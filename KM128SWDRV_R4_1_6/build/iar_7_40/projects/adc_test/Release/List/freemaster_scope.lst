###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        16/Mar/2017  11:18:06
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_scope.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_scope.c -D
#        NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\Release\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\..\..\..\..\src\projects\adc_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\..\..\..\..\src\toolchain\iar\
#        -Ol --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\Release\List\freemaster_scope.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\Release\Obj\freemaster_scope.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_scope.c
      1          /*******************************************************************************
      2          *
      3          * Copyright 2004-2013 Freescale Semiconductor, Inc.
      4          *
      5          * This software is owned or controlled by Freescale Semiconductor.
      6          * Use of this software is governed by the Freescale FreeMASTER License
      7          * distributed with this Material.
      8          * See the license file distributed for more details.
      9          *
     10          ****************************************************************************//*!
     11          *
     12          * @brief  FreeMASTER Oscilloscope implementation
     13          *
     14          *******************************************************************************/
     15          
     16          #include "freemaster.h"
     17          #include "freemaster_private.h"
     18          #include "freemaster_protocol.h"
     19          
     20          #if (FMSTR_USE_SCOPE) && (!(FMSTR_DISABLE))
     21          
     22          /***********************************
     23          *  local variables
     24          ***********************************/
     25          

   \                                 In section .bss, align 1
     26          static FMSTR_U8  pcm_nScopeVarCount;        /* number of active scope variables */
   \                     pcm_nScopeVarCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     27          static FMSTR_ADDR  pcm_pScopeVarAddr[FMSTR_MAX_SCOPE_VARS]; /* addresses of scope variables */
   \                     pcm_pScopeVarAddr:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
     28          static FMSTR_SIZE8 pcm_pScopeVarSize[FMSTR_MAX_SCOPE_VARS]; /* sizes of scope variables */
   \                     pcm_pScopeVarSize:
   \   00000000                      DS8 8
     29          
     30          /**************************************************************************//*!
     31          *
     32          * @brief    Scope Initialization
     33          *
     34          ******************************************************************************/
     35          

   \                                 In section .text, align 2, keep-with-next
     36          void FMSTR_InitScope(void)
     37          {
     38          }
   \                     FMSTR_InitScope: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     39          
     40          /**************************************************************************//*!
     41          *
     42          * @brief    Handling SETUPSCOPE and SETUPSCOPE_EX command
     43          *
     44          * @param    pMessageIO - original command (in) and response buffer (out)
     45          *
     46          * @return   As all command handlers, the return value should be the buffer
     47          *           pointer where the response output finished (except checksum)
     48          *
     49          ******************************************************************************/
     50          

   \                                 In section .text, align 2, keep-with-next
     51          FMSTR_BPTR FMSTR_SetUpScope(FMSTR_BPTR pMessageIO)
     52          {
   \                     FMSTR_SetUpScope: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
     53              FMSTR_BPTR pResponse = pMessageIO;
   \   00000002   0x0006             MOVS     R6,R0
     54              FMSTR_U8 i, sz, nVarCnt;
     55          
     56              /* uninitialize scope */
     57              pcm_nScopeVarCount = 0U;
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x....             LDR      R2,??DataTable1
   \   00000008   0x7011             STRB     R1,[R2, #+0]
     58          
     59              /* seek the setup data */
     60              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
   \   0000000A   0x1C80             ADDS     R0,R0,#+2
     61          
     62              /* scope variable count  */
     63              pMessageIO = FMSTR_ValueFromBuffer8(&nVarCnt, pMessageIO);
   \   0000000C   0x7807             LDRB     R7,[R0, #+0]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
     64          
     65              /* scope variable information must fit into our buffers */
     66              if(!nVarCnt || nVarCnt > (FMSTR_U8)FMSTR_MAX_SCOPE_VARS)
   \   00000010   0xB2FF             UXTB     R7,R7
   \   00000012   0x2F00             CMP      R7,#+0
   \   00000014   0xD002             BEQ      ??FMSTR_SetUpScope_0
   \   00000016   0xB2FF             UXTB     R7,R7
   \   00000018   0x2F09             CMP      R7,#+9
   \   0000001A   0xDB04             BLT      ??FMSTR_SetUpScope_1
     67              {
     68                  return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_INVBUFF);
   \                     ??FMSTR_SetUpScope_0: (+1)
   \   0000001C   0x2085             MOVS     R0,#+133
   \   0000001E   0x7030             STRB     R0,[R6, #+0]
   \   00000020   0x1C76             ADDS     R6,R6,#+1
   \   00000022   0x0030             MOVS     R0,R6
   \   00000024   0xE024             B        ??FMSTR_SetUpScope_2
     69              }
     70          
     71              /* get all addresses and sizes */
     72              for(i=0U; i<nVarCnt; i++)
   \                     ??FMSTR_SetUpScope_1: (+1)
   \   00000026   0x2400             MOVS     R4,#+0
   \   00000028   0xE000             B        ??FMSTR_SetUpScope_3
   \                     ??FMSTR_SetUpScope_4: (+1)
   \   0000002A   0x1C64             ADDS     R4,R4,#+1
   \                     ??FMSTR_SetUpScope_3: (+1)
   \   0000002C   0xB2E4             UXTB     R4,R4
   \   0000002E   0xB2FF             UXTB     R7,R7
   \   00000030   0x42BC             CMP      R4,R7
   \   00000032   0xD217             BCS      ??FMSTR_SetUpScope_5
     73              {
     74                  /* variable size */
     75                  pMessageIO = FMSTR_ValueFromBuffer8(&sz, pMessageIO);
   \   00000034   0x7805             LDRB     R5,[R0, #+0]
   \   00000036   0x1C40             ADDS     R0,R0,#+1
     76                  pcm_pScopeVarSize[i] = sz;
   \   00000038   0x....             LDR      R1,??DataTable1_1
   \   0000003A   0xB2E4             UXTB     R4,R4
   \   0000003C   0x550D             STRB     R5,[R1, R4]
     77          
     78                  /* variable address */
     79                  pMessageIO = FMSTR_AddressFromBuffer(&pcm_pScopeVarAddr[i], pMessageIO);
   \   0000003E   0x0001             MOVS     R1,R0
   \   00000040   0x....             LDR      R0,??DataTable1_2
   \   00000042   0xB2E4             UXTB     R4,R4
   \   00000044   0x2204             MOVS     R2,#+4
   \   00000046   0x4362             MULS     R2,R4,R2
   \   00000048   0x1880             ADDS     R0,R0,R2
   \   0000004A   0x.... 0x....      BL       FMSTR_AddressFromBuffer
     80          
     81                  /* valid numeric variable sizes only */
     82                  if(sz == 0U || sz > 8U)
   \   0000004E   0xB2ED             UXTB     R5,R5
   \   00000050   0x2D00             CMP      R5,#+0
   \   00000052   0xD002             BEQ      ??FMSTR_SetUpScope_6
   \   00000054   0xB2ED             UXTB     R5,R5
   \   00000056   0x2D09             CMP      R5,#+9
   \   00000058   0xD3E7             BCC      ??FMSTR_SetUpScope_4
     83                  {
     84                      return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_INVSIZE);
   \                     ??FMSTR_SetUpScope_6: (+1)
   \   0000005A   0x2086             MOVS     R0,#+134
   \   0000005C   0x7030             STRB     R0,[R6, #+0]
   \   0000005E   0x1C76             ADDS     R6,R6,#+1
   \   00000060   0x0030             MOVS     R0,R6
   \   00000062   0xE005             B        ??FMSTR_SetUpScope_2
     85                  }
     86          
     87          #if FMSTR_CFG_BUS_WIDTH > 1U
     88                  /* even sizes only */
     89                  if(sz & 0x1)
     90                  {
     91                      return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_INVSIZE);
     92                  }
     93          #endif
     94          
     95          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
     96                  if(!FMSTR_CheckTsaSpace(pcm_pScopeVarAddr[i], (FMSTR_SIZE8) sz, 0U))
     97                  {
     98                      return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_EACCESS);
     99                  }
    100          #endif
    101          
    102              }
    103          
    104              /* activate scope */
    105              pcm_nScopeVarCount = nVarCnt;
   \                     ??FMSTR_SetUpScope_5: (+1)
   \   00000064   0x....             LDR      R0,??DataTable1
   \   00000066   0x7007             STRB     R7,[R0, #+0]
    106          
    107              /* return just a status */
    108              return FMSTR_ConstToBuffer8(pResponse, FMSTR_STS_OK);
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x7030             STRB     R0,[R6, #+0]
   \   0000006C   0x1C76             ADDS     R6,R6,#+1
   \   0000006E   0x0030             MOVS     R0,R6
   \                     ??FMSTR_SetUpScope_2: (+1)
   \   00000070   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    109          }
    110          
    111          /**************************************************************************//*!
    112          *
    113          * @brief    Handling READSCOPE command
    114          *
    115          * @param    pMessageIO - original command (in) and response buffer (out)
    116          *
    117          * @return   As all command handlers, the return value should be the buffer
    118          *           pointer where the response output finished (except checksum)
    119          *
    120          ******************************************************************************/
    121          

   \                                 In section .text, align 2, keep-with-next
    122          FMSTR_BPTR FMSTR_ReadScope(FMSTR_BPTR pMessageIO)
    123          {
   \                     FMSTR_ReadScope: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    124              FMSTR_U8 i;
    125          
    126              if(!pcm_nScopeVarCount)
   \   00000002   0x....             LDR      R1,??DataTable1
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE      ??FMSTR_ReadScope_0
    127              {
    128                  return FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STC_NOTINIT);
   \   0000000A   0x2188             MOVS     R1,#+136
   \   0000000C   0x7001             STRB     R1,[R0, #+0]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0xE014             B        ??FMSTR_ReadScope_1
    129              }
    130          
    131              /* success */
    132              pMessageIO = FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STS_OK);
   \                     ??FMSTR_ReadScope_0: (+1)
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x7001             STRB     R1,[R0, #+0]
   \   00000016   0x1C40             ADDS     R0,R0,#+1
    133          
    134              for (i=0U; i<pcm_nScopeVarCount; i++)
   \   00000018   0x2400             MOVS     R4,#+0
   \   0000001A   0xE00A             B        ??FMSTR_ReadScope_2
    135              {
    136                  pMessageIO = FMSTR_CopyToBuffer(pMessageIO, pcm_pScopeVarAddr[i], pcm_pScopeVarSize[i]);
   \                     ??FMSTR_ReadScope_3: (+1)
   \   0000001C   0x....             LDR      R1,??DataTable1_1
   \   0000001E   0xB2E4             UXTB     R4,R4
   \   00000020   0x5D0A             LDRB     R2,[R1, R4]
   \   00000022   0x....             LDR      R1,??DataTable1_2
   \   00000024   0xB2E4             UXTB     R4,R4
   \   00000026   0x2304             MOVS     R3,#+4
   \   00000028   0x4363             MULS     R3,R4,R3
   \   0000002A   0x58C9             LDR      R1,[R1, R3]
   \   0000002C   0x.... 0x....      BL       FMSTR_CopyToBuffer
    137              }
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \                     ??FMSTR_ReadScope_2: (+1)
   \   00000032   0x....             LDR      R1,??DataTable1
   \   00000034   0x7809             LDRB     R1,[R1, #+0]
   \   00000036   0xB2E4             UXTB     R4,R4
   \   00000038   0x428C             CMP      R4,R1
   \   0000003A   0xD3EF             BCC      ??FMSTR_ReadScope_3
    138          
    139              /* return end position */
    140              return pMessageIO;
   \                     ??FMSTR_ReadScope_1: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    141          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     pcm_nScopeVarCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     pcm_pScopeVarSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     pcm_pScopeVarAddr
    142          
    143          #else  /* (FMSTR_USE_SCOPE) && !(FMSTR_DISABLE) */
    144          
    145          /*lint -efile(766, freemaster_protocol.h) include file is not used in this case */
    146          
    147          #endif /* (FMSTR_USE_SCOPE) && !(FMSTR_DISABLE) */
    148          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FMSTR_InitScope
       8   FMSTR_ReadScope
         8   -> FMSTR_CopyToBuffer
      24   FMSTR_SetUpScope
        24   -> FMSTR_AddressFromBuffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       2  FMSTR_InitScope
      62  FMSTR_ReadScope
     114  FMSTR_SetUpScope
       1  pcm_nScopeVarCount
      32  pcm_pScopeVarAddr
       8  pcm_pScopeVarSize

 
  41 bytes in section .bss
 190 bytes in section .text
 
 190 bytes of CODE memory
  41 bytes of DATA memory

Errors: none
Warnings: none
