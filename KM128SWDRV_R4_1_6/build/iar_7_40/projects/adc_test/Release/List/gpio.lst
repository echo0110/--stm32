###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        16/Mar/2017  11:18:06
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\gpio\gpio.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\gpio\gpio.c -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\Release\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\..\..\..\..\src\projects\adc_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\..\..\..\..\src\toolchain\iar\
#        -Ol --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\Release\List\gpio.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\adc_test\Release\Obj\gpio.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\gpio\gpio.c
      1          /******************************************************************************
      2           * (c) Copyright 2010-2015, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ***************************************************************************//*!
      5           * @file      gpio.c
      6           * @version   1.0.6.0
      7           * @date      Jun-11-2015
      8           * @brief     General-Purpose Input/Output (GPIO) driver source code.
      9           ******************************************************************************/
     10          #include "common.h"
     11          #include "gpio.h"
     12          
     13          #if !defined(MCU_MKM34ZA5)
     14            #error "The gpio.c module is specific to the MKMxxZxxACxx5 microcontrollers."
     15          #endif
     16          
     17          /******************************************************************************
     18           * data type definitions                                                      *
     19           ******************************************************************************/

   \                                 In section .bss, align 4
     20          static PORT_CALLBACK pCallbackPTx;
   \                     pCallbackPTx:
   \   00000000                      DS8 4
     21          
     22          /******************************************************************************
     23           * public function definitions                                                *
     24           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     25          void PORT_InstallCallback (uint8 ip, PORT_CALLBACK pCallback)
     26          {
   \                     PORT_InstallCallback: (+1)
   \   00000000   0xB500             PUSH     {LR}
     27            if (pCallback) { pCallbackPTx = pCallback; NVIC_SetIsr(INT_PTx,ip); }
   \   00000002   0x000A             MOVS     R2,R1
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0xD016             BEQ      ??PORT_InstallCallback_0
   \   00000008   0x....             LDR      R2,??DataTable9
   \   0000000A   0x6011             STR      R1,[R2, #+0]
   \   0000000C   0x....             LDR      R1,??DataTable9_1  ;; 0xe000e280
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x2280             MOVS     R2,#+128
   \   00000012   0x0292             LSLS     R2,R2,#+10       ;; #+131072
   \   00000014   0x430A             ORRS     R2,R2,R1
   \   00000016   0x....             LDR      R1,??DataTable9_1  ;; 0xe000e280
   \   00000018   0x600A             STR      R2,[R1, #+0]
   \   0000001A   0x....             LDR      R1,??DataTable9_2  ;; 0xe000e100
   \   0000001C   0x6809             LDR      R1,[R1, #+0]
   \   0000001E   0x2280             MOVS     R2,#+128
   \   00000020   0x0292             LSLS     R2,R2,#+10       ;; #+131072
   \   00000022   0x430A             ORRS     R2,R2,R1
   \   00000024   0x....             LDR      R1,??DataTable9_2  ;; 0xe000e100
   \   00000026   0x600A             STR      R2,[R1, #+0]
   \   00000028   0x....             LDR      R1,??DataTable9_3  ;; 0xe000e410
   \   0000002A   0x6809             LDR      R1,[R1, #+0]
   \   0000002C   0xB2C0             UXTB     R0,R0
   \   0000002E   0x0380             LSLS     R0,R0,#+14
   \   00000030   0x4308             ORRS     R0,R0,R1
   \   00000032   0x....             LDR      R1,??DataTable9_3  ;; 0xe000e410
   \   00000034   0x6008             STR      R0,[R1, #+0]
     28          }
   \                     ??PORT_InstallCallback_0: (+1)
   \   00000036   0xBD00             POP      {PC}             ;; return
     29          

   \                                 In section .text, align 2, keep-with-next
     30          void PORTA_Init (tPORT port, uint8 pin_mask)
     31          {
   \                     PORTA_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
     32            register uint16 i;
     33          
     34            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE00B             B        ??PORTA_Init_0
     35              if(pin_mask & (uint8)(1u << i)) { PORTA_BASE_PTR->PCR[i] = port.PCR; }
   \                     ??PORTA_Init_1: (+1)
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x409C             LSLS     R4,R4,R3
   \   0000000A   0x0015             MOVS     R5,R2
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x4225             TST      R5,R4
   \   00000010   0xD004             BEQ      ??PORTA_Init_2
   \   00000012   0x....             LDR      R4,??DataTable9_4  ;; 0x40046000
   \   00000014   0xB29B             UXTH     R3,R3
   \   00000016   0x2504             MOVS     R5,#+4
   \   00000018   0x435D             MULS     R5,R3,R5
   \   0000001A   0x5160             STR      R0,[R4, R5]
   \                     ??PORTA_Init_2: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??PORTA_Init_0: (+1)
   \   0000001E   0xB29B             UXTH     R3,R3
   \   00000020   0x2B08             CMP      R3,#+8
   \   00000022   0xDBF0             BLT      ??PORTA_Init_1
     36            PORTA_ISFR = pin_mask;
   \   00000024   0xB2D2             UXTB     R2,R2
   \   00000026   0x....             LDR      R0,??DataTable10  ;; 0x400460a0
   \   00000028   0x6002             STR      R2,[R0, #+0]
     37          }
   \   0000002A   0xBD30             POP      {R4,R5,PC}       ;; return
     38          

   \                                 In section .text, align 2, keep-with-next
     39          void PORTB_Init (tPORT port, uint8 pin_mask)
     40          {
   \                     PORTB_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
     41            register uint16 i;
     42          
     43            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE00B             B        ??PORTB_Init_0
     44              if(pin_mask & (uint8)(1u << i)) { PORTB_BASE_PTR->PCR[i] = port.PCR; }
   \                     ??PORTB_Init_1: (+1)
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x409C             LSLS     R4,R4,R3
   \   0000000A   0x0015             MOVS     R5,R2
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x4225             TST      R5,R4
   \   00000010   0xD004             BEQ      ??PORTB_Init_2
   \   00000012   0x....             LDR      R4,??DataTable9_5  ;; 0x40047000
   \   00000014   0xB29B             UXTH     R3,R3
   \   00000016   0x2504             MOVS     R5,#+4
   \   00000018   0x435D             MULS     R5,R3,R5
   \   0000001A   0x5160             STR      R0,[R4, R5]
   \                     ??PORTB_Init_2: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??PORTB_Init_0: (+1)
   \   0000001E   0xB29B             UXTH     R3,R3
   \   00000020   0x2B08             CMP      R3,#+8
   \   00000022   0xDBF0             BLT      ??PORTB_Init_1
     45            PORTB_ISFR = pin_mask;
   \   00000024   0xB2D2             UXTB     R2,R2
   \   00000026   0x....             LDR      R0,??DataTable10_1  ;; 0x400470a0
   \   00000028   0x6002             STR      R2,[R0, #+0]
     46          }
   \   0000002A   0xBD30             POP      {R4,R5,PC}       ;; return
     47          

   \                                 In section .text, align 2, keep-with-next
     48          void PORTC_Init (tPORT port, uint8 pin_mask)
     49          {
   \                     PORTC_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
     50            register uint16 i;
     51          
     52            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE00B             B        ??PORTC_Init_0
     53              if(pin_mask & (uint8)(1u << i)) { PORTC_BASE_PTR->PCR[i] = port.PCR; }
   \                     ??PORTC_Init_1: (+1)
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x409C             LSLS     R4,R4,R3
   \   0000000A   0x0015             MOVS     R5,R2
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x4225             TST      R5,R4
   \   00000010   0xD004             BEQ      ??PORTC_Init_2
   \   00000012   0x....             LDR      R4,??DataTable9_6  ;; 0x40048000
   \   00000014   0xB29B             UXTH     R3,R3
   \   00000016   0x2504             MOVS     R5,#+4
   \   00000018   0x435D             MULS     R5,R3,R5
   \   0000001A   0x5160             STR      R0,[R4, R5]
   \                     ??PORTC_Init_2: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??PORTC_Init_0: (+1)
   \   0000001E   0xB29B             UXTH     R3,R3
   \   00000020   0x2B08             CMP      R3,#+8
   \   00000022   0xDBF0             BLT      ??PORTC_Init_1
     54            PORTC_ISFR = pin_mask;
   \   00000024   0xB2D2             UXTB     R2,R2
   \   00000026   0x....             LDR      R0,??DataTable10_2  ;; 0x400480a0
   \   00000028   0x6002             STR      R2,[R0, #+0]
     55          }
   \   0000002A   0xBD30             POP      {R4,R5,PC}       ;; return
     56          

   \                                 In section .text, align 2, keep-with-next
     57          void PORTD_Init (tPORT port, uint8 pin_mask)
     58          {
   \                     PORTD_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
     59            register uint16 i;
     60          
     61            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE00B             B        ??PORTD_Init_0
     62              if(pin_mask & (uint8)(1u << i)) { PORTD_BASE_PTR->PCR[i] = port.PCR; }
   \                     ??PORTD_Init_1: (+1)
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x409C             LSLS     R4,R4,R3
   \   0000000A   0x0015             MOVS     R5,R2
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x4225             TST      R5,R4
   \   00000010   0xD004             BEQ      ??PORTD_Init_2
   \   00000012   0x....             LDR      R4,??DataTable10_3  ;; 0x40049000
   \   00000014   0xB29B             UXTH     R3,R3
   \   00000016   0x2504             MOVS     R5,#+4
   \   00000018   0x435D             MULS     R5,R3,R5
   \   0000001A   0x5160             STR      R0,[R4, R5]
   \                     ??PORTD_Init_2: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??PORTD_Init_0: (+1)
   \   0000001E   0xB29B             UXTH     R3,R3
   \   00000020   0x2B08             CMP      R3,#+8
   \   00000022   0xDBF0             BLT      ??PORTD_Init_1
     63            PORTD_ISFR = pin_mask;
   \   00000024   0xB2D2             UXTB     R2,R2
   \   00000026   0x....             LDR      R0,??DataTable10_4  ;; 0x400490a0
   \   00000028   0x6002             STR      R2,[R0, #+0]
     64          }
   \   0000002A   0xBD30             POP      {R4,R5,PC}       ;; return
     65          

   \                                 In section .text, align 2, keep-with-next
     66          void PORTE_Init (tPORT port, uint8 pin_mask)
     67          {
   \                     PORTE_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
     68            register uint16 i;
     69          
     70            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE00B             B        ??PORTE_Init_0
     71              if(pin_mask & (uint8)(1u << i)) { PORTE_BASE_PTR->PCR[i] = port.PCR; }
   \                     ??PORTE_Init_1: (+1)
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x409C             LSLS     R4,R4,R3
   \   0000000A   0x0015             MOVS     R5,R2
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x4225             TST      R5,R4
   \   00000010   0xD004             BEQ      ??PORTE_Init_2
   \   00000012   0x....             LDR      R4,??DataTable10_5  ;; 0x4004a000
   \   00000014   0xB29B             UXTH     R3,R3
   \   00000016   0x2504             MOVS     R5,#+4
   \   00000018   0x435D             MULS     R5,R3,R5
   \   0000001A   0x5160             STR      R0,[R4, R5]
   \                     ??PORTE_Init_2: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??PORTE_Init_0: (+1)
   \   0000001E   0xB29B             UXTH     R3,R3
   \   00000020   0x2B08             CMP      R3,#+8
   \   00000022   0xDBF0             BLT      ??PORTE_Init_1
     72            PORTE_DFER |= (port.DFER & pin_mask); /* DFER content OR-ed with pin_mask   */
   \   00000024   0x....             LDR      R3,??DataTable10_6  ;; 0x4004a0c0
   \   00000026   0x681B             LDR      R3,[R3, #+0]
   \   00000028   0xB2D2             UXTB     R2,R2
   \   0000002A   0x4011             ANDS     R1,R1,R2
   \   0000002C   0x4319             ORRS     R1,R1,R3
   \   0000002E   0x....             LDR      R0,??DataTable10_6  ;; 0x4004a0c0
   \   00000030   0x6001             STR      R1,[R0, #+0]
     73            PORTE_ISFR  = pin_mask;
   \   00000032   0xB2D2             UXTB     R2,R2
   \   00000034   0x....             LDR      R0,??DataTable10_7  ;; 0x4004a0a0
   \   00000036   0x6002             STR      R2,[R0, #+0]
     74          }
   \   00000038   0xBD30             POP      {R4,R5,PC}       ;; return
     75          

   \                                 In section .text, align 2, keep-with-next
     76          void PORTF_Init (tPORT port, uint8 pin_mask)
     77          {
   \                     PORTF_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
     78            register uint16 i;
     79          
     80            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE00B             B        ??PORTF_Init_0
     81              if(pin_mask & (uint8)(1u << i)) { PORTF_BASE_PTR->PCR[i] = port.PCR; }
   \                     ??PORTF_Init_1: (+1)
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x409C             LSLS     R4,R4,R3
   \   0000000A   0x0015             MOVS     R5,R2
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x4225             TST      R5,R4
   \   00000010   0xD004             BEQ      ??PORTF_Init_2
   \   00000012   0x....             LDR      R4,??DataTable10_8  ;; 0x4004b000
   \   00000014   0xB29B             UXTH     R3,R3
   \   00000016   0x2504             MOVS     R5,#+4
   \   00000018   0x435D             MULS     R5,R3,R5
   \   0000001A   0x5160             STR      R0,[R4, R5]
   \                     ??PORTF_Init_2: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??PORTF_Init_0: (+1)
   \   0000001E   0xB29B             UXTH     R3,R3
   \   00000020   0x2B08             CMP      R3,#+8
   \   00000022   0xDBF0             BLT      ??PORTF_Init_1
     82            PORTF_ISFR = pin_mask;
   \   00000024   0xB2D2             UXTB     R2,R2
   \   00000026   0x....             LDR      R0,??DataTable10_9  ;; 0x4004b0a0
   \   00000028   0x6002             STR      R2,[R0, #+0]
     83          }
   \   0000002A   0xBD30             POP      {R4,R5,PC}       ;; return
     84          

   \                                 In section .text, align 2, keep-with-next
     85          void PORTG_Init (tPORT port, uint8 pin_mask)
     86          {
   \                     PORTG_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
     87            register uint16 i;
     88          
     89            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE00B             B        ??PORTG_Init_0
     90              if(pin_mask & (uint8)(1u << i)) { PORTG_BASE_PTR->PCR[i] = port.PCR; }
   \                     ??PORTG_Init_1: (+1)
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x409C             LSLS     R4,R4,R3
   \   0000000A   0x0015             MOVS     R5,R2
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x4225             TST      R5,R4
   \   00000010   0xD004             BEQ      ??PORTG_Init_2
   \   00000012   0x....             LDR      R4,??DataTable10_10  ;; 0x4004c000
   \   00000014   0xB29B             UXTH     R3,R3
   \   00000016   0x2504             MOVS     R5,#+4
   \   00000018   0x435D             MULS     R5,R3,R5
   \   0000001A   0x5160             STR      R0,[R4, R5]
   \                     ??PORTG_Init_2: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??PORTG_Init_0: (+1)
   \   0000001E   0xB29B             UXTH     R3,R3
   \   00000020   0x2B08             CMP      R3,#+8
   \   00000022   0xDBF0             BLT      ??PORTG_Init_1
     91            PORTG_ISFR = pin_mask;
   \   00000024   0xB2D2             UXTB     R2,R2
   \   00000026   0x....             LDR      R0,??DataTable10_11  ;; 0x4004c0a0
   \   00000028   0x6002             STR      R2,[R0, #+0]
     92          }
   \   0000002A   0xBD30             POP      {R4,R5,PC}       ;; return
     93          

   \                                 In section .text, align 2, keep-with-next
     94          void PORTH_Init (tPORT port, uint8 pin_mask)
     95          {
   \                     PORTH_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
     96            register uint16 i;
     97          
     98            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE00B             B        ??PORTH_Init_0
     99              if(pin_mask & (uint8)(1u << i)) { PORTH_BASE_PTR->PCR[i] = port.PCR; }
   \                     ??PORTH_Init_1: (+1)
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x409C             LSLS     R4,R4,R3
   \   0000000A   0x0015             MOVS     R5,R2
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x4225             TST      R5,R4
   \   00000010   0xD004             BEQ      ??PORTH_Init_2
   \   00000012   0x....             LDR      R4,??DataTable10_12  ;; 0x4004d000
   \   00000014   0xB29B             UXTH     R3,R3
   \   00000016   0x2504             MOVS     R5,#+4
   \   00000018   0x435D             MULS     R5,R3,R5
   \   0000001A   0x5160             STR      R0,[R4, R5]
   \                     ??PORTH_Init_2: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??PORTH_Init_0: (+1)
   \   0000001E   0xB29B             UXTH     R3,R3
   \   00000020   0x2B08             CMP      R3,#+8
   \   00000022   0xDBF0             BLT      ??PORTH_Init_1
    100            PORTH_ISFR = pin_mask;
   \   00000024   0xB2D2             UXTB     R2,R2
   \   00000026   0x....             LDR      R0,??DataTable10_13  ;; 0x4004d0a0
   \   00000028   0x6002             STR      R2,[R0, #+0]
    101          }
   \   0000002A   0xBD30             POP      {R4,R5,PC}       ;; return
    102          

   \                                 In section .text, align 2, keep-with-next
    103          void PORTI_Init (tPORT port, uint8 pin_mask)
    104          {
   \                     PORTI_Init: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    105            register uint16 i;
    106          
    107            for (i=0; i<8; i++)
   \   00000002   0x2300             MOVS     R3,#+0
   \   00000004   0xE00B             B        ??PORTI_Init_0
    108              if(pin_mask & (uint8)(1u << i)) { PORTI_BASE_PTR->PCR[i] = port.PCR; }
   \                     ??PORTI_Init_1: (+1)
   \   00000006   0x2401             MOVS     R4,#+1
   \   00000008   0x409C             LSLS     R4,R4,R3
   \   0000000A   0x0015             MOVS     R5,R2
   \   0000000C   0xB2ED             UXTB     R5,R5
   \   0000000E   0x4225             TST      R5,R4
   \   00000010   0xD004             BEQ      ??PORTI_Init_2
   \   00000012   0x....             LDR      R4,??DataTable10_14  ;; 0x4004e000
   \   00000014   0xB29B             UXTH     R3,R3
   \   00000016   0x2504             MOVS     R5,#+4
   \   00000018   0x435D             MULS     R5,R3,R5
   \   0000001A   0x5160             STR      R0,[R4, R5]
   \                     ??PORTI_Init_2: (+1)
   \   0000001C   0x1C5B             ADDS     R3,R3,#+1
   \                     ??PORTI_Init_0: (+1)
   \   0000001E   0xB29B             UXTH     R3,R3
   \   00000020   0x2B08             CMP      R3,#+8
   \   00000022   0xDBF0             BLT      ??PORTI_Init_1
    109            PORTI_ISFR = pin_mask;
   \   00000024   0xB2D2             UXTB     R2,R2
   \   00000026   0x....             LDR      R0,??DataTable10_15  ;; 0x4004e0a0
   \   00000028   0x6002             STR      R2,[R0, #+0]
    110          }
   \   0000002A   0xBD30             POP      {R4,R5,PC}       ;; return
    111          
    112          /******************************************************************************
    113           * interrupt function definitions                                             *
    114           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    115          weak void portx_isr (void)
    116          {
   \                     portx_isr: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    117            register uint8 tmp;
    118          
    119            /* process interrupt callback function for PORTA                            */
    120            if (SIM_SCGC5 & SIM_SCGC5_PORTA_MASK)
   \   00000002   0x....             LDR      R0,??DataTable10_16  ;; 0x4003f038
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0640             LSLS     R0,R0,#+25
   \   00000008   0xD50C             BPL      ??portx_isr_0
    121            {
    122              PORTA_ISFR = tmp = (uint8)PORTA_ISFR; /* read and clear interrupt flags   */
   \   0000000A   0x....             LDR      R0,??DataTable10  ;; 0x400460a0
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0x....             LDR      R0,??DataTable10  ;; 0x400460a0
   \   00000012   0x6001             STR      R1,[R0, #+0]
    123              if (tmp != 0) { pCallbackPTx (PORTA_CALLBACK, tmp); }
   \   00000014   0xB2C9             UXTB     R1,R1
   \   00000016   0x2900             CMP      R1,#+0
   \   00000018   0xD004             BEQ      ??portx_isr_0
   \   0000001A   0xB2C9             UXTB     R1,R1
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x....             LDR      R2,??DataTable10_17
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0x4790             BLX      R2
    124            }
    125          
    126            /* process interrupt callback function for PORTB                            */
    127            if (SIM_SCGC5 & SIM_SCGC5_PORTB_MASK)
   \                     ??portx_isr_0: (+1)
   \   00000024   0x....             LDR      R0,??DataTable10_16  ;; 0x4003f038
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0600             LSLS     R0,R0,#+24
   \   0000002A   0xD50C             BPL      ??portx_isr_1
    128            {
    129              PORTB_ISFR = tmp = (uint8)PORTB_ISFR; /* read and clear interrupt flags   */
   \   0000002C   0x....             LDR      R0,??DataTable10_1  ;; 0x400470a0
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0xB2C9             UXTB     R1,R1
   \   00000032   0x....             LDR      R0,??DataTable10_1  ;; 0x400470a0
   \   00000034   0x6001             STR      R1,[R0, #+0]
    130              if (tmp != 0) { pCallbackPTx (PORTB_CALLBACK, tmp); }
   \   00000036   0xB2C9             UXTB     R1,R1
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD004             BEQ      ??portx_isr_1
   \   0000003C   0xB2C9             UXTB     R1,R1
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x....             LDR      R2,??DataTable10_17
   \   00000042   0x6812             LDR      R2,[R2, #+0]
   \   00000044   0x4790             BLX      R2
    131            }
    132          
    133            /* process interrupt callback function for PORTC                            */
    134            if (SIM_SCGC5 & SIM_SCGC5_PORTC_MASK)
   \                     ??portx_isr_1: (+1)
   \   00000046   0x....             LDR      R0,??DataTable10_16  ;; 0x4003f038
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x05C0             LSLS     R0,R0,#+23
   \   0000004C   0xD50C             BPL      ??portx_isr_2
    135            {
    136              PORTC_ISFR = tmp = (uint8)PORTC_ISFR; /* read and clear interrupt flags   */
   \   0000004E   0x....             LDR      R0,??DataTable10_2  ;; 0x400480a0
   \   00000050   0x6801             LDR      R1,[R0, #+0]
   \   00000052   0xB2C9             UXTB     R1,R1
   \   00000054   0x....             LDR      R0,??DataTable10_2  ;; 0x400480a0
   \   00000056   0x6001             STR      R1,[R0, #+0]
    137              if (tmp != 0) { pCallbackPTx (PORTC_CALLBACK, tmp); }
   \   00000058   0xB2C9             UXTB     R1,R1
   \   0000005A   0x2900             CMP      R1,#+0
   \   0000005C   0xD004             BEQ      ??portx_isr_2
   \   0000005E   0xB2C9             UXTB     R1,R1
   \   00000060   0x2003             MOVS     R0,#+3
   \   00000062   0x....             LDR      R2,??DataTable10_17
   \   00000064   0x6812             LDR      R2,[R2, #+0]
   \   00000066   0x4790             BLX      R2
    138            }
    139          
    140            /* process interrupt callback function for PORTD                            */
    141            if (SIM_SCGC5 & SIM_SCGC5_PORTD_MASK)
   \                     ??portx_isr_2: (+1)
   \   00000068   0x....             LDR      R0,??DataTable10_16  ;; 0x4003f038
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x0580             LSLS     R0,R0,#+22
   \   0000006E   0xD50C             BPL      ??portx_isr_3
    142            {
    143              PORTD_ISFR = tmp = (uint8)PORTD_ISFR; /* read and clear interrupt flags   */
   \   00000070   0x....             LDR      R0,??DataTable10_4  ;; 0x400490a0
   \   00000072   0x6801             LDR      R1,[R0, #+0]
   \   00000074   0xB2C9             UXTB     R1,R1
   \   00000076   0x....             LDR      R0,??DataTable10_4  ;; 0x400490a0
   \   00000078   0x6001             STR      R1,[R0, #+0]
    144              if (tmp != 0) { pCallbackPTx (PORTD_CALLBACK, tmp); }
   \   0000007A   0xB2C9             UXTB     R1,R1
   \   0000007C   0x2900             CMP      R1,#+0
   \   0000007E   0xD004             BEQ      ??portx_isr_3
   \   00000080   0xB2C9             UXTB     R1,R1
   \   00000082   0x2004             MOVS     R0,#+4
   \   00000084   0x....             LDR      R2,??DataTable10_17
   \   00000086   0x6812             LDR      R2,[R2, #+0]
   \   00000088   0x4790             BLX      R2
    145            }
    146          
    147            /* process interrupt callback function for PORTE                            */
    148            if (SIM_SCGC5 & SIM_SCGC5_PORTE_MASK)
   \                     ??portx_isr_3: (+1)
   \   0000008A   0x....             LDR      R0,??DataTable10_16  ;; 0x4003f038
   \   0000008C   0x6800             LDR      R0,[R0, #+0]
   \   0000008E   0x0540             LSLS     R0,R0,#+21
   \   00000090   0xD50C             BPL      ??portx_isr_4
    149            {
    150              PORTE_ISFR = tmp = (uint8)PORTE_ISFR; /* read and clear interrupt flags   */
   \   00000092   0x....             LDR      R0,??DataTable10_7  ;; 0x4004a0a0
   \   00000094   0x6801             LDR      R1,[R0, #+0]
   \   00000096   0xB2C9             UXTB     R1,R1
   \   00000098   0x....             LDR      R0,??DataTable10_7  ;; 0x4004a0a0
   \   0000009A   0x6001             STR      R1,[R0, #+0]
    151              if (tmp != 0) { pCallbackPTx (PORTE_CALLBACK, tmp); }
   \   0000009C   0xB2C9             UXTB     R1,R1
   \   0000009E   0x2900             CMP      R1,#+0
   \   000000A0   0xD004             BEQ      ??portx_isr_4
   \   000000A2   0xB2C9             UXTB     R1,R1
   \   000000A4   0x2005             MOVS     R0,#+5
   \   000000A6   0x....             LDR      R2,??DataTable10_17
   \   000000A8   0x6812             LDR      R2,[R2, #+0]
   \   000000AA   0x4790             BLX      R2
    152            }
    153          
    154            /* process interrupt callback function for PORTF                            */
    155            if (SIM_SCGC5 & SIM_SCGC5_PORTF_MASK)
   \                     ??portx_isr_4: (+1)
   \   000000AC   0x....             LDR      R0,??DataTable10_16  ;; 0x4003f038
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x0500             LSLS     R0,R0,#+20
   \   000000B2   0xD50C             BPL      ??portx_isr_5
    156            {
    157              PORTF_ISFR = tmp = (uint8)PORTF_ISFR; /* read and clear interrupt flags   */
   \   000000B4   0x....             LDR      R0,??DataTable10_9  ;; 0x4004b0a0
   \   000000B6   0x6801             LDR      R1,[R0, #+0]
   \   000000B8   0xB2C9             UXTB     R1,R1
   \   000000BA   0x....             LDR      R0,??DataTable10_9  ;; 0x4004b0a0
   \   000000BC   0x6001             STR      R1,[R0, #+0]
    158              if (tmp != 0) { pCallbackPTx (PORTF_CALLBACK, tmp); }
   \   000000BE   0xB2C9             UXTB     R1,R1
   \   000000C0   0x2900             CMP      R1,#+0
   \   000000C2   0xD004             BEQ      ??portx_isr_5
   \   000000C4   0xB2C9             UXTB     R1,R1
   \   000000C6   0x2006             MOVS     R0,#+6
   \   000000C8   0x....             LDR      R2,??DataTable10_17
   \   000000CA   0x6812             LDR      R2,[R2, #+0]
   \   000000CC   0x4790             BLX      R2
    159            }
    160          
    161            /* process interrupt callback function for PORTG                            */
    162            if (SIM_SCGC5 & SIM_SCGC5_PORTG_MASK)
   \                     ??portx_isr_5: (+1)
   \   000000CE   0x....             LDR      R0,??DataTable10_16  ;; 0x4003f038
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0x04C0             LSLS     R0,R0,#+19
   \   000000D4   0xD50C             BPL      ??portx_isr_6
    163            {
    164              PORTG_ISFR = tmp = (uint8)PORTG_ISFR; /* read and clear interrupt flags   */
   \   000000D6   0x....             LDR      R0,??DataTable10_11  ;; 0x4004c0a0
   \   000000D8   0x6801             LDR      R1,[R0, #+0]
   \   000000DA   0xB2C9             UXTB     R1,R1
   \   000000DC   0x....             LDR      R0,??DataTable10_11  ;; 0x4004c0a0
   \   000000DE   0x6001             STR      R1,[R0, #+0]
    165              if (tmp != 0) { pCallbackPTx (PORTG_CALLBACK, tmp); }
   \   000000E0   0xB2C9             UXTB     R1,R1
   \   000000E2   0x2900             CMP      R1,#+0
   \   000000E4   0xD004             BEQ      ??portx_isr_6
   \   000000E6   0xB2C9             UXTB     R1,R1
   \   000000E8   0x2007             MOVS     R0,#+7
   \   000000EA   0x....             LDR      R2,??DataTable10_17
   \   000000EC   0x6812             LDR      R2,[R2, #+0]
   \   000000EE   0x4790             BLX      R2
    166            }
    167          
    168            /* process interrupt callback function for PORTH                            */
    169            if (SIM_SCGC5 & SIM_SCGC5_PORTH_MASK)
   \                     ??portx_isr_6: (+1)
   \   000000F0   0x....             LDR      R0,??DataTable10_16  ;; 0x4003f038
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x0480             LSLS     R0,R0,#+18
   \   000000F6   0xD50C             BPL      ??portx_isr_7
    170            {
    171              PORTH_ISFR = tmp = (uint8)PORTH_ISFR; /* read and clear interrupt flags   */
   \   000000F8   0x....             LDR      R0,??DataTable10_13  ;; 0x4004d0a0
   \   000000FA   0x6801             LDR      R1,[R0, #+0]
   \   000000FC   0xB2C9             UXTB     R1,R1
   \   000000FE   0x....             LDR      R0,??DataTable10_13  ;; 0x4004d0a0
   \   00000100   0x6001             STR      R1,[R0, #+0]
    172              if (tmp != 0) { pCallbackPTx (PORTH_CALLBACK, tmp); }
   \   00000102   0xB2C9             UXTB     R1,R1
   \   00000104   0x2900             CMP      R1,#+0
   \   00000106   0xD004             BEQ      ??portx_isr_7
   \   00000108   0xB2C9             UXTB     R1,R1
   \   0000010A   0x2008             MOVS     R0,#+8
   \   0000010C   0x....             LDR      R2,??DataTable10_17
   \   0000010E   0x6812             LDR      R2,[R2, #+0]
   \   00000110   0x4790             BLX      R2
    173            }
    174          
    175            /* process interrupt callback function for PORTI                            */
    176            if (SIM_SCGC5 & SIM_SCGC5_PORTI_MASK)
   \                     ??portx_isr_7: (+1)
   \   00000112   0x....             LDR      R0,??DataTable10_16  ;; 0x4003f038
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x0440             LSLS     R0,R0,#+17
   \   00000118   0xD50C             BPL      ??portx_isr_8
    177            {
    178              PORTI_ISFR = tmp = (uint8)PORTI_ISFR; /* read and clear interrupt flags   */
   \   0000011A   0x....             LDR      R0,??DataTable10_15  ;; 0x4004e0a0
   \   0000011C   0x6801             LDR      R1,[R0, #+0]
   \   0000011E   0xB2C9             UXTB     R1,R1
   \   00000120   0x....             LDR      R0,??DataTable10_15  ;; 0x4004e0a0
   \   00000122   0x6001             STR      R1,[R0, #+0]
    179              if (tmp != 0) { pCallbackPTx (PORTI_CALLBACK, tmp); }
   \   00000124   0xB2C9             UXTB     R1,R1
   \   00000126   0x2900             CMP      R1,#+0
   \   00000128   0xD004             BEQ      ??portx_isr_8
   \   0000012A   0xB2C9             UXTB     R1,R1
   \   0000012C   0x2009             MOVS     R0,#+9
   \   0000012E   0x....             LDR      R2,??DataTable10_17
   \   00000130   0x6812             LDR      R2,[R2, #+0]
   \   00000132   0x4790             BLX      R2
    180            }
    181          }
   \                     ??portx_isr_8: (+1)
   \   00000134   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     pCallbackPTx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0xE000E410         DC32     0xe000e410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x40046000         DC32     0x40046000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x40047000         DC32     0x40047000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x40048000         DC32     0x40048000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x400460A0         DC32     0x400460a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x400470A0         DC32     0x400470a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x400480A0         DC32     0x400480a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x400490A0         DC32     0x400490a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x4004A0C0         DC32     0x4004a0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x4004A0A0         DC32     0x4004a0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x4004B000         DC32     0x4004b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x4004B0A0         DC32     0x4004b0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x4004C000         DC32     0x4004c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x4004C0A0         DC32     0x4004c0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x4004D0A0         DC32     0x4004d0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_14:
   \   00000000   0x4004E000         DC32     0x4004e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_15:
   \   00000000   0x4004E0A0         DC32     0x4004e0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_16:
   \   00000000   0x4003F038         DC32     0x4003f038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_17:
   \   00000000   0x........         DC32     pCallbackPTx
    182          /******************************************************************************
    183           * End of module                                                              *
    184           ******************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   PORTA_Init
      12   PORTB_Init
      12   PORTC_Init
      12   PORTD_Init
      12   PORTE_Init
      12   PORTF_Init
      12   PORTG_Init
      12   PORTH_Init
      12   PORTI_Init
       4   PORT_InstallCallback
       8   portx_isr
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
      44  PORTA_Init
      44  PORTB_Init
      44  PORTC_Init
      44  PORTD_Init
      58  PORTE_Init
      44  PORTF_Init
      44  PORTG_Init
      44  PORTH_Init
      44  PORTI_Init
      56  PORT_InstallCallback
       4  pCallbackPTx
     310  portx_isr

 
   4 bytes in section .bss
 876 bytes in section .text
 
 876 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
