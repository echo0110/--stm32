###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        13/Jan/2017  10:29:26
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\i2c\i2c.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\i2c\i2c.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\..\..\..\..\src\projects\fllfei_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\Release\List\i2c.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\Release\Obj\i2c.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\i2c\i2c.c
      1          /******************************************************************************
      2           * (c) Copyright 2010-2015, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ***************************************************************************//*!
      5           * @file      i2c.c
      6           * @version   1.0.4.0
      7           * @date      Apr-20-2014
      8           * @brief     I2C bus controller (I2C) driver source code.
      9          ******************************************************************************/
     10          #include "common.h"
     11          #include "i2c.h"
     12          
     13          #if !defined(MCU_MKM34ZA5)
     14            #error "The i2c.c module is specific to the MKMxxZxxACxx5 microcontrollers."
     15          #endif
     16          
     17          /******************************************************************************
     18           * data type definitions                                                      *
     19           ******************************************************************************/

   \                                 In section .bss, align 4
     20          static I2C_CALLBACK pCallbackI2Cx;
   \                     pCallbackI2Cx:
   \   00000000                      DS8 4
     21          
     22          /******************************************************************************
     23           * public function definitions                                                *
     24           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     25          void I2C_InstallCallback (uint8 ip, I2C_CALLBACK pCallback)
     26          {
     27            if (pCallback) { pCallbackI2Cx = pCallback; NVIC_SetIsr(INT_I2C0_I2C1,ip); }  //if判读是不是空指针
   \                     I2C_InstallCallback: (+1)
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0xD010             BEQ      ??I2C_InstallCallback_0
   \   00000004   0x....             LDR      R2,??DataTable3
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x2180             MOVS     R1,#+128
   \   0000000A   0x04C9             LSLS     R1,R1,#+19       ;; #+67108864
   \   0000000C   0x....             LDR      R2,??DataTable3_1  ;; 0xe000e280
   \   0000000E   0x6813             LDR      R3,[R2, #+0]
   \   00000010   0x430B             ORRS     R3,R3,R1
   \   00000012   0x6013             STR      R3,[R2, #+0]
   \   00000014   0x....             LDR      R2,??DataTable3_2  ;; 0xe000e100
   \   00000016   0x6813             LDR      R3,[R2, #+0]
   \   00000018   0x4319             ORRS     R1,R1,R3
   \   0000001A   0x6011             STR      R1,[R2, #+0]
   \   0000001C   0x....             LDR      R1,??DataTable3_3  ;; 0xe000e418
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x0580             LSLS     R0,R0,#+22
   \   00000022   0x4310             ORRS     R0,R0,R2
   \   00000024   0x6008             STR      R0,[R1, #+0]
     28          }
   \                     ??I2C_InstallCallback_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
     29          

   \                                 In section .text, align 2, keep-with-next
     30          void I2C0_Init (tI2C i2c)
     31          {
   \                     I2C0_Init: (+1)
   \   00000000   0xB407             PUSH     {R0-R2}
     32            I2C0_A1    = i2c.A1;
   \   00000002   0x....             LDR      R0,??DataTable3_4  ;; 0x40067000
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x7001             STRB     R1,[R0, #+0]
     33            I2C0_F     = i2c.F;
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x7849             LDRB     R1,[R1, #+1]
   \   0000000E   0x7041             STRB     R1,[R0, #+1]
     34            I2C0_C1    = i2c.C1;
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x7889             LDRB     R1,[R1, #+2]
   \   00000014   0x7081             STRB     R1,[R0, #+2]
     35            I2C0_C2    = i2c.C2;
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x78C9             LDRB     R1,[R1, #+3]
   \   0000001A   0x7141             STRB     R1,[R0, #+5]
     36            I2C0_FLT   = i2c.FLT;
   \   0000001C   0x4669             MOV      R1,SP
   \   0000001E   0x7909             LDRB     R1,[R1, #+4]
   \   00000020   0x7181             STRB     R1,[R0, #+6]
     37            I2C0_RA    = i2c.RA;
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x7949             LDRB     R1,[R1, #+5]
   \   00000026   0x71C1             STRB     R1,[R0, #+7]
     38            I2C0_SMB   = i2c.SMB;
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x7989             LDRB     R1,[R1, #+6]
   \   0000002C   0x7201             STRB     R1,[R0, #+8]
     39            I2C0_A2    = i2c.A2;
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x79C9             LDRB     R1,[R1, #+7]
   \   00000032   0x7241             STRB     R1,[R0, #+9]
     40            I2C0_SLTH  = i2c.SLTH;
   \   00000034   0x4669             MOV      R1,SP
   \   00000036   0x7A09             LDRB     R1,[R1, #+8]
   \   00000038   0x7281             STRB     R1,[R0, #+10]
     41            I2C0_SLTL  = i2c.SLTL;
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x7A49             LDRB     R1,[R1, #+9]
   \   0000003E   0x72C1             STRB     R1,[R0, #+11]
     42          }
   \   00000040   0xB003             ADD      SP,SP,#+12
   \   00000042   0x4770             BX       LR               ;; return
     43          

   \                                 In section .text, align 2, keep-with-next
     44          void I2C1_Init (tI2C i2c)
     45          {
   \                     I2C1_Init: (+1)
   \   00000000   0xB407             PUSH     {R0-R2}
     46            I2C1_A1    = i2c.A1;
   \   00000002   0x....             LDR      R0,??DataTable3_5  ;; 0x40068000
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x7001             STRB     R1,[R0, #+0]
     47            I2C1_F     = i2c.F;
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x7849             LDRB     R1,[R1, #+1]
   \   0000000E   0x7041             STRB     R1,[R0, #+1]
     48            I2C1_C1    = i2c.C1;
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x7889             LDRB     R1,[R1, #+2]
   \   00000014   0x7081             STRB     R1,[R0, #+2]
     49            I2C1_C2    = i2c.C2;
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x78C9             LDRB     R1,[R1, #+3]
   \   0000001A   0x7141             STRB     R1,[R0, #+5]
     50            I2C1_FLT   = i2c.FLT;
   \   0000001C   0x4669             MOV      R1,SP
   \   0000001E   0x7909             LDRB     R1,[R1, #+4]
   \   00000020   0x7181             STRB     R1,[R0, #+6]
     51            I2C1_RA    = i2c.RA;
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x7949             LDRB     R1,[R1, #+5]
   \   00000026   0x71C1             STRB     R1,[R0, #+7]
     52            I2C1_SMB   = i2c.SMB;
   \   00000028   0x4669             MOV      R1,SP
   \   0000002A   0x7989             LDRB     R1,[R1, #+6]
   \   0000002C   0x7201             STRB     R1,[R0, #+8]
     53            I2C1_A2    = i2c.A2;
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x79C9             LDRB     R1,[R1, #+7]
   \   00000032   0x7241             STRB     R1,[R0, #+9]
     54            I2C1_SLTH  = i2c.SLTH;
   \   00000034   0x4669             MOV      R1,SP
   \   00000036   0x7A09             LDRB     R1,[R1, #+8]
   \   00000038   0x7281             STRB     R1,[R0, #+10]
     55            I2C1_SLTL  = i2c.SLTL;
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x7A49             LDRB     R1,[R1, #+9]
   \   0000003E   0x72C1             STRB     R1,[R0, #+11]
     56          }
   \   00000040   0xB003             ADD      SP,SP,#+12
   \   00000042   0x4770             BX       LR               ;; return
     57          
     58          /******************************************************************************
     59           * interrupt function definitions                                             *
     60           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     61          weak void i2cx_isr (void)
     62          {
   \                     i2cx_isr: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
     63            register uint8 arbitration_lost = FALSE;
   \   00000004   0x2700             MOVS     R7,#+0
   \   00000006   0x....             LDR      R0,??DataTable3_6  ;; 0x4003f034
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x0600             LSLS     R0,R0,#+24
   \   0000000C   0xD54F             BPL      ??i2cx_isr_0
     64          
     65            /* process I2C0 interrupt                                                   */
     66            if (SIM_SCGC4 & SIM_SCGC4_I2C0_MASK)
     67            {
     68              if (I2C_GetIsrFlag(I2C0) && (I2C0_C1 & I2C_C1_IICIE_MASK))
   \   0000000E   0x....             LDR      R6,??DataTable3_7  ;; 0x40067002
   \   00000010   0x2002             MOVS     R0,#+2
   \   00000012   0x7871             LDRB     R1,[R6, #+1]
   \   00000014   0x4201             TST      R1,R0
   \   00000016   0xD04A             BEQ      ??i2cx_isr_0
   \   00000018   0x2540             MOVS     R5,#+64
   \   0000001A   0x7831             LDRB     R1,[R6, #+0]
   \   0000001C   0x4229             TST      R1,R5
   \   0000001E   0xD046             BEQ      ??i2cx_isr_0
     69              {
     70                /* Arbitration testing                                                  */
     71                if (I2C0_S & I2C_S_ARBL_MASK) { arbitration_lost = TRUE; }   //I2C_S --status  registor
   \   00000020   0x2410             MOVS     R4,#+16
   \   00000022   0x7871             LDRB     R1,[R6, #+1]
   \   00000024   0x4221             TST      R1,R4
   \   00000026   0xD000             BEQ      ??i2cx_isr_1
   \   00000028   0x2701             MOVS     R7,#+1
     72          
     73                I2C_ClrIsrFlag(I2C0);
   \                     ??i2cx_isr_1: (+1)
   \   0000002A   0x7871             LDRB     R1,[R6, #+1]
   \   0000002C   0x22EF             MOVS     R2,#+239
   \   0000002E   0x400A             ANDS     R2,R2,R1
   \   00000030   0x4310             ORRS     R0,R0,R2
   \   00000032   0x7070             STRB     R0,[R6, #+1]
     74          
     75                /* Master part                                                          */
     76                if ( (I2C0_C1 & I2C_C1_TX_MASK) && (I2C0_C1 & I2C_C1_MST_MASK))
   \   00000034   0x7830             LDRB     R0,[R6, #+0]
   \   00000036   0x4220             TST      R0,R4
   \   00000038   0xD007             BEQ      ??i2cx_isr_2
   \   0000003A   0x7830             LDRB     R0,[R6, #+0]
   \   0000003C   0x0680             LSLS     R0,R0,#+26
   \   0000003E   0xD504             BPL      ??i2cx_isr_2
     77                {
     78                   pCallbackI2Cx (I2C0_CALLBACK, I2C_MTX_CALLBACK);
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x2001             MOVS     R0,#+1
   \   00000044   0x....             LDR      R2,??DataTable3
   \   00000046   0x6812             LDR      R2,[R2, #+0]
   \   00000048   0x4790             BLX      R2
     79                }
     80                if (!(I2C0_C1 & I2C_C1_TX_MASK) && (I2C0_C1 & I2C_C1_MST_MASK))
   \                     ??i2cx_isr_2: (+1)
   \   0000004A   0x7830             LDRB     R0,[R6, #+0]
   \   0000004C   0x4220             TST      R0,R4
   \   0000004E   0xD107             BNE      ??i2cx_isr_3
   \   00000050   0x7830             LDRB     R0,[R6, #+0]
   \   00000052   0x0680             LSLS     R0,R0,#+26
   \   00000054   0xD504             BPL      ??i2cx_isr_3
     81                {
     82                   pCallbackI2Cx (I2C0_CALLBACK, I2C_MRX_CALLBACK);
   \   00000056   0x2102             MOVS     R1,#+2
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x....             LDR      R2,??DataTable3
   \   0000005C   0x6812             LDR      R2,[R2, #+0]
   \   0000005E   0x4790             BLX      R2
     83                }
     84          
     85                /* Slave part                                                           */
     86                if (I2C0_S & I2C_S_IAAS_MASK)   /* if addressed as a slave              */
   \                     ??i2cx_isr_3: (+1)
   \   00000060   0x7870             LDRB     R0,[R6, #+1]
   \   00000062   0x4228             TST      R0,R5
   \   00000064   0xD00A             BEQ      ??i2cx_isr_4
     87                {
     88                  if (I2C0_S & I2C_S_SRW_MASK)
   \   00000066   0x....             LDR      R0,??DataTable3
   \   00000068   0x6802             LDR      R2,[R0, #+0]
   \   0000006A   0x7870             LDRB     R0,[R6, #+1]
   \   0000006C   0x0740             LSLS     R0,R0,#+29
   \   0000006E   0xD502             BPL      ??i2cx_isr_5
     89                  {
     90                    pCallbackI2Cx (I2C0_CALLBACK, I2C_SIAAS_TX_CALLBACK);
   \   00000070   0x2120             MOVS     R1,#+32
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0xE01A             B        ??i2cx_isr_6
     91                  }
     92                  else
     93                  {
     94                    pCallbackI2Cx (I2C0_CALLBACK, I2C_SIAAS_RX_CALLBACK);
   \                     ??i2cx_isr_5: (+1)
   \   00000076   0x2110             MOVS     R1,#+16
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0xE017             B        ??i2cx_isr_6
     95                  }
     96                }
     97                else
     98                {
     99                  if (arbitration_lost == FALSE)/* if master didn't lost arbitration    */
   \                     ??i2cx_isr_4: (+1)
   \   0000007C   0x2F00             CMP      R7,#+0
   \   0000007E   0xD116             BNE      ??i2cx_isr_0
    100                  {
    101                    if (!(I2C0_C1 & I2C_C1_MST_MASK) &&  (I2C0_C1 & I2C_C1_TX_MASK))
   \   00000080   0x2520             MOVS     R5,#+32
   \   00000082   0x7830             LDRB     R0,[R6, #+0]
   \   00000084   0x4228             TST      R0,R5
   \   00000086   0xD107             BNE      ??i2cx_isr_7
   \   00000088   0x7830             LDRB     R0,[R6, #+0]
   \   0000008A   0x4220             TST      R0,R4
   \   0000008C   0xD004             BEQ      ??i2cx_isr_7
    102                    {
    103                       pCallbackI2Cx (I2C0_CALLBACK, I2C_STX_CALLBACK);
   \   0000008E   0x2104             MOVS     R1,#+4
   \   00000090   0x2001             MOVS     R0,#+1
   \   00000092   0x....             LDR      R2,??DataTable3
   \   00000094   0x6812             LDR      R2,[R2, #+0]
   \   00000096   0x4790             BLX      R2
    104                    }
    105                    if (!(I2C0_C1 & I2C_C1_MST_MASK) && !(I2C0_C1 & I2C_C1_TX_MASK))
   \                     ??i2cx_isr_7: (+1)
   \   00000098   0x7830             LDRB     R0,[R6, #+0]
   \   0000009A   0x4228             TST      R0,R5
   \   0000009C   0xD107             BNE      ??i2cx_isr_0
   \   0000009E   0x7830             LDRB     R0,[R6, #+0]
   \   000000A0   0x4220             TST      R0,R4
   \   000000A2   0xD104             BNE      ??i2cx_isr_0
    106                    {
    107                       pCallbackI2Cx (I2C0_CALLBACK, I2C_SRX_CALLBACK);
   \   000000A4   0x2108             MOVS     R1,#+8
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0x....             LDR      R2,??DataTable3
   \   000000AA   0x6812             LDR      R2,[R2, #+0]
   \                     ??i2cx_isr_6: (+1)
   \   000000AC   0x4790             BLX      R2
    108                    }
    109                  }
    110                }
    111              }
    112            }
    113          
    114            /* process I2C1 interrupt                                                   */
    115            if (SIM_SCGC4 & SIM_SCGC4_I2C1_MASK)
   \                     ??i2cx_isr_0: (+1)
   \   000000AE   0x....             LDR      R0,??DataTable3_6  ;; 0x4003f034
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x05C0             LSLS     R0,R0,#+23
   \   000000B4   0xD54F             BPL      ??i2cx_isr_8
    116            {
    117              if (I2C_GetIsrFlag(I2C1) && (I2C1_C1 & I2C_C1_IICIE_MASK))
   \   000000B6   0x....             LDR      R6,??DataTable3_8  ;; 0x40068002
   \   000000B8   0x2002             MOVS     R0,#+2
   \   000000BA   0x7871             LDRB     R1,[R6, #+1]
   \   000000BC   0x4201             TST      R1,R0
   \   000000BE   0xD04A             BEQ      ??i2cx_isr_8
   \   000000C0   0x2540             MOVS     R5,#+64
   \   000000C2   0x7831             LDRB     R1,[R6, #+0]
   \   000000C4   0x4229             TST      R1,R5
   \   000000C6   0xD046             BEQ      ??i2cx_isr_8
    118              {
    119                /* Arbitration testing                                                  */
    120                if (I2C1_S & I2C_S_ARBL_MASK) { arbitration_lost = TRUE; }
   \   000000C8   0x2410             MOVS     R4,#+16
   \   000000CA   0x7871             LDRB     R1,[R6, #+1]
   \   000000CC   0x4221             TST      R1,R4
   \   000000CE   0xD000             BEQ      ??i2cx_isr_9
   \   000000D0   0x2701             MOVS     R7,#+1
    121          
    122                I2C_ClrIsrFlag(I2C1);
   \                     ??i2cx_isr_9: (+1)
   \   000000D2   0x7871             LDRB     R1,[R6, #+1]
   \   000000D4   0x22EF             MOVS     R2,#+239
   \   000000D6   0x400A             ANDS     R2,R2,R1
   \   000000D8   0x4310             ORRS     R0,R0,R2
   \   000000DA   0x7070             STRB     R0,[R6, #+1]
    123          
    124                /* Master part                                                          */
    125                if ( (I2C1_C1 & I2C_C1_TX_MASK) && (I2C1_C1 & I2C_C1_MST_MASK))
   \   000000DC   0x7830             LDRB     R0,[R6, #+0]
   \   000000DE   0x4220             TST      R0,R4
   \   000000E0   0xD007             BEQ      ??i2cx_isr_10
   \   000000E2   0x7830             LDRB     R0,[R6, #+0]
   \   000000E4   0x0680             LSLS     R0,R0,#+26
   \   000000E6   0xD504             BPL      ??i2cx_isr_10
    126                {
    127                   pCallbackI2Cx (I2C1_CALLBACK, I2C_MTX_CALLBACK);
   \   000000E8   0x2101             MOVS     R1,#+1
   \   000000EA   0x2002             MOVS     R0,#+2
   \   000000EC   0x....             LDR      R2,??DataTable3
   \   000000EE   0x6812             LDR      R2,[R2, #+0]
   \   000000F0   0x4790             BLX      R2
    128                }
    129                if (!(I2C1_C1 & I2C_C1_TX_MASK) && (I2C1_C1 & I2C_C1_MST_MASK))
   \                     ??i2cx_isr_10: (+1)
   \   000000F2   0x7830             LDRB     R0,[R6, #+0]
   \   000000F4   0x4220             TST      R0,R4
   \   000000F6   0xD107             BNE      ??i2cx_isr_11
   \   000000F8   0x7830             LDRB     R0,[R6, #+0]
   \   000000FA   0x0680             LSLS     R0,R0,#+26
   \   000000FC   0xD504             BPL      ??i2cx_isr_11
    130                {
    131                   pCallbackI2Cx (I2C1_CALLBACK, I2C_MRX_CALLBACK);
   \   000000FE   0x2102             MOVS     R1,#+2
   \   00000100   0x2002             MOVS     R0,#+2
   \   00000102   0x....             LDR      R2,??DataTable3
   \   00000104   0x6812             LDR      R2,[R2, #+0]
   \   00000106   0x4790             BLX      R2
    132                }
    133          
    134                /* Slave part                                                           */
    135                if (I2C1_S & I2C_S_IAAS_MASK)   /* if addressed as a slave              */
   \                     ??i2cx_isr_11: (+1)
   \   00000108   0x7870             LDRB     R0,[R6, #+1]
   \   0000010A   0x4228             TST      R0,R5
   \   0000010C   0xD00A             BEQ      ??i2cx_isr_12
    136                {
    137                  if (I2C1_S & I2C_S_SRW_MASK)
   \   0000010E   0x....             LDR      R0,??DataTable3
   \   00000110   0x6802             LDR      R2,[R0, #+0]
   \   00000112   0x7870             LDRB     R0,[R6, #+1]
   \   00000114   0x0740             LSLS     R0,R0,#+29
   \   00000116   0xD502             BPL      ??i2cx_isr_13
    138                  {
    139                    pCallbackI2Cx (I2C1_CALLBACK, I2C_SIAAS_TX_CALLBACK);
   \   00000118   0x2120             MOVS     R1,#+32
   \   0000011A   0x2002             MOVS     R0,#+2
   \   0000011C   0xE01A             B        ??i2cx_isr_14
    140                  }
    141                  else
    142                  {
    143                    pCallbackI2Cx (I2C1_CALLBACK, I2C_SIAAS_RX_CALLBACK);
   \                     ??i2cx_isr_13: (+1)
   \   0000011E   0x2110             MOVS     R1,#+16
   \   00000120   0x2002             MOVS     R0,#+2
   \   00000122   0xE017             B        ??i2cx_isr_14
    144                  }
    145                }
    146                else
    147                {
    148                  if (arbitration_lost == FALSE)/* if master didn't lost arbitration    */
   \                     ??i2cx_isr_12: (+1)
   \   00000124   0x2F00             CMP      R7,#+0
   \   00000126   0xD116             BNE      ??i2cx_isr_8
    149                  {
    150                    if (!(I2C1_C1 & I2C_C1_MST_MASK) &&  (I2C1_C1 & I2C_C1_TX_MASK))
   \   00000128   0x2520             MOVS     R5,#+32
   \   0000012A   0x7830             LDRB     R0,[R6, #+0]
   \   0000012C   0x4228             TST      R0,R5
   \   0000012E   0xD107             BNE      ??i2cx_isr_15
   \   00000130   0x7830             LDRB     R0,[R6, #+0]
   \   00000132   0x4220             TST      R0,R4
   \   00000134   0xD004             BEQ      ??i2cx_isr_15
    151                    {
    152                       pCallbackI2Cx (I2C1_CALLBACK, I2C_STX_CALLBACK);
   \   00000136   0x2104             MOVS     R1,#+4
   \   00000138   0x2002             MOVS     R0,#+2
   \   0000013A   0x....             LDR      R2,??DataTable3
   \   0000013C   0x6812             LDR      R2,[R2, #+0]
   \   0000013E   0x4790             BLX      R2
    153                    }
    154                    if (!(I2C1_C1 & I2C_C1_MST_MASK) && !(I2C1_C1 & I2C_C1_TX_MASK))
   \                     ??i2cx_isr_15: (+1)
   \   00000140   0x7830             LDRB     R0,[R6, #+0]
   \   00000142   0x4228             TST      R0,R5
   \   00000144   0xD107             BNE      ??i2cx_isr_8
   \   00000146   0x7830             LDRB     R0,[R6, #+0]
   \   00000148   0x4220             TST      R0,R4
   \   0000014A   0xD104             BNE      ??i2cx_isr_8
    155                    {
    156                       pCallbackI2Cx (I2C1_CALLBACK, I2C_SRX_CALLBACK);
   \   0000014C   0x2108             MOVS     R1,#+8
   \   0000014E   0x2002             MOVS     R0,#+2
   \   00000150   0x....             LDR      R2,??DataTable3
   \   00000152   0x6812             LDR      R2,[R2, #+0]
   \                     ??i2cx_isr_14: (+1)
   \   00000154   0x4790             BLX      R2
    157                    }
    158                  }
    159                }
    160              }
    161            }
    162          }
   \                     ??i2cx_isr_8: (+1)
   \   00000156   0xB001             ADD      SP,SP,#+4
   \   00000158   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     pCallbackI2Cx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0xE000E418         DC32     0xe000e418

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x40067000         DC32     0x40067000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x40068000         DC32     0x40068000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x4003F034         DC32     0x4003f034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x40067002         DC32     0x40067002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x40068002         DC32     0x40068002
    163          /******************************************************************************
    164           * End of module                                                              *
    165           ******************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   I2C0_Init
      12   I2C1_Init
       0   I2C_InstallCallback
      24   i2cx_isr
        24   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
      68  I2C0_Init
      68  I2C1_Init
      40  I2C_InstallCallback
     346  i2cx_isr
       4  pCallbackI2Cx

 
   4 bytes in section .bss
 558 bytes in section .text
 
 558 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
