###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        13/Jan/2017  10:29:30
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\uart\uart.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\uart\uart.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\..\..\..\..\src\projects\fllfei_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\Release\List\uart.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\fllfei_test\Release\Obj\uart.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\uart\uart.c
      1          /******************************************************************************
      2           * (c) Copyright 2010-2015, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ***************************************************************************//*!
      5           * @file      uart.c
      6           * @version   1.0.5.0
      7           * @date      Apr-20-2015
      8           * @brief     Universal Asynchronous Receiver/Transmitter (UART) driver source
      9           *            code.
     10           ******************************************************************************/
     11          #include "common.h"
     12          #include "uart.h"
     13          
     14          #if !defined(MCU_MKM34ZA5)
     15            #error "The uart.c module is specific to the MKMxxZxxACxx5 microcontrollers."
     16          #endif
     17          
     18          /******************************************************************************
     19           * data type definitions                                                      *
     20           ******************************************************************************/

   \                                 In section .bss, align 4
     21          static UART_CALLBACK pCallbackUART0_UART1;
   \                     pCallbackUART0_UART1:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     22          static UART_CALLBACK pCallbackUART2_UART3;
   \                     pCallbackUART2_UART3:
   \   00000000                      DS8 4
     23          
     24          /******************************************************************************
     25           * public function definitions                                                *
     26           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     27          void UART_InstallCallbackUART0_UART1 (uint8 ip, UART_CALLBACK pCallback)
     28          {
     29            if (pCallback) { pCallbackUART0_UART1 = pCallback; NVIC_SetIsr(INT_SCI0_SCI1,ip); }
   \                     UART_InstallCallbackUART0_UART1: (+1)
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0xD010             BEQ      ??UART_InstallCallbackUART0_UART1_0
   \   00000004   0x....             LDR      R2,??DataTable6
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x2180             MOVS     R1,#+128
   \   0000000A   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   0000000C   0x....             LDR      R2,??DataTable6_1  ;; 0xe000e280
   \   0000000E   0x6813             LDR      R3,[R2, #+0]
   \   00000010   0x430B             ORRS     R3,R3,R1
   \   00000012   0x6013             STR      R3,[R2, #+0]
   \   00000014   0x....             LDR      R2,??DataTable6_2  ;; 0xe000e100
   \   00000016   0x6813             LDR      R3,[R2, #+0]
   \   00000018   0x4319             ORRS     R1,R1,R3
   \   0000001A   0x6011             STR      R1,[R2, #+0]
   \   0000001C   0x....             LDR      R1,??DataTable7  ;; 0xe000e410
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x0780             LSLS     R0,R0,#+30
   \   00000022   0x4310             ORRS     R0,R0,R2
   \   00000024   0x6008             STR      R0,[R1, #+0]
     30          }
   \                     ??UART_InstallCallbackUART0_UART1_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
     31          

   \                                 In section .text, align 2, keep-with-next
     32          void UART_InstallCallbackUART2_UART3 (uint8 ip, UART_CALLBACK pCallback)
     33          {
     34            if (pCallback) { pCallbackUART2_UART3 = pCallback; NVIC_SetIsr(INT_SCI2_SCI3,ip); }
   \                     UART_InstallCallbackUART2_UART3: (+1)
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0xD010             BEQ      ??UART_InstallCallbackUART2_UART3_0
   \   00000004   0x....             LDR      R2,??DataTable7_1
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x2180             MOVS     R1,#+128
   \   0000000A   0x0349             LSLS     R1,R1,#+13       ;; #+1048576
   \   0000000C   0x....             LDR      R2,??DataTable6_1  ;; 0xe000e280
   \   0000000E   0x6813             LDR      R3,[R2, #+0]
   \   00000010   0x430B             ORRS     R3,R3,R1
   \   00000012   0x6013             STR      R3,[R2, #+0]
   \   00000014   0x....             LDR      R2,??DataTable6_2  ;; 0xe000e100
   \   00000016   0x6813             LDR      R3,[R2, #+0]
   \   00000018   0x4319             ORRS     R1,R1,R3
   \   0000001A   0x6011             STR      R1,[R2, #+0]
   \   0000001C   0x....             LDR      R1,??DataTable7_2  ;; 0xe000e414
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x0180             LSLS     R0,R0,#+6
   \   00000022   0x4310             ORRS     R0,R0,R2
   \   00000024   0x6008             STR      R0,[R1, #+0]
     35          }
   \                     ??UART_InstallCallbackUART2_UART3_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
     36          

   \                                 In section .text, align 2, keep-with-next
     37          void UART0_Init (tUART sci)
     38          {
   \                     UART0_Init: (+1)
   \   00000000   0xB407             PUSH     {R0-R2}
     39            UART0_C2 &= ~(UART_C2_TE_MASK|UART_C2_RE_MASK );  /* disable uart operation */
   \   00000002   0x....             LDR      R0,??DataTable7_3  ;; 0x4006a000
   \   00000004   0x78C1             LDRB     R1,[R0, #+3]
   \   00000006   0x22F3             MOVS     R2,#+243
   \   00000008   0x400A             ANDS     R2,R2,R1
   \   0000000A   0x70C2             STRB     R2,[R0, #+3]
     40            UART0_BDH     = sci.BDH;
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x7001             STRB     R1,[R0, #+0]
     41            UART0_BDL     = sci.BDL;
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x7849             LDRB     R1,[R1, #+1]
   \   00000016   0x7041             STRB     R1,[R0, #+1]
     42            UART0_C1      = sci.C1;
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x7889             LDRB     R1,[R1, #+2]
   \   0000001C   0x7081             STRB     R1,[R0, #+2]
     43            UART0_S2      = sci.S2;
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x7909             LDRB     R1,[R1, #+4]
   \   00000022   0x7141             STRB     R1,[R0, #+5]
     44            UART0_C3      = sci.C3;
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x7949             LDRB     R1,[R1, #+5]
   \   00000028   0x7181             STRB     R1,[R0, #+6]
     45            UART0_MA1     = sci.MA1;
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x7989             LDRB     R1,[R1, #+6]
   \   0000002E   0x7201             STRB     R1,[R0, #+8]
     46            UART0_MA2     = sci.MA2;
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x79C9             LDRB     R1,[R1, #+7]
   \   00000034   0x7241             STRB     R1,[R0, #+9]
     47            UART0_C4      = sci.C4;
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x7A09             LDRB     R1,[R1, #+8]
   \   0000003A   0x7281             STRB     R1,[R0, #+10]
     48            UART0_C5      = sci.C5;
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x7A49             LDRB     R1,[R1, #+9]
   \   00000040   0x72C1             STRB     R1,[R0, #+11]
     49            UART0_C2      = sci.C2;                           /* enable uart operation  */
   \   00000042   0x4669             MOV      R1,SP
   \   00000044   0x78C9             LDRB     R1,[R1, #+3]
   \   00000046   0x70C1             STRB     R1,[R0, #+3]
     50          }
   \   00000048   0xB003             ADD      SP,SP,#+12
   \   0000004A   0x4770             BX       LR               ;; return
     51          

   \                                 In section .text, align 2, keep-with-next
     52          void UART1_Init (tUART sci)
     53          {
   \                     UART1_Init: (+1)
   \   00000000   0xB407             PUSH     {R0-R2}
     54            UART1_C2 &= ~(UART_C2_TE_MASK|UART_C2_RE_MASK );  /* disable uart operation */
   \   00000002   0x....             LDR      R0,??DataTable7_4  ;; 0x4006b000
   \   00000004   0x78C1             LDRB     R1,[R0, #+3]
   \   00000006   0x22F3             MOVS     R2,#+243
   \   00000008   0x400A             ANDS     R2,R2,R1
   \   0000000A   0x70C2             STRB     R2,[R0, #+3]
     55            UART1_BDH     = sci.BDH;
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x7001             STRB     R1,[R0, #+0]
     56            UART1_BDL     = sci.BDL;
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x7849             LDRB     R1,[R1, #+1]
   \   00000016   0x7041             STRB     R1,[R0, #+1]
     57            UART1_C1      = sci.C1;
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x7889             LDRB     R1,[R1, #+2]
   \   0000001C   0x7081             STRB     R1,[R0, #+2]
     58            UART1_S2      = sci.S2;
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x7909             LDRB     R1,[R1, #+4]
   \   00000022   0x7141             STRB     R1,[R0, #+5]
     59            UART1_C3      = sci.C3;
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x7949             LDRB     R1,[R1, #+5]
   \   00000028   0x7181             STRB     R1,[R0, #+6]
     60            UART1_MA1     = sci.MA1;
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x7989             LDRB     R1,[R1, #+6]
   \   0000002E   0x7201             STRB     R1,[R0, #+8]
     61            UART1_MA2     = sci.MA2;
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x79C9             LDRB     R1,[R1, #+7]
   \   00000034   0x7241             STRB     R1,[R0, #+9]
     62            UART1_C4      = sci.C4;
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x7A09             LDRB     R1,[R1, #+8]
   \   0000003A   0x7281             STRB     R1,[R0, #+10]
     63            UART1_C5      = sci.C5;
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x7A49             LDRB     R1,[R1, #+9]
   \   00000040   0x72C1             STRB     R1,[R0, #+11]
     64            UART1_C2      = sci.C2;                            /* enable uart operation */
   \   00000042   0x4669             MOV      R1,SP
   \   00000044   0x78C9             LDRB     R1,[R1, #+3]
   \   00000046   0x70C1             STRB     R1,[R0, #+3]
     65          }
   \   00000048   0xB003             ADD      SP,SP,#+12
   \   0000004A   0x4770             BX       LR               ;; return
     66          

   \                                 In section .text, align 2, keep-with-next
     67          void UART2_Init (tUART sci)
     68          {
   \                     UART2_Init: (+1)
   \   00000000   0xB407             PUSH     {R0-R2}
     69            UART2_C2 &= ~(UART_C2_TE_MASK|UART_C2_RE_MASK );  /* disable uart operation */
   \   00000002   0x....             LDR      R0,??DataTable7_5  ;; 0x4006c000
   \   00000004   0x78C1             LDRB     R1,[R0, #+3]
   \   00000006   0x22F3             MOVS     R2,#+243
   \   00000008   0x400A             ANDS     R2,R2,R1
   \   0000000A   0x70C2             STRB     R2,[R0, #+3]
     70            UART2_BDH     = sci.BDH;
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x7001             STRB     R1,[R0, #+0]
     71            UART2_BDL     = sci.BDL;
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x7849             LDRB     R1,[R1, #+1]
   \   00000016   0x7041             STRB     R1,[R0, #+1]
     72            UART2_C1      = sci.C1;
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x7889             LDRB     R1,[R1, #+2]
   \   0000001C   0x7081             STRB     R1,[R0, #+2]
     73            UART2_S2      = sci.S2;
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x7909             LDRB     R1,[R1, #+4]
   \   00000022   0x7141             STRB     R1,[R0, #+5]
     74            UART2_C3      = sci.C3;
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x7949             LDRB     R1,[R1, #+5]
   \   00000028   0x7181             STRB     R1,[R0, #+6]
     75            UART2_MA1     = sci.MA1;
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x7989             LDRB     R1,[R1, #+6]
   \   0000002E   0x7201             STRB     R1,[R0, #+8]
     76            UART2_MA2     = sci.MA2;
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x79C9             LDRB     R1,[R1, #+7]
   \   00000034   0x7241             STRB     R1,[R0, #+9]
     77            UART2_C4      = sci.C4;
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x7A09             LDRB     R1,[R1, #+8]
   \   0000003A   0x7281             STRB     R1,[R0, #+10]
     78            UART2_C5      = sci.C5;
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x7A49             LDRB     R1,[R1, #+9]
   \   00000040   0x72C1             STRB     R1,[R0, #+11]
     79            UART2_C2      = sci.C2;                            /* enable uart operation */
   \   00000042   0x4669             MOV      R1,SP
   \   00000044   0x78C9             LDRB     R1,[R1, #+3]
   \   00000046   0x70C1             STRB     R1,[R0, #+3]
     80          }
   \   00000048   0xB003             ADD      SP,SP,#+12
   \   0000004A   0x4770             BX       LR               ;; return
     81          

   \                                 In section .text, align 2, keep-with-next
     82          void UART3_Init (tUART sci)
     83          {
   \                     UART3_Init: (+1)
   \   00000000   0xB407             PUSH     {R0-R2}
     84            UART3_C2 &= ~(UART_C2_TE_MASK|UART_C2_RE_MASK );  /* disable uart operation */
   \   00000002   0x....             LDR      R0,??DataTable7_6  ;; 0x4006d000
   \   00000004   0x78C1             LDRB     R1,[R0, #+3]
   \   00000006   0x22F3             MOVS     R2,#+243
   \   00000008   0x400A             ANDS     R2,R2,R1
   \   0000000A   0x70C2             STRB     R2,[R0, #+3]
     85            UART3_BDH     = sci.BDH;
   \   0000000C   0x4669             MOV      R1,SP
   \   0000000E   0x7809             LDRB     R1,[R1, #+0]
   \   00000010   0x7001             STRB     R1,[R0, #+0]
     86            UART3_BDL     = sci.BDL;
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x7849             LDRB     R1,[R1, #+1]
   \   00000016   0x7041             STRB     R1,[R0, #+1]
     87            UART3_C1      = sci.C1;
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x7889             LDRB     R1,[R1, #+2]
   \   0000001C   0x7081             STRB     R1,[R0, #+2]
     88            UART3_S2      = sci.S2;
   \   0000001E   0x4669             MOV      R1,SP
   \   00000020   0x7909             LDRB     R1,[R1, #+4]
   \   00000022   0x7141             STRB     R1,[R0, #+5]
     89            UART3_C3      = sci.C3;
   \   00000024   0x4669             MOV      R1,SP
   \   00000026   0x7949             LDRB     R1,[R1, #+5]
   \   00000028   0x7181             STRB     R1,[R0, #+6]
     90            UART3_MA1     = sci.MA1;
   \   0000002A   0x4669             MOV      R1,SP
   \   0000002C   0x7989             LDRB     R1,[R1, #+6]
   \   0000002E   0x7201             STRB     R1,[R0, #+8]
     91            UART3_MA2     = sci.MA2;
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x79C9             LDRB     R1,[R1, #+7]
   \   00000034   0x7241             STRB     R1,[R0, #+9]
     92            UART3_C4      = sci.C4;
   \   00000036   0x4669             MOV      R1,SP
   \   00000038   0x7A09             LDRB     R1,[R1, #+8]
   \   0000003A   0x7281             STRB     R1,[R0, #+10]
     93            UART3_C5      = sci.C5;
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x7A49             LDRB     R1,[R1, #+9]
   \   00000040   0x72C1             STRB     R1,[R0, #+11]
     94            UART3_C2      = sci.C2;                           /* enable uart operation  */
   \   00000042   0x4669             MOV      R1,SP
   \   00000044   0x78C9             LDRB     R1,[R1, #+3]
   \   00000046   0x70C1             STRB     R1,[R0, #+3]
     95          }
   \   00000048   0xB003             ADD      SP,SP,#+12
   \   0000004A   0x4770             BX       LR               ;; return
     96          
     97          /******************************************************************************
     98           * interrupt function definitions                                             *
     99           ******************************************************************************/
    100          #if defined(__ICCARM__)
    101            #pragma diag_suppress=Pa082
    102          #endif

   \                                 In section .text, align 2, keep-with-next
    103          weak void uart01_isr (void)
    104          {
   \                     uart01_isr: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    105            register int32 tmp;
    106          
    107            /* process UART0 interrupts                                                 */
    108            if (SIM_SCGC4 & SIM_SCGC4_UART0_MASK)
   \   00000004   0x....             LDR      R7,??DataTable7_7  ;; 0x4003f034
   \   00000006   0x6838             LDR      R0,[R7, #+0]
   \   00000008   0x0540             LSLS     R0,R0,#+21
   \   0000000A   0xD52B             BPL      ??uart01_isr_0
    109            {
    110              tmp = UART0_S2 & (UART0_BDH & UART_BDH_RXEDGIE_MASK);
   \   0000000C   0x....             LDR      R4,??DataTable7_3  ;; 0x4006a000
   \   0000000E   0x7960             LDRB     R0,[R4, #+5]
   \   00000010   0x7822             LDRB     R2,[R4, #+0]
   \   00000012   0x4002             ANDS     R2,R2,R0
   \   00000014   0x2040             MOVS     R0,#+64
   \   00000016   0x4002             ANDS     R2,R2,R0
    111              if(tmp != 0)
   \   00000018   0x....             LDR      R6,??DataTable6
   \   0000001A   0xD005             BEQ      ??uart01_isr_1
    112              {
    113                UART0_S2 = UART0_S2;  /* clear RXEDGIF interrupt flag                   */
   \   0000001C   0x7960             LDRB     R0,[R4, #+5]
   \   0000001E   0x7160             STRB     R0,[R4, #+5]
    114                pCallbackUART0_UART1 (UART0_CALLBACK, UART_EDG_CALLBACK, tmp);
   \   00000020   0x2108             MOVS     R1,#+8
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x6833             LDR      R3,[R6, #+0]
   \   00000026   0x4798             BLX      R3
    115              }
    116          
    117              tmp = UART0_S1 & (UART0_C2 & (UART_C2_RIE_MASK|UART_C2_TCIE_MASK|         \
    118                                            UART_C2_TIE_MASK));
   \                     ??uart01_isr_1: (+1)
   \   00000028   0x7920             LDRB     R0,[R4, #+4]
   \   0000002A   0x78E1             LDRB     R1,[R4, #+3]
   \   0000002C   0x4001             ANDS     R1,R1,R0
   \   0000002E   0x25E0             MOVS     R5,#+224
   \   00000030   0x400D             ANDS     R5,R5,R1
    119              if(tmp & UART_S1_RDRF_MASK)
   \   00000032   0x06A8             LSLS     R0,R5,#+26
   \   00000034   0xD504             BPL      ??uart01_isr_2
    120                pCallbackUART0_UART1 (UART0_CALLBACK, UART_RX_CALLBACK, tmp);
   \   00000036   0x002A             MOVS     R2,R5
   \   00000038   0x2102             MOVS     R1,#+2
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x6833             LDR      R3,[R6, #+0]
   \   0000003E   0x4798             BLX      R3
    121          
    122              if(tmp & (UART_S1_TC_MASK|UART_S1_TDRE_MASK))
   \                     ??uart01_isr_2: (+1)
   \   00000040   0x21C0             MOVS     R1,#+192
   \   00000042   0x420D             TST      R5,R1
   \   00000044   0xD004             BEQ      ??uart01_isr_3
    123                pCallbackUART0_UART1 (UART0_CALLBACK ,UART_TX_CALLBACK, tmp);
   \   00000046   0x002A             MOVS     R2,R5
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x6833             LDR      R3,[R6, #+0]
   \   0000004E   0x4798             BLX      R3
    124          
    125              tmp = UART0_S1 & (UART0_C3 & (UART_C3_PEIE_MASK|UART_C3_FEIE_MASK|        \
    126                                            UART_C3_NEIE_MASK|UART_C3_ORIE_MASK));
   \                     ??uart01_isr_3: (+1)
   \   00000050   0x7920             LDRB     R0,[R4, #+4]
   \   00000052   0x79A1             LDRB     R1,[R4, #+6]
   \   00000054   0x4001             ANDS     R1,R1,R0
   \   00000056   0x070A             LSLS     R2,R1,#+28
   \   00000058   0x0F12             LSRS     R2,R2,#+28
    127              if(tmp != 0)
   \   0000005A   0xD003             BEQ      ??uart01_isr_0
    128                pCallbackUART0_UART1 (UART0_CALLBACK, UART_ER_CALLBACK, tmp);
   \   0000005C   0x2104             MOVS     R1,#+4
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0x6833             LDR      R3,[R6, #+0]
   \   00000062   0x4798             BLX      R3
    129            }
    130          
    131            /* process UART1 interrupts                                                 */
    132            if (SIM_SCGC4 & SIM_SCGC4_UART1_MASK)
   \                     ??uart01_isr_0: (+1)
   \   00000064   0x6838             LDR      R0,[R7, #+0]
   \   00000066   0x0500             LSLS     R0,R0,#+20
   \   00000068   0xD52E             BPL      ??uart01_isr_4
    133            {
    134              tmp = UART1_S2 & (UART1_BDH & UART_BDH_RXEDGIE_MASK);
   \   0000006A   0x....             LDR      R4,??DataTable7_4  ;; 0x4006b000
   \   0000006C   0x7960             LDRB     R0,[R4, #+5]
   \   0000006E   0x7822             LDRB     R2,[R4, #+0]
   \   00000070   0x4002             ANDS     R2,R2,R0
   \   00000072   0x2040             MOVS     R0,#+64
   \   00000074   0x4002             ANDS     R2,R2,R0
    135              if(tmp != 0)
   \   00000076   0xD006             BEQ      ??uart01_isr_5
    136              {
    137                UART1_S2 = UART1_S2;  /* clear RXEDGIF interrupt flag                   */
   \   00000078   0x7960             LDRB     R0,[R4, #+5]
   \   0000007A   0x7160             STRB     R0,[R4, #+5]
    138                pCallbackUART0_UART1 (UART1_CALLBACK, UART_EDG_CALLBACK, tmp);
   \   0000007C   0x2108             MOVS     R1,#+8
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0x....             LDR      R3,??DataTable6
   \   00000082   0x681B             LDR      R3,[R3, #+0]
   \   00000084   0x4798             BLX      R3
    139              }
    140          
    141              tmp = UART1_S1 & (UART1_C2 & (UART_C2_RIE_MASK|UART_C2_TCIE_MASK|         \
    142                                            UART_C2_TIE_MASK));
   \                     ??uart01_isr_5: (+1)
   \   00000086   0x7920             LDRB     R0,[R4, #+4]
   \   00000088   0x78E1             LDRB     R1,[R4, #+3]
   \   0000008A   0x4001             ANDS     R1,R1,R0
   \   0000008C   0x25E0             MOVS     R5,#+224
   \   0000008E   0x400D             ANDS     R5,R5,R1
    143              if(tmp & UART_S1_RDRF_MASK)
   \   00000090   0x06A8             LSLS     R0,R5,#+26
   \   00000092   0xD505             BPL      ??uart01_isr_6
    144                pCallbackUART0_UART1 (UART1_CALLBACK, UART_RX_CALLBACK, tmp);
   \   00000094   0x002A             MOVS     R2,R5
   \   00000096   0x2102             MOVS     R1,#+2
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0x....             LDR      R3,??DataTable6
   \   0000009C   0x681B             LDR      R3,[R3, #+0]
   \   0000009E   0x4798             BLX      R3
    145          
    146              if(tmp & (UART_S1_TC_MASK|UART_S1_TDRE_MASK))
   \                     ??uart01_isr_6: (+1)
   \   000000A0   0x21C0             MOVS     R1,#+192
   \   000000A2   0x420D             TST      R5,R1
   \   000000A4   0xD005             BEQ      ??uart01_isr_7
    147                pCallbackUART0_UART1 (UART1_CALLBACK, UART_TX_CALLBACK, tmp);
   \   000000A6   0x002A             MOVS     R2,R5
   \   000000A8   0x2101             MOVS     R1,#+1
   \   000000AA   0x2002             MOVS     R0,#+2
   \   000000AC   0x....             LDR      R3,??DataTable6
   \   000000AE   0x681B             LDR      R3,[R3, #+0]
   \   000000B0   0x4798             BLX      R3
    148          
    149              tmp = UART1_S1 & (UART1_C3 & (UART_C3_PEIE_MASK|UART_C3_FEIE_MASK|        \
    150                                            UART_C3_NEIE_MASK|UART_C3_ORIE_MASK));
   \                     ??uart01_isr_7: (+1)
   \   000000B2   0x7920             LDRB     R0,[R4, #+4]
   \   000000B4   0x79A1             LDRB     R1,[R4, #+6]
   \   000000B6   0x4001             ANDS     R1,R1,R0
   \   000000B8   0x070A             LSLS     R2,R1,#+28
   \   000000BA   0x0F12             LSRS     R2,R2,#+28
    151              if(tmp != 0)
   \   000000BC   0xD004             BEQ      ??uart01_isr_4
    152                pCallbackUART0_UART1 (UART1_CALLBACK, UART_ER_CALLBACK, tmp);
   \   000000BE   0x2104             MOVS     R1,#+4
   \   000000C0   0x2002             MOVS     R0,#+2
   \   000000C2   0x....             LDR      R3,??DataTable6
   \   000000C4   0x681B             LDR      R3,[R3, #+0]
   \   000000C6   0x4798             BLX      R3
    153            }
    154          }
   \                     ??uart01_isr_4: (+1)
   \   000000C8   0xB001             ADD      SP,SP,#+4
   \   000000CA   0xBDF0             POP      {R4-R7,PC}       ;; return
    155          
    156          #if defined(__ICCARM__)
    157            #pragma diag_suppress=Pa082
    158          #endif

   \                                 In section .text, align 2, keep-with-next
    159          weak void uart23_isr (void)
    160          {
   \                     uart23_isr: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    161            register int32 tmp;
    162          
    163            /* process UART2 interrupts                                                 */
    164            if (SIM_SCGC4 & SIM_SCGC4_UART2_MASK)
   \   00000004   0x....             LDR      R7,??DataTable7_7  ;; 0x4003f034
   \   00000006   0x6838             LDR      R0,[R7, #+0]
   \   00000008   0x04C0             LSLS     R0,R0,#+19
   \   0000000A   0xD52B             BPL      ??uart23_isr_0
    165            {
    166              tmp = UART2_S2 & (UART2_BDH & UART_BDH_RXEDGIE_MASK);
   \   0000000C   0x....             LDR      R4,??DataTable7_5  ;; 0x4006c000
   \   0000000E   0x7960             LDRB     R0,[R4, #+5]
   \   00000010   0x7822             LDRB     R2,[R4, #+0]
   \   00000012   0x4002             ANDS     R2,R2,R0
   \   00000014   0x2040             MOVS     R0,#+64
   \   00000016   0x4002             ANDS     R2,R2,R0
    167              if(tmp != 0)
   \   00000018   0x....             LDR      R6,??DataTable7_1
   \   0000001A   0xD005             BEQ      ??uart23_isr_1
    168              {
    169                UART2_S2 = UART2_S2;  /* clear RXEDGIF interrupt flag                   */
   \   0000001C   0x7960             LDRB     R0,[R4, #+5]
   \   0000001E   0x7160             STRB     R0,[R4, #+5]
    170                pCallbackUART2_UART3 (UART2_CALLBACK, UART_EDG_CALLBACK, tmp);
   \   00000020   0x2108             MOVS     R1,#+8
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0x6833             LDR      R3,[R6, #+0]
   \   00000026   0x4798             BLX      R3
    171              }
    172          
    173              tmp = UART2_S1 & (UART2_C2 & (UART_C2_RIE_MASK|UART_C2_TCIE_MASK|         \
    174                                            UART_C2_TIE_MASK));
   \                     ??uart23_isr_1: (+1)
   \   00000028   0x7920             LDRB     R0,[R4, #+4]
   \   0000002A   0x78E1             LDRB     R1,[R4, #+3]
   \   0000002C   0x4001             ANDS     R1,R1,R0
   \   0000002E   0x25E0             MOVS     R5,#+224
   \   00000030   0x400D             ANDS     R5,R5,R1
    175              if(tmp & UART_S1_RDRF_MASK)
   \   00000032   0x06A8             LSLS     R0,R5,#+26
   \   00000034   0xD504             BPL      ??uart23_isr_2
    176                pCallbackUART2_UART3 (UART2_CALLBACK, UART_RX_CALLBACK, tmp);
   \   00000036   0x002A             MOVS     R2,R5
   \   00000038   0x2102             MOVS     R1,#+2
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0x6833             LDR      R3,[R6, #+0]
   \   0000003E   0x4798             BLX      R3
    177          
    178              if(tmp & (UART_S1_TC_MASK|UART_S1_TDRE_MASK))
   \                     ??uart23_isr_2: (+1)
   \   00000040   0x21C0             MOVS     R1,#+192
   \   00000042   0x420D             TST      R5,R1
   \   00000044   0xD004             BEQ      ??uart23_isr_3
    179                pCallbackUART2_UART3 (UART2_CALLBACK, UART_TX_CALLBACK, tmp);
   \   00000046   0x002A             MOVS     R2,R5
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x2004             MOVS     R0,#+4
   \   0000004C   0x6833             LDR      R3,[R6, #+0]
   \   0000004E   0x4798             BLX      R3
    180          
    181              tmp = UART2_S1 & (UART2_C3 & (UART_C3_PEIE_MASK|UART_C3_FEIE_MASK|        \
    182                                            UART_C3_NEIE_MASK|UART_C3_ORIE_MASK));
   \                     ??uart23_isr_3: (+1)
   \   00000050   0x7920             LDRB     R0,[R4, #+4]
   \   00000052   0x79A1             LDRB     R1,[R4, #+6]
   \   00000054   0x4001             ANDS     R1,R1,R0
   \   00000056   0x070A             LSLS     R2,R1,#+28
   \   00000058   0x0F12             LSRS     R2,R2,#+28
    183              if(tmp != 0)
   \   0000005A   0xD003             BEQ      ??uart23_isr_0
    184                pCallbackUART2_UART3 (UART2_CALLBACK, UART_ER_CALLBACK, tmp);
   \   0000005C   0x2104             MOVS     R1,#+4
   \   0000005E   0x2004             MOVS     R0,#+4
   \   00000060   0x6833             LDR      R3,[R6, #+0]
   \   00000062   0x4798             BLX      R3
    185            }
    186          
    187            /* process UART3 interrupts                                                 */
    188            if (SIM_SCGC4 & SIM_SCGC4_UART3_MASK)
   \                     ??uart23_isr_0: (+1)
   \   00000064   0x6838             LDR      R0,[R7, #+0]
   \   00000066   0x0480             LSLS     R0,R0,#+18
   \   00000068   0xD52E             BPL      ??uart23_isr_4
    189            {
    190              tmp = UART3_S2 & (UART3_BDH & UART_BDH_RXEDGIE_MASK);
   \   0000006A   0x....             LDR      R4,??DataTable7_6  ;; 0x4006d000
   \   0000006C   0x7960             LDRB     R0,[R4, #+5]
   \   0000006E   0x7822             LDRB     R2,[R4, #+0]
   \   00000070   0x4002             ANDS     R2,R2,R0
   \   00000072   0x2040             MOVS     R0,#+64
   \   00000074   0x4002             ANDS     R2,R2,R0
    191              if(tmp != 0)
   \   00000076   0xD006             BEQ      ??uart23_isr_5
    192              {
    193                UART3_S2 = UART3_S2;  /* clear RXEDGIF interrupt flag                   */
   \   00000078   0x7960             LDRB     R0,[R4, #+5]
   \   0000007A   0x7160             STRB     R0,[R4, #+5]
    194                pCallbackUART2_UART3 (UART3_CALLBACK, UART_EDG_CALLBACK, tmp);
   \   0000007C   0x2108             MOVS     R1,#+8
   \   0000007E   0x2008             MOVS     R0,#+8
   \   00000080   0x....             LDR      R3,??DataTable7_1
   \   00000082   0x681B             LDR      R3,[R3, #+0]
   \   00000084   0x4798             BLX      R3
    195              }
    196          
    197              tmp = UART3_S1 & (UART3_C2 & (UART_C2_RIE_MASK|UART_C2_TCIE_MASK|         \
    198                                            UART_C2_TIE_MASK));
   \                     ??uart23_isr_5: (+1)
   \   00000086   0x7920             LDRB     R0,[R4, #+4]
   \   00000088   0x78E1             LDRB     R1,[R4, #+3]
   \   0000008A   0x4001             ANDS     R1,R1,R0
   \   0000008C   0x25E0             MOVS     R5,#+224
   \   0000008E   0x400D             ANDS     R5,R5,R1
    199              if(tmp & UART_S1_RDRF_MASK)
   \   00000090   0x06A8             LSLS     R0,R5,#+26
   \   00000092   0xD505             BPL      ??uart23_isr_6
    200                pCallbackUART2_UART3 (UART3_CALLBACK, UART_RX_CALLBACK, tmp);
   \   00000094   0x002A             MOVS     R2,R5
   \   00000096   0x2102             MOVS     R1,#+2
   \   00000098   0x2008             MOVS     R0,#+8
   \   0000009A   0x....             LDR      R3,??DataTable7_1
   \   0000009C   0x681B             LDR      R3,[R3, #+0]
   \   0000009E   0x4798             BLX      R3
    201          
    202              if(tmp & (UART_S1_TC_MASK|UART_S1_TDRE_MASK))
   \                     ??uart23_isr_6: (+1)
   \   000000A0   0x21C0             MOVS     R1,#+192
   \   000000A2   0x420D             TST      R5,R1
   \   000000A4   0xD005             BEQ      ??uart23_isr_7
    203                pCallbackUART2_UART3 (UART3_CALLBACK ,UART_TX_CALLBACK, tmp);
   \   000000A6   0x002A             MOVS     R2,R5
   \   000000A8   0x2101             MOVS     R1,#+1
   \   000000AA   0x2008             MOVS     R0,#+8
   \   000000AC   0x....             LDR      R3,??DataTable7_1
   \   000000AE   0x681B             LDR      R3,[R3, #+0]
   \   000000B0   0x4798             BLX      R3
    204          
    205              tmp = UART3_S1 & (UART3_C3 & (UART_C3_PEIE_MASK|UART_C3_FEIE_MASK|        \
    206                                            UART_C3_NEIE_MASK|UART_C3_ORIE_MASK));
   \                     ??uart23_isr_7: (+1)
   \   000000B2   0x7920             LDRB     R0,[R4, #+4]
   \   000000B4   0x79A1             LDRB     R1,[R4, #+6]
   \   000000B6   0x4001             ANDS     R1,R1,R0
   \   000000B8   0x070A             LSLS     R2,R1,#+28
   \   000000BA   0x0F12             LSRS     R2,R2,#+28
    207              if(tmp != 0)
   \   000000BC   0xD004             BEQ      ??uart23_isr_4
    208                pCallbackUART2_UART3 (UART3_CALLBACK, UART_ER_CALLBACK, tmp);
   \   000000BE   0x2104             MOVS     R1,#+4
   \   000000C0   0x2008             MOVS     R0,#+8
   \   000000C2   0x....             LDR      R3,??DataTable7_1
   \   000000C4   0x681B             LDR      R3,[R3, #+0]
   \   000000C6   0x4798             BLX      R3
    209            }
    210          }
   \                     ??uart23_isr_4: (+1)
   \   000000C8   0xB001             ADD      SP,SP,#+4
   \   000000CA   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     pCallbackUART0_UART1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0xE000E410         DC32     0xe000e410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     pCallbackUART2_UART3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0xE000E414         DC32     0xe000e414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x4006A000         DC32     0x4006a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x4006B000         DC32     0x4006b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x4006C000         DC32     0x4006c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x4006D000         DC32     0x4006d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x4003F034         DC32     0x4003f034
    211          /******************************************************************************
    212           * End of module                                                              *
    213           ******************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   UART0_Init
      12   UART1_Init
      12   UART2_Init
      12   UART3_Init
       0   UART_InstallCallbackUART0_UART1
       0   UART_InstallCallbackUART2_UART3
      24   uart01_isr
        24   -- Indirect call
      24   uart23_isr
        24   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
      76  UART0_Init
      76  UART1_Init
      76  UART2_Init
      76  UART3_Init
      40  UART_InstallCallbackUART0_UART1
      40  UART_InstallCallbackUART2_UART3
       4  pCallbackUART0_UART1
       4  pCallbackUART2_UART3
     204  uart01_isr
     204  uart23_isr

 
   8 bytes in section .bss
 836 bytes in section .text
 
 836 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: none
