###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        27/Dec/2016  15:50:52
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\spi\spi.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\spi\spi.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\gpio_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\gpio_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\gpio_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\gpio_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\gpio_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\gpio_test\..\..\..\..\src\projects\gpio_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\gpio_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\gpio_test\Release\List\spi.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\gpio_test\Release\Obj\spi.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\spi\spi.c
      1          /******************************************************************************
      2           * (c) Copyright 2010-2015, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ***************************************************************************//*!
      5           * @file      spi.c
      6           * @version   1.0.7.0
      7           * @date      Apr-20-2015
      8           * @brief     Serial Peripheral Interface (SPI) driver source code.
      9          ******************************************************************************/
     10          #include "common.h"
     11          #include "spi.h"
     12          
     13          #if !defined(MCU_MKM34ZA5)
     14            #error "The spi.c module is specific to the MKMxxZxxACxx5 microcontrollers."
     15          #endif
     16          
     17          /******************************************************************************
     18           * data type definitions                                                      *
     19           ******************************************************************************/

   \                                 In section .bss, align 4
     20          static SPI_CALLBACK     pCallbackSPI0, pCallbackSPI1;
   \                     pCallbackSPI0:
   \   00000000                      DS8 4
   \   00000004                      DS8 4

   \                                 In section .bss, align 4
   \                     pCallbackSPI1:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
     21          static SPI_SSCALLBACK   pCallbackSS0, pCallbackSS1;
     22          
     23          /******************************************************************************
     24           * public function definitions                                                *
     25           ******************************************************************************/
     26          #if defined(__ICCARM__)
     27            #pragma diag_suppress=Pa082
     28          #endif

   \                                 In section .text, align 2, keep-with-next
     29          void SPI0_Init (tSPI spi,SPI_SSCALLBACK pC2,uint8 ip,SPI_CALLBACK pC1)
     30          {
   \                     SPI0_Init: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x9804             LDR      R0,[SP, #+16]
     31            /* main callback function initialization                                    */
     32            if (pC1) { pCallbackSPI0 = pC1; NVIC_SetIsr(INT_SPI0,ip); }
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xD010             BEQ      ??SPI0_Init_0
   \   00000008   0x....             LDR      R1,??DataTable7
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   \   0000000C   0x2010             MOVS     R0,#+16
   \   0000000E   0x....             LDR      R1,??DataTable7_1  ;; 0xe000e280
   \   00000010   0x680C             LDR      R4,[R1, #+0]
   \   00000012   0x4304             ORRS     R4,R4,R0
   \   00000014   0x600C             STR      R4,[R1, #+0]
   \   00000016   0x....             LDR      R1,??DataTable7_2  ;; 0xe000e100
   \   00000018   0x680C             LDR      R4,[R1, #+0]
   \   0000001A   0x4320             ORRS     R0,R0,R4
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0x....             LDR      R0,??DataTable7_3  ;; 0xe000e404
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x061B             LSLS     R3,R3,#+24
   \   00000024   0x0C9B             LSRS     R3,R3,#+18
   \   00000026   0x430B             ORRS     R3,R3,R1
   \   00000028   0x6003             STR      R3,[R0, #+0]
     33          
     34            /* initialization of SS callback function where SS will be driven manually  */
     35            if (pC2) { pCallbackSS0 = pC2; pCallbackSS0 (SS_INIT);  }
   \                     ??SPI0_Init_0: (+1)
   \   0000002A   0x0010             MOVS     R0,R2
   \   0000002C   0xD004             BEQ      ??SPI0_Init_1
   \   0000002E   0x....             LDR      R1,??DataTable7
   \   00000030   0x604A             STR      R2,[R1, #+4]
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x4611             MOV      R1,R2
   \   00000036   0x4788             BLX      R1
     36          
     37            /* SPI configuration (without C3 register)                                  */
     38            SPI0_C1  = spi.C1;              /* SPI control register 1                   */
   \                     ??SPI0_Init_1: (+1)
   \   00000038   0x....             LDR      R0,??DataTable8  ;; 0x40075001
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0x7081             STRB     R1,[R0, #+2]
     39            SPI0_C2  = spi.C2;              /* SPI control register 2                   */
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x7849             LDRB     R1,[R1, #+1]
   \   00000044   0x7041             STRB     R1,[R0, #+1]
     40            SPI0_BR  = spi.BR;              /* SPI baud rate register                   */
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0x78C9             LDRB     R1,[R1, #+3]
   \   0000004A   0x7001             STRB     R1,[R0, #+0]
     41            SPI0_ML  = spi.ML;              /* SPI match register low                   */
   \   0000004C   0x4669             MOV      R1,SP
   \   0000004E   0x7909             LDRB     R1,[R1, #+4]
   \   00000050   0x70C1             STRB     R1,[R0, #+3]
     42            SPI0_MH  = spi.MH;              /* SPI match register high                  */
   \   00000052   0x4669             MOV      R1,SP
   \   00000054   0x7949             LDRB     R1,[R1, #+5]
   \   00000056   0x7101             STRB     R1,[R0, #+4]
     43            SPI0_C1 |= SPI_C1_SPE_MASK;     /* Enable SPI                               */
   \   00000058   0x7881             LDRB     R1,[R0, #+2]
   \   0000005A   0x2240             MOVS     R2,#+64
   \   0000005C   0x430A             ORRS     R2,R2,R1
   \   0000005E   0x7082             STRB     R2,[R0, #+2]
     44            /* Note: FIFO functionality is not supported in SPI0 module                 */
     45          }
   \   00000060   0xB002             ADD      SP,SP,#+8
   \   00000062   0xBD10             POP      {R4,PC}          ;; return
     46          

   \                                 In section .text, align 2, keep-with-next
     47          void SPI1_Init (tSPI spi,SPI_SSCALLBACK pC2,uint8 ip, SPI_CALLBACK pC1)
     48          {
   \                     SPI1_Init: (+1)
   \   00000000   0xB513             PUSH     {R0,R1,R4,LR}
   \   00000002   0x9804             LDR      R0,[SP, #+16]
     49            /* main callback function initialization                                    */
     50            if (pC1) { pCallbackSPI1 = pC1; NVIC_SetIsr(INT_SPI1,ip); }
   \   00000004   0x0001             MOVS     R1,R0
   \   00000006   0xD010             BEQ      ??SPI1_Init_0
   \   00000008   0x....             LDR      R1,??DataTable8_1
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   \   0000000C   0x2020             MOVS     R0,#+32
   \   0000000E   0x....             LDR      R1,??DataTable7_1  ;; 0xe000e280
   \   00000010   0x680C             LDR      R4,[R1, #+0]
   \   00000012   0x4304             ORRS     R4,R4,R0
   \   00000014   0x600C             STR      R4,[R1, #+0]
   \   00000016   0x....             LDR      R1,??DataTable7_2  ;; 0xe000e100
   \   00000018   0x680C             LDR      R4,[R1, #+0]
   \   0000001A   0x4320             ORRS     R0,R0,R4
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0x....             LDR      R0,??DataTable7_3  ;; 0xe000e404
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x061B             LSLS     R3,R3,#+24
   \   00000024   0x0A9B             LSRS     R3,R3,#+10
   \   00000026   0x430B             ORRS     R3,R3,R1
   \   00000028   0x6003             STR      R3,[R0, #+0]
     51          
     52            /* initialization of SS callback function where SS will be driven manually  */
     53            if (pC2) { pCallbackSS1 = pC2; pCallbackSS1 (SS_INIT); }
   \                     ??SPI1_Init_0: (+1)
   \   0000002A   0x0010             MOVS     R0,R2
   \   0000002C   0xD004             BEQ      ??SPI1_Init_1
   \   0000002E   0x....             LDR      R1,??DataTable8_1
   \   00000030   0x604A             STR      R2,[R1, #+4]
   \   00000032   0x2002             MOVS     R0,#+2
   \   00000034   0x4611             MOV      R1,R2
   \   00000036   0x4788             BLX      R1
     54          
     55            /* SPI configuration (with C3 register)                                     */
     56            SPI1_C1  = spi.C1;              /* SPI control register 1                   */
   \                     ??SPI1_Init_1: (+1)
   \   00000038   0x....             LDR      R0,??DataTable8_2  ;; 0x40076001
   \   0000003A   0x4669             MOV      R1,SP
   \   0000003C   0x7809             LDRB     R1,[R1, #+0]
   \   0000003E   0x7081             STRB     R1,[R0, #+2]
     57            SPI1_C2  = spi.C2;              /* SPI control register 2                   */
   \   00000040   0x4669             MOV      R1,SP
   \   00000042   0x7849             LDRB     R1,[R1, #+1]
   \   00000044   0x7041             STRB     R1,[R0, #+1]
     58            SPI1_C3  = spi.C3;              /* SPI control register 3                   */
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0x7889             LDRB     R1,[R1, #+2]
   \   0000004A   0x7281             STRB     R1,[R0, #+10]
     59            SPI1_BR  = spi.BR;              /* SPI baud rate register                   */
   \   0000004C   0x4669             MOV      R1,SP
   \   0000004E   0x78C9             LDRB     R1,[R1, #+3]
   \   00000050   0x7001             STRB     R1,[R0, #+0]
     60            SPI1_ML  = spi.ML;              /* SPI match register low                   */
   \   00000052   0x4669             MOV      R1,SP
   \   00000054   0x7909             LDRB     R1,[R1, #+4]
   \   00000056   0x70C1             STRB     R1,[R0, #+3]
     61            SPI1_MH  = spi.MH;              /* SPI match register high                  */
   \   00000058   0x4669             MOV      R1,SP
   \   0000005A   0x7949             LDRB     R1,[R1, #+5]
   \   0000005C   0x7101             STRB     R1,[R0, #+4]
     62            SPI1_C1 |= SPI_C1_SPE_MASK;     /* Enable SPI                               */
   \   0000005E   0x7881             LDRB     R1,[R0, #+2]
   \   00000060   0x2240             MOVS     R2,#+64
   \   00000062   0x430A             ORRS     R2,R2,R1
   \   00000064   0x7082             STRB     R2,[R0, #+2]
     63          }
   \   00000066   0xB002             ADD      SP,SP,#+8
   \   00000068   0xBD10             POP      {R4,PC}          ;; return
     64          
     65          /******************************************************************************
     66           * Simple SPI Tx/Rx function (1 word Tx + 1 word Rx)                          *
     67           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     68          uint16 SPI0_TxRxWord(uint16 txdata)
     69          {
   \                     SPI0_TxRxWord: (+1)
   \   00000000   0x2220             MOVS     R2,#+32
   \   00000002   0x....             LDR      R1,??DataTable9  ;; 0x40075000
     70            while (!SPI_TxCmpl(SPI0));      /* wait until Tx buffer is empty            */
   \                     ??SPI0_TxRxWord_0: (+1)
   \   00000004   0x780B             LDRB     R3,[R1, #+0]
   \   00000006   0x4213             TST      R3,R2
   \   00000008   0xD0FC             BEQ      ??SPI0_TxRxWord_0
     71            SPI_PutWord(SPI0,txdata);       /* write a 16-bit data                      */
   \   0000000A   0x7188             STRB     R0,[R1, #+6]
   \   0000000C   0x0A00             LSRS     R0,R0,#+8
   \   0000000E   0x71C8             STRB     R0,[R1, #+7]
   \   00000010   0x2080             MOVS     R0,#+128
     72            while(!SPI_RxFull(SPI0));       /* wait until Rx buffer is full             */
   \                     ??SPI0_TxRxWord_1: (+1)
   \   00000012   0x780A             LDRB     R2,[R1, #+0]
   \   00000014   0x4202             TST      R2,R0
   \   00000016   0xD0FC             BEQ      ??SPI0_TxRxWord_1
     73            return (SPI_GetWord(SPI0));     /* read data and exit                       */
   \   00000018   0x798A             LDRB     R2,[R1, #+6]
   \   0000001A   0x79C8             LDRB     R0,[R1, #+7]
   \   0000001C   0x0200             LSLS     R0,R0,#+8
   \   0000001E   0x4310             ORRS     R0,R0,R2
   \   00000020   0x4770             BX       LR               ;; return
     74          }
     75          

   \                                 In section .text, align 2, keep-with-next
     76          uint16 SPI1_TxRxWord(uint16 txdata)
     77          {
   \                     SPI1_TxRxWord: (+1)
   \   00000000   0x2220             MOVS     R2,#+32
   \   00000002   0x....             LDR      R1,??DataTable10  ;; 0x40076000
     78            while (!SPI_TxCmpl(SPI1));      /* wait until Tx buffer is empty            */
   \                     ??SPI1_TxRxWord_0: (+1)
   \   00000004   0x780B             LDRB     R3,[R1, #+0]
   \   00000006   0x4213             TST      R3,R2
   \   00000008   0xD0FC             BEQ      ??SPI1_TxRxWord_0
     79            SPI_PutWord(SPI1,txdata);       /* write a 16-bit data                      */
   \   0000000A   0x7188             STRB     R0,[R1, #+6]
   \   0000000C   0x0A00             LSRS     R0,R0,#+8
   \   0000000E   0x71C8             STRB     R0,[R1, #+7]
   \   00000010   0x2080             MOVS     R0,#+128
     80            while(!SPI_RxFull(SPI1));       /* wait until Rx buffer is full             */
   \                     ??SPI1_TxRxWord_1: (+1)
   \   00000012   0x780A             LDRB     R2,[R1, #+0]
   \   00000014   0x4202             TST      R2,R0
   \   00000016   0xD0FC             BEQ      ??SPI1_TxRxWord_1
     81            return (SPI_GetWord(SPI1));     /* read data and exit                       */
   \   00000018   0x798A             LDRB     R2,[R1, #+6]
   \   0000001A   0x79C8             LDRB     R0,[R1, #+7]
   \   0000001C   0x0200             LSLS     R0,R0,#+8
   \   0000001E   0x4310             ORRS     R0,R0,R2
   \   00000020   0x4770             BX       LR               ;; return
     82          }
     83          
     84          /******************************************************************************
     85           * Simple SPI Tx/Rx function (1 byte Tx + 1 byte Rx)                          *
     86           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     87          uint8 SPI0_TxRxByte(uint8 txdata)
     88          {
   \                     SPI0_TxRxByte: (+1)
   \   00000000   0x2120             MOVS     R1,#+32
   \   00000002   0x....             LDR      R2,??DataTable9  ;; 0x40075000
     89            while (!SPI_TxCmpl(SPI0));      /* wait until Tx buffer is empty            */
   \                     ??SPI0_TxRxByte_0: (+1)
   \   00000004   0x7813             LDRB     R3,[R2, #+0]
   \   00000006   0x420B             TST      R3,R1
   \   00000008   0xD0FC             BEQ      ??SPI0_TxRxByte_0
     90            SPI_PutByte(SPI0,txdata);       /* write an 8-bit data                      */
   \   0000000A   0x7190             STRB     R0,[R2, #+6]
   \   0000000C   0x2080             MOVS     R0,#+128
     91            while(!SPI_RxFull(SPI0));       /* wait until Rx buffer is full             */
   \                     ??SPI0_TxRxByte_1: (+1)
   \   0000000E   0x7811             LDRB     R1,[R2, #+0]
   \   00000010   0x4201             TST      R1,R0
   \   00000012   0xD0FC             BEQ      ??SPI0_TxRxByte_1
     92            return (SPI_GetByte(SPI0));     /* read data and exit                       */
   \   00000014   0x7990             LDRB     R0,[R2, #+6]
   \   00000016   0x4770             BX       LR               ;; return
     93          }
     94          

   \                                 In section .text, align 2, keep-with-next
     95          uint8 SPI1_TxRxByte(uint8 txdata)
     96          {
   \                     SPI1_TxRxByte: (+1)
   \   00000000   0x2120             MOVS     R1,#+32
   \   00000002   0x....             LDR      R2,??DataTable10  ;; 0x40076000
     97            while (!SPI_TxCmpl(SPI1));      /* wait until Tx buffer is empty            */
   \                     ??SPI1_TxRxByte_0: (+1)
   \   00000004   0x7813             LDRB     R3,[R2, #+0]
   \   00000006   0x420B             TST      R3,R1
   \   00000008   0xD0FC             BEQ      ??SPI1_TxRxByte_0
     98            SPI_PutByte(SPI1,txdata);       /* write an 8-bit data                      */
   \   0000000A   0x7190             STRB     R0,[R2, #+6]
   \   0000000C   0x2080             MOVS     R0,#+128
     99            while(!SPI_RxFull(SPI1));       /* wait until Rx buffer is full             */
   \                     ??SPI1_TxRxByte_1: (+1)
   \   0000000E   0x7811             LDRB     R1,[R2, #+0]
   \   00000010   0x4201             TST      R1,R0
   \   00000012   0xD0FC             BEQ      ??SPI1_TxRxByte_1
    100            return (SPI_GetByte(SPI1));     /* read data and exit                       */
   \   00000014   0x7990             LDRB     R0,[R2, #+6]
   \   00000016   0x4770             BX       LR               ;; return
    101          }
    102          
    103          /******************************************************************************
    104           * Communication via an SPI (Tx+Rx data packet) with driving a slave select   *
    105           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    106          void SPI0_CommWord(uint16 *txdata, uint16 txcnt,uint16 *rxdata, uint16 rxcnt)
    107          {
   \                     SPI0_CommWord: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x....             LDR      R0,??DataTable7
   \   0000000A   0x6841             LDR      R1,[R0, #+4]
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xD001             BEQ      ??SPI0_CommWord_0
    108            register uint16 i;
    109          
    110            /* SS=0                                                                     */
    111            if (pCallbackSS0)  { pCallbackSS0 (SS_CLEAR); }
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4788             BLX      R1
    112          
    113            if (txdata) {                   /* any data for transmitting?               */
   \                     ??SPI0_CommWord_0: (+1)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD013             BEQ      ??SPI0_CommWord_1
    114              for (i=0; i<txcnt; i++) {     /* writing cycle                            */
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD011             BEQ      ??SPI0_CommWord_1
   \   0000001C   0x2080             MOVS     R0,#+128
   \   0000001E   0x2120             MOVS     R1,#+32
   \   00000020   0x....             LDR      R2,??DataTable9  ;; 0x40075000
    115                SPI_TxRxWord(SPI0,*txdata); /* Write a 16-bit data                      */
   \                     ??SPI0_CommWord_2: (+1)
   \   00000022   0x8823             LDRH     R3,[R4, #+0]
   \                     ??SPI0_CommWord_3: (+1)
   \   00000024   0x7817             LDRB     R7,[R2, #+0]
   \   00000026   0x420F             TST      R7,R1
   \   00000028   0xD0FC             BEQ      ??SPI0_CommWord_3
   \   0000002A   0x7193             STRB     R3,[R2, #+6]
   \   0000002C   0x0A1B             LSRS     R3,R3,#+8
   \   0000002E   0x71D3             STRB     R3,[R2, #+7]
   \                     ??SPI0_CommWord_4: (+1)
   \   00000030   0x7813             LDRB     R3,[R2, #+0]
   \   00000032   0x4203             TST      R3,R0
   \   00000034   0xD0FC             BEQ      ??SPI0_CommWord_4
   \   00000036   0x7993             LDRB     R3,[R2, #+6]
   \   00000038   0x79D3             LDRB     R3,[R2, #+7]
    116                txdata++;                   /* increment a source address               */
   \   0000003A   0x1CA4             ADDS     R4,R4,#+2
    117              }
   \   0000003C   0x1E6D             SUBS     R5,R5,#+1
   \   0000003E   0xD1F0             BNE      ??SPI0_CommWord_2
    118            }
    119          
    120            if (rxdata) {                   /* any data for receiving?                  */
   \                     ??SPI0_CommWord_1: (+1)
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD01A             BEQ      ??SPI0_CommWord_5
    121              for (i=0; i<rxcnt; i++) {     /* reading cycle                            */
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x8800             LDRH     R0,[R0, #+0]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD016             BEQ      ??SPI0_CommWord_5
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x8803             LDRH     R3,[R0, #+0]
   \   00000050   0x24FF             MOVS     R4,#+255
   \   00000052   0x2080             MOVS     R0,#+128
   \   00000054   0x2120             MOVS     R1,#+32
   \   00000056   0x....             LDR      R2,??DataTable9  ;; 0x40075000
   \                     ??SPI0_CommWord_6: (+1)
   \   00000058   0x7815             LDRB     R5,[R2, #+0]
   \   0000005A   0x420D             TST      R5,R1
   \   0000005C   0xD0FC             BEQ      ??SPI0_CommWord_6
   \   0000005E   0x7194             STRB     R4,[R2, #+6]
   \   00000060   0x2500             MOVS     R5,#+0
   \   00000062   0x71D5             STRB     R5,[R2, #+7]
   \                     ??SPI0_CommWord_7: (+1)
   \   00000064   0x7815             LDRB     R5,[R2, #+0]
   \   00000066   0x4205             TST      R5,R0
   \   00000068   0xD0FC             BEQ      ??SPI0_CommWord_7
   \   0000006A   0x7995             LDRB     R5,[R2, #+6]
   \   0000006C   0x79D7             LDRB     R7,[R2, #+7]
   \   0000006E   0x023F             LSLS     R7,R7,#+8
   \   00000070   0x432F             ORRS     R7,R7,R5
   \   00000072   0x8037             STRH     R7,[R6, #+0]
    122                /* read a 16-bit data with writing a dummy data to generate SCLK signal */
    123                *rxdata=SPI_TxRxWord(SPI0,0xFF);/* 0xFF is dummy data for writing!      */
    124                rxdata++;                   /* increment a destination address          */
   \   00000074   0x1CB6             ADDS     R6,R6,#+2
    125              }
   \   00000076   0x1E5B             SUBS     R3,R3,#+1
   \   00000078   0xD1EE             BNE      ??SPI0_CommWord_6
    126            }
    127          
    128            /* SS=1                                                                     */
    129            if (pCallbackSS0) { pCallbackSS0 (SS_SET); }
   \                     ??SPI0_CommWord_5: (+1)
   \   0000007A   0x....             LDR      R0,??DataTable7
   \   0000007C   0x6841             LDR      R1,[R0, #+4]
   \   0000007E   0x0008             MOVS     R0,R1
   \   00000080   0xD001             BEQ      ??SPI0_CommWord_8
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x4788             BLX      R1
    130          }
   \                     ??SPI0_CommWord_8: (+1)
   \   00000086   0xB001             ADD      SP,SP,#+4
   \   00000088   0xBDF0             POP      {R4-R7,PC}       ;; return
    131          

   \                                 In section .text, align 2, keep-with-next
    132          void SPI0_CommByte(uint8 *txdata, uint16 txcnt,uint8 *rxdata, uint16 rxcnt)
    133          {
   \                     SPI0_CommByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x....             LDR      R0,??DataTable7
   \   0000000A   0x6841             LDR      R1,[R0, #+4]
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xD001             BEQ      ??SPI0_CommByte_0
    134            register uint16 i;
    135          
    136            /* SS=0                                                                     */
    137            if (pCallbackSS0) { pCallbackSS0 (SS_CLEAR); }
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4788             BLX      R1
    138          
    139            if (txdata) {                   /* any data for transmitting?               */
   \                     ??SPI0_CommByte_0: (+1)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD010             BEQ      ??SPI0_CommByte_1
    140              for (i=0; i<txcnt; i++) {     /* writing cycle                            */
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD00E             BEQ      ??SPI0_CommByte_1
   \   0000001C   0x2080             MOVS     R0,#+128
   \   0000001E   0x2120             MOVS     R1,#+32
   \   00000020   0x....             LDR      R2,??DataTable9  ;; 0x40075000
    141                SPI_TxRxByte(SPI0,*txdata); /* write an 8-bit data                      */
   \                     ??SPI0_CommByte_2: (+1)
   \   00000022   0x7823             LDRB     R3,[R4, #+0]
   \                     ??SPI0_CommByte_3: (+1)
   \   00000024   0x7817             LDRB     R7,[R2, #+0]
   \   00000026   0x420F             TST      R7,R1
   \   00000028   0xD0FC             BEQ      ??SPI0_CommByte_3
   \   0000002A   0x7193             STRB     R3,[R2, #+6]
   \                     ??SPI0_CommByte_4: (+1)
   \   0000002C   0x7813             LDRB     R3,[R2, #+0]
   \   0000002E   0x4203             TST      R3,R0
   \   00000030   0xD0FC             BEQ      ??SPI0_CommByte_4
   \   00000032   0x7993             LDRB     R3,[R2, #+6]
    142                txdata++;                   /* increment a source address               */
   \   00000034   0x1C64             ADDS     R4,R4,#+1
    143              }
   \   00000036   0x1E6D             SUBS     R5,R5,#+1
   \   00000038   0xD1F3             BNE      ??SPI0_CommByte_2
    144            }
    145          
    146            if (rxdata) {                   /* any data for receiving?                  */
   \                     ??SPI0_CommByte_1: (+1)
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD015             BEQ      ??SPI0_CommByte_5
    147              for (i=0; i<rxcnt; i++) {     /* reading cycle                            */
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x8800             LDRH     R0,[R0, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD011             BEQ      ??SPI0_CommByte_5
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x8803             LDRH     R3,[R0, #+0]
   \   0000004A   0x24FF             MOVS     R4,#+255
   \   0000004C   0x2080             MOVS     R0,#+128
   \   0000004E   0x2120             MOVS     R1,#+32
   \   00000050   0x....             LDR      R2,??DataTable9  ;; 0x40075000
   \                     ??SPI0_CommByte_6: (+1)
   \   00000052   0x7815             LDRB     R5,[R2, #+0]
   \   00000054   0x420D             TST      R5,R1
   \   00000056   0xD0FC             BEQ      ??SPI0_CommByte_6
   \   00000058   0x7194             STRB     R4,[R2, #+6]
   \                     ??SPI0_CommByte_7: (+1)
   \   0000005A   0x7815             LDRB     R5,[R2, #+0]
   \   0000005C   0x4205             TST      R5,R0
   \   0000005E   0xD0FC             BEQ      ??SPI0_CommByte_7
   \   00000060   0x7995             LDRB     R5,[R2, #+6]
   \   00000062   0x7035             STRB     R5,[R6, #+0]
    148                /* read an 8-bit data with writing a dummy data to generate SCLK signal */
    149                *rxdata=SPI_TxRxByte(SPI0,0xFF);/* 0xFF is dummy data for writing!      */
    150                rxdata++;                   /* increment a destination address          */
   \   00000064   0x1C76             ADDS     R6,R6,#+1
    151              }
   \   00000066   0x1E5B             SUBS     R3,R3,#+1
   \   00000068   0xD1F3             BNE      ??SPI0_CommByte_6
    152            }
    153          
    154            /* SS=1                                                                     */
    155            if (pCallbackSS0) { pCallbackSS0 (SS_SET); }
   \                     ??SPI0_CommByte_5: (+1)
   \   0000006A   0x....             LDR      R0,??DataTable7
   \   0000006C   0x6841             LDR      R1,[R0, #+4]
   \   0000006E   0x0008             MOVS     R0,R1
   \   00000070   0xD001             BEQ      ??SPI0_CommByte_8
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x4788             BLX      R1
    156          }
   \                     ??SPI0_CommByte_8: (+1)
   \   00000076   0xB001             ADD      SP,SP,#+4
   \   00000078   0xBDF0             POP      {R4-R7,PC}       ;; return
    157          

   \                                 In section .text, align 2, keep-with-next
    158          void SPI1_CommWord(uint16 *txdata, uint16 txcnt,uint16 *rxdata, uint16 rxcnt)
    159          {
   \                     SPI1_CommWord: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x....             LDR      R0,??DataTable8_1
   \   0000000A   0x6841             LDR      R1,[R0, #+4]
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xD001             BEQ      ??SPI1_CommWord_0
    160            register uint16 i;
    161          
    162            /* SS=0                                                                     */
    163            if (pCallbackSS1) { pCallbackSS1 (SS_CLEAR); }
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4788             BLX      R1
    164          
    165            if (txdata) {                   /* any data for transmitting?               */
   \                     ??SPI1_CommWord_0: (+1)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD013             BEQ      ??SPI1_CommWord_1
    166              for (i=0; i<txcnt; i++) {     /* writing cycle                            */
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD011             BEQ      ??SPI1_CommWord_1
   \   0000001C   0x2080             MOVS     R0,#+128
   \   0000001E   0x2120             MOVS     R1,#+32
   \   00000020   0x....             LDR      R2,??DataTable10  ;; 0x40076000
    167                SPI_TxRxWord(SPI1,*txdata); /* write a 16-bit data                      */
   \                     ??SPI1_CommWord_2: (+1)
   \   00000022   0x8823             LDRH     R3,[R4, #+0]
   \                     ??SPI1_CommWord_3: (+1)
   \   00000024   0x7817             LDRB     R7,[R2, #+0]
   \   00000026   0x420F             TST      R7,R1
   \   00000028   0xD0FC             BEQ      ??SPI1_CommWord_3
   \   0000002A   0x7193             STRB     R3,[R2, #+6]
   \   0000002C   0x0A1B             LSRS     R3,R3,#+8
   \   0000002E   0x71D3             STRB     R3,[R2, #+7]
   \                     ??SPI1_CommWord_4: (+1)
   \   00000030   0x7813             LDRB     R3,[R2, #+0]
   \   00000032   0x4203             TST      R3,R0
   \   00000034   0xD0FC             BEQ      ??SPI1_CommWord_4
   \   00000036   0x7993             LDRB     R3,[R2, #+6]
   \   00000038   0x79D3             LDRB     R3,[R2, #+7]
    168                txdata++;                   /* increment a source address               */
   \   0000003A   0x1CA4             ADDS     R4,R4,#+2
    169              }
   \   0000003C   0x1E6D             SUBS     R5,R5,#+1
   \   0000003E   0xD1F0             BNE      ??SPI1_CommWord_2
    170            }
    171          
    172            if (rxdata) {                   /* any data for receiving?                  */
   \                     ??SPI1_CommWord_1: (+1)
   \   00000040   0x2E00             CMP      R6,#+0
   \   00000042   0xD01A             BEQ      ??SPI1_CommWord_5
    173              for (i=0; i<rxcnt; i++) {     /* reading cycle                            */
   \   00000044   0x4668             MOV      R0,SP
   \   00000046   0x8800             LDRH     R0,[R0, #+0]
   \   00000048   0x2800             CMP      R0,#+0
   \   0000004A   0xD016             BEQ      ??SPI1_CommWord_5
   \   0000004C   0x4668             MOV      R0,SP
   \   0000004E   0x8803             LDRH     R3,[R0, #+0]
   \   00000050   0x24FF             MOVS     R4,#+255
   \   00000052   0x2080             MOVS     R0,#+128
   \   00000054   0x2120             MOVS     R1,#+32
   \   00000056   0x....             LDR      R2,??DataTable10  ;; 0x40076000
   \                     ??SPI1_CommWord_6: (+1)
   \   00000058   0x7815             LDRB     R5,[R2, #+0]
   \   0000005A   0x420D             TST      R5,R1
   \   0000005C   0xD0FC             BEQ      ??SPI1_CommWord_6
   \   0000005E   0x7194             STRB     R4,[R2, #+6]
   \   00000060   0x2500             MOVS     R5,#+0
   \   00000062   0x71D5             STRB     R5,[R2, #+7]
   \                     ??SPI1_CommWord_7: (+1)
   \   00000064   0x7815             LDRB     R5,[R2, #+0]
   \   00000066   0x4205             TST      R5,R0
   \   00000068   0xD0FC             BEQ      ??SPI1_CommWord_7
   \   0000006A   0x7995             LDRB     R5,[R2, #+6]
   \   0000006C   0x79D7             LDRB     R7,[R2, #+7]
   \   0000006E   0x023F             LSLS     R7,R7,#+8
   \   00000070   0x432F             ORRS     R7,R7,R5
   \   00000072   0x8037             STRH     R7,[R6, #+0]
    174                /* read a 16-bit data with writing a dummy data to generate SCLK signal */
    175                *rxdata=SPI_TxRxWord(SPI1,0xFF);/* 0xFF is dummy data for writing!      */
    176                rxdata++;                   /* increment a destination address          */
   \   00000074   0x1CB6             ADDS     R6,R6,#+2
    177              }
   \   00000076   0x1E5B             SUBS     R3,R3,#+1
   \   00000078   0xD1EE             BNE      ??SPI1_CommWord_6
    178            }
    179          
    180            /* SS=1                                                                     */
    181            if (pCallbackSS1) { pCallbackSS1 (SS_SET); }
   \                     ??SPI1_CommWord_5: (+1)
   \   0000007A   0x....             LDR      R0,??DataTable8_1
   \   0000007C   0x6841             LDR      R1,[R0, #+4]
   \   0000007E   0x0008             MOVS     R0,R1
   \   00000080   0xD001             BEQ      ??SPI1_CommWord_8
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x4788             BLX      R1
    182          }
   \                     ??SPI1_CommWord_8: (+1)
   \   00000086   0xB001             ADD      SP,SP,#+4
   \   00000088   0xBDF0             POP      {R4-R7,PC}       ;; return
    183          

   \                                 In section .text, align 2, keep-with-next
    184          void SPI1_CommByte(uint8 *txdata, uint16 txcnt,uint8 *rxdata, uint16 rxcnt)
    185          {
   \                     SPI1_CommByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0x....             LDR      R0,??DataTable15
   \   0000000A   0x6841             LDR      R1,[R0, #+4]
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0xD001             BEQ      ??SPI1_CommByte_0
    186            register uint16 i;
    187          
    188            /* SS=0                                                                     */
    189            if (pCallbackSS1) { pCallbackSS1 (SS_CLEAR); }
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4788             BLX      R1
    190          
    191            if (txdata) {                   /* any data for transmitting?               */
   \                     ??SPI1_CommByte_0: (+1)
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD010             BEQ      ??SPI1_CommByte_1
    192              for (i=0; i<txcnt; i++) {     /* writing cycle                            */
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD00E             BEQ      ??SPI1_CommByte_1
   \   0000001C   0x2080             MOVS     R0,#+128
   \   0000001E   0x2120             MOVS     R1,#+32
   \   00000020   0x....             LDR      R2,??DataTable10  ;; 0x40076000
    193                SPI_TxRxByte(SPI1,*txdata); /* write an 8-bit data                      */
   \                     ??SPI1_CommByte_2: (+1)
   \   00000022   0x7823             LDRB     R3,[R4, #+0]
   \                     ??SPI1_CommByte_3: (+1)
   \   00000024   0x7817             LDRB     R7,[R2, #+0]
   \   00000026   0x420F             TST      R7,R1
   \   00000028   0xD0FC             BEQ      ??SPI1_CommByte_3
   \   0000002A   0x7193             STRB     R3,[R2, #+6]
   \                     ??SPI1_CommByte_4: (+1)
   \   0000002C   0x7813             LDRB     R3,[R2, #+0]
   \   0000002E   0x4203             TST      R3,R0
   \   00000030   0xD0FC             BEQ      ??SPI1_CommByte_4
   \   00000032   0x7993             LDRB     R3,[R2, #+6]
    194                txdata++;                   /* increment a source address               */
   \   00000034   0x1C64             ADDS     R4,R4,#+1
    195              }
   \   00000036   0x1E6D             SUBS     R5,R5,#+1
   \   00000038   0xD1F3             BNE      ??SPI1_CommByte_2
    196            }
    197          
    198            if (rxdata) {                   /* any data for receiving?                  */
   \                     ??SPI1_CommByte_1: (+1)
   \   0000003A   0x2E00             CMP      R6,#+0
   \   0000003C   0xD015             BEQ      ??SPI1_CommByte_5
    199              for (i=0; i<rxcnt; i++) {     /* reading cycle                            */
   \   0000003E   0x4668             MOV      R0,SP
   \   00000040   0x8800             LDRH     R0,[R0, #+0]
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD011             BEQ      ??SPI1_CommByte_5
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x8803             LDRH     R3,[R0, #+0]
   \   0000004A   0x24FF             MOVS     R4,#+255
   \   0000004C   0x2080             MOVS     R0,#+128
   \   0000004E   0x2120             MOVS     R1,#+32
   \   00000050   0x....             LDR      R2,??DataTable10  ;; 0x40076000
   \                     ??SPI1_CommByte_6: (+1)
   \   00000052   0x7815             LDRB     R5,[R2, #+0]
   \   00000054   0x420D             TST      R5,R1
   \   00000056   0xD0FC             BEQ      ??SPI1_CommByte_6
   \   00000058   0x7194             STRB     R4,[R2, #+6]
   \                     ??SPI1_CommByte_7: (+1)
   \   0000005A   0x7815             LDRB     R5,[R2, #+0]
   \   0000005C   0x4205             TST      R5,R0
   \   0000005E   0xD0FC             BEQ      ??SPI1_CommByte_7
   \   00000060   0x7995             LDRB     R5,[R2, #+6]
   \   00000062   0x7035             STRB     R5,[R6, #+0]
    200                /*read an 8-bit data with writing a dummy data to generate SCLK signal  */
    201                *rxdata=SPI_TxRxByte(SPI1,0xFF);/* 0xFF is dummy data for writing!      */
    202                rxdata++;                   /* increment a destination address          */
   \   00000064   0x1C76             ADDS     R6,R6,#+1
    203              }
   \   00000066   0x1E5B             SUBS     R3,R3,#+1
   \   00000068   0xD1F3             BNE      ??SPI1_CommByte_6
    204            }
    205          
    206            /* SS=1                                                                     */
    207            if (pCallbackSS1) { pCallbackSS1 (SS_SET); }
   \                     ??SPI1_CommByte_5: (+1)
   \   0000006A   0x....             LDR      R0,??DataTable15
   \   0000006C   0x6841             LDR      R1,[R0, #+4]
   \   0000006E   0x0008             MOVS     R0,R1
   \   00000070   0xD001             BEQ      ??SPI1_CommByte_8
   \   00000072   0x2001             MOVS     R0,#+1
   \   00000074   0x4788             BLX      R1
    208          }
   \                     ??SPI1_CommByte_8: (+1)
   \   00000076   0xB001             ADD      SP,SP,#+4
   \   00000078   0xBDF0             POP      {R4-R7,PC}       ;; return
    209          

   \                                 In section .text, align 2, keep-with-next
    210          void SPI1_PutWordToFifo(uint16 *txdata, uint32 txcnt)
    211          {
    212            register uint32 i;
    213          
    214            if (txdata) {                   /* any data for transmitting?               */
   \                     SPI1_PutWordToFifo: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      ??SPI1_PutWordToFifo_0
   \   00000004   0x4770             BX       LR
    215              for (i=0; i<txcnt; i++) {     /* writing cycle                            */
   \                     ??SPI1_PutWordToFifo_0: (+1)
   \   00000006   0xB430             PUSH     {R4,R5}
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x2280             MOVS     R2,#+128
   \   0000000C   0x....             LDR      R3,??DataTable15_1  ;; 0x40076000
   \   0000000E   0xE005             B        ??SPI1_PutWordToFifo_1
    216                if(!(SPI_TxFifoFull(SPI1))) {  /* isn't transmit FIFO full?             */
    217                  SPI_PutWord(SPI1,*txdata);/* write 16-bit data                        */
   \                     ??SPI1_PutWordToFifo_2: (+1)
   \   00000010   0x8805             LDRH     R5,[R0, #+0]
   \   00000012   0x719D             STRB     R5,[R3, #+6]
   \   00000014   0x0A2D             LSRS     R5,R5,#+8
   \   00000016   0x71DD             STRB     R5,[R3, #+7]
    218                  txdata++;                 /* increment a source address               */
   \   00000018   0x1C80             ADDS     R0,R0,#+2
    219                }
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \                     ??SPI1_PutWordToFifo_1: (+1)
   \   0000001C   0x428C             CMP      R4,R1
   \   0000001E   0xD202             BCS      ??SPI1_PutWordToFifo_3
   \   00000020   0x781D             LDRB     R5,[R3, #+0]
   \   00000022   0x4215             TST      R5,R2
   \   00000024   0xD0F4             BEQ      ??SPI1_PutWordToFifo_2
    220                else {
    221                  return;
    222                }
    223              }
    224            }
    225          }
   \                     ??SPI1_PutWordToFifo_3: (+1)
   \   00000026   0xBC30             POP      {R4,R5}
   \   00000028   0x4770             BX       LR               ;; return
    226          

   \                                 In section .text, align 2, keep-with-next
    227          void SPI1_PutByteToFifo(uint8 *txdata, uint32 txcnt)
    228          {
    229            register uint32 i;
    230          
    231            if (txdata) {                   /* any data for transmitting?               */
   \                     SPI1_PutByteToFifo: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      ??SPI1_PutByteToFifo_0
   \   00000004   0x4770             BX       LR
    232              for (i=0; i<txcnt; i++) {     /* writing cycle                            */
   \                     ??SPI1_PutByteToFifo_0: (+1)
   \   00000006   0xB430             PUSH     {R4,R5}
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x2380             MOVS     R3,#+128
   \   0000000C   0x....             LDR      R4,??DataTable15_1  ;; 0x40076000
   \   0000000E   0xE003             B        ??SPI1_PutByteToFifo_1
    233                if(!(SPI_TxFifoFull(SPI1))) {  /* isn't transmit FIFO full?             */
    234                  SPI_PutByte(SPI1,*txdata);/* write 8-bit data                         */
   \                     ??SPI1_PutByteToFifo_2: (+1)
   \   00000010   0x7805             LDRB     R5,[R0, #+0]
   \   00000012   0x71A5             STRB     R5,[R4, #+6]
    235                  txdata++;                 /* increment a source address               */
   \   00000014   0x1C40             ADDS     R0,R0,#+1
    236                }
   \   00000016   0x1C52             ADDS     R2,R2,#+1
   \                     ??SPI1_PutByteToFifo_1: (+1)
   \   00000018   0x428A             CMP      R2,R1
   \   0000001A   0xD202             BCS      ??SPI1_PutByteToFifo_3
   \   0000001C   0x7825             LDRB     R5,[R4, #+0]
   \   0000001E   0x421D             TST      R5,R3
   \   00000020   0xD0F6             BEQ      ??SPI1_PutByteToFifo_2
    237                else {
    238                  return;
    239                }
    240              }
    241            }
    242          }
   \                     ??SPI1_PutByteToFifo_3: (+1)
   \   00000022   0xBC30             POP      {R4,R5}
   \   00000024   0x4770             BX       LR               ;; return
    243          

   \                                 In section .text, align 2, keep-with-next
    244          void SPI1_GetWordFromFifo(uint16 *rxdata, uint32 rxcnt)
    245          {
    246            register uint32 i;
    247          
    248            if (rxdata) {                   /* any data for receiving?                  */
   \                     SPI1_GetWordFromFifo: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      ??SPI1_GetWordFromFifo_0
   \   00000004   0x4770             BX       LR
    249              for (i=0; i<rxcnt; i++) {     /* reading cycle                            */
   \                     ??SPI1_GetWordFromFifo_0: (+1)
   \   00000006   0xB430             PUSH     {R4,R5}
   \   00000008   0x2300             MOVS     R3,#+0
   \   0000000A   0x....             LDR      R2,??DataTable15_1  ;; 0x40076000
   \   0000000C   0xE001             B        ??SPI1_GetWordFromFifo_1
    250                  *rxdata = SPI_GetWord(SPI1); /* read 16-bit data                      */
    251                  if(SPI_RxFifoEmpty(SPI1)) {  /* is receive FIFO empty?                */
    252                  return;
    253                }
    254                  rxdata++;                 /* increment a destination address          */
   \                     ??SPI1_GetWordFromFifo_2: (+1)
   \   0000000E   0x1C80             ADDS     R0,R0,#+2
   \   00000010   0x1C5B             ADDS     R3,R3,#+1
   \                     ??SPI1_GetWordFromFifo_1: (+1)
   \   00000012   0x428B             CMP      R3,R1
   \   00000014   0xD207             BCS      ??SPI1_GetWordFromFifo_3
   \   00000016   0x7994             LDRB     R4,[R2, #+6]
   \   00000018   0x79D5             LDRB     R5,[R2, #+7]
   \   0000001A   0x022D             LSLS     R5,R5,#+8
   \   0000001C   0x4325             ORRS     R5,R5,R4
   \   0000001E   0x8005             STRH     R5,[R0, #+0]
   \   00000020   0x7814             LDRB     R4,[R2, #+0]
   \   00000022   0x07E4             LSLS     R4,R4,#+31
   \   00000024   0xD5F3             BPL      ??SPI1_GetWordFromFifo_2
    255              }
    256            }
    257          }
   \                     ??SPI1_GetWordFromFifo_3: (+1)
   \   00000026   0xBC30             POP      {R4,R5}
   \   00000028   0x4770             BX       LR               ;; return
    258          

   \                                 In section .text, align 2, keep-with-next
    259          void SPI1_GetByteFromFifo(uint8 *rxdata, uint32 rxcnt)
    260          {
    261            register uint32 i;
    262          
    263            if (rxdata) {                   /* any data for receiving?                  */
   \                     SPI1_GetByteFromFifo: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD100             BNE      ??SPI1_GetByteFromFifo_0
   \   00000004   0x4770             BX       LR
    264              for (i=0; i<rxcnt; i++) {     /* reading cycle                            */
   \                     ??SPI1_GetByteFromFifo_0: (+1)
   \   00000006   0xB410             PUSH     {R4}
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x....             LDR      R3,??DataTable15_1  ;; 0x40076000
   \   0000000C   0xE001             B        ??SPI1_GetByteFromFifo_1
    265                  *rxdata = SPI_GetByte(SPI1); /* read 8-bit data                       */
    266                  if(SPI_RxFifoEmpty(SPI1)) {  /* is receive FIFO empty?                */
    267                  return;
    268                }
    269              rxdata++;                     /* increment a destination address          */
   \                     ??SPI1_GetByteFromFifo_2: (+1)
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x1C52             ADDS     R2,R2,#+1
   \                     ??SPI1_GetByteFromFifo_1: (+1)
   \   00000012   0x428A             CMP      R2,R1
   \   00000014   0xD204             BCS      ??SPI1_GetByteFromFifo_3
   \   00000016   0x799C             LDRB     R4,[R3, #+6]
   \   00000018   0x7004             STRB     R4,[R0, #+0]
   \   0000001A   0x781C             LDRB     R4,[R3, #+0]
   \   0000001C   0x07E4             LSLS     R4,R4,#+31
   \   0000001E   0xD5F6             BPL      ??SPI1_GetByteFromFifo_2
    270              }
    271            }
    272          }
   \                     ??SPI1_GetByteFromFifo_3: (+1)
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    273          /******************************************************************************
    274           * interrupt function definitions                                             *
    275           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    276          weak void spi0_isr (void)
    277          {
   \                     spi0_isr: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    278            register uint8 tmp = SPI0_S;
   \   00000004   0x....             LDR      R4,??DataTable15_2  ;; 0x40075000
   \   00000006   0x7825             LDRB     R5,[R4, #+0]
    279          
    280            /* Rx buffer or FIFO buffer is full; SPRF is cleared by reading data        */
    281            /* registers DH:DL                                                          */
    282            if(tmp & SPI_S_SPRF_MASK) { pCallbackSPI0 (SPI0_CALLBACK,SPI_RX_CALLBACK); }
   \   00000008   0x0628             LSLS     R0,R5,#+24
   \   0000000A   0xD504             BPL      ??spi0_isr_0
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x....             LDR      R2,??DataTable15_3
   \   00000012   0x6812             LDR      R2,[R2, #+0]
   \   00000014   0x4790             BLX      R2
    283          
    284            /* Tx buffer or FIFO buffer is empty; SPTEF is cleared by writing a value   */
    285            /* to DH:DL                                                                 */
    286            if(tmp & SPI_S_SPTEF_MASK){ pCallbackSPI0 (SPI0_CALLBACK,SPI_TX_CALLBACK); }
   \                     ??spi0_isr_0: (+1)
   \   00000016   0x06A8             LSLS     R0,R5,#+26
   \   00000018   0xD504             BPL      ??spi0_isr_1
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x....             LDR      R2,??DataTable15_3
   \   00000020   0x6812             LDR      R2,[R2, #+0]
   \   00000022   0x4790             BLX      R2
    287          
    288            /* Receive data buffer matches the value in MH:ML registers                 */
    289            if(tmp & SPI_S_SPMF_MASK)
   \                     ??spi0_isr_1: (+1)
   \   00000024   0x2040             MOVS     R0,#+64
   \   00000026   0x4205             TST      R5,R0
   \   00000028   0xD005             BEQ      ??spi0_isr_2
    290            {
    291              SPI0_S = SPI_S_SPMF_MASK;                              /* clear SPMF flag */
   \   0000002A   0x7020             STRB     R0,[R4, #+0]
    292              pCallbackSPI0 (SPI0_CALLBACK,SPI_MATCH_CALLBACK);
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x....             LDR      R2,??DataTable15_3
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0x4790             BLX      R2
    293            }
    294          
    295            /* Mode fault error detected (Only for MSTR=1, MODFEN=1, SSOE=0)            */
    296            if(tmp & SPI_S_MODF_MASK)
   \                     ??spi0_isr_2: (+1)
   \   00000036   0x06E8             LSLS     R0,R5,#+27
   \   00000038   0xD506             BPL      ??spi0_isr_3
    297            {
    298              SPI0_C1 = SPI0_C1;                                     /* clear MODF flag */
   \   0000003A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000003C   0x70E0             STRB     R0,[R4, #+3]
    299              pCallbackSPI0 (SPI0_CALLBACK,SPI_FAULT_CALLBACK);
   \   0000003E   0x2108             MOVS     R1,#+8
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x....             LDR      R2,??DataTable15_3
   \   00000044   0x6812             LDR      R2,[R2, #+0]
   \   00000046   0x4790             BLX      R2
    300            }
    301          }
   \                     ??spi0_isr_3: (+1)
   \   00000048   0xB001             ADD      SP,SP,#+4
   \   0000004A   0xBD30             POP      {R4,R5,PC}       ;; return
    302          

   \                                 In section .text, align 2, keep-with-next
    303          weak void spi1_isr (void)
    304          {
   \                     spi1_isr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    305            register uint8 tmp = SPI1_S;
   \   00000002   0x....             LDR      R4,??DataTable15_1  ;; 0x40076000
   \   00000004   0x7825             LDRB     R5,[R4, #+0]
    306          
    307            /* Rx buffer or Rx FIFO buffer is full; SPRF is cleared by reading data     */
    308            /* registers DH:DL                                                          */
    309            if(tmp & SPI_S_SPRF_MASK) { pCallbackSPI1 (SPI1_CALLBACK,SPI_RX_CALLBACK); }
   \   00000006   0x....             LDR      R6,??DataTable15
   \   00000008   0x0628             LSLS     R0,R5,#+24
   \   0000000A   0xD503             BPL      ??spi1_isr_0
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x6832             LDR      R2,[R6, #+0]
   \   00000012   0x4790             BLX      R2
    310          
    311            /* Tx buffer or Tx FIFO buffer is empty; SPTEF is cleared by writing a      */
    312            /* value to DH:DL                                                           */
    313            if(tmp & SPI_S_SPTEF_MASK){ pCallbackSPI1 (SPI1_CALLBACK,SPI_TX_CALLBACK); }
   \                     ??spi1_isr_0: (+1)
   \   00000014   0x06A8             LSLS     R0,R5,#+26
   \   00000016   0xD503             BPL      ??spi1_isr_1
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x6832             LDR      R2,[R6, #+0]
   \   0000001E   0x4790             BLX      R2
    314          
    315            /* Receive data buffer matches the value in MH:ML registers                 */
    316            if(tmp & SPI_S_SPMF_MASK)
   \                     ??spi1_isr_1: (+1)
   \   00000020   0x2040             MOVS     R0,#+64
   \   00000022   0x4205             TST      R5,R0
   \   00000024   0xD004             BEQ      ??spi1_isr_2
    317            {
    318              SPI1_S = SPI_S_SPMF_MASK;                              /* clear SPMF flag */
   \   00000026   0x7020             STRB     R0,[R4, #+0]
    319              pCallbackSPI1 (SPI1_CALLBACK,SPI_MATCH_CALLBACK);
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x6832             LDR      R2,[R6, #+0]
   \   0000002E   0x4790             BLX      R2
    320            }
    321          
    322            /* Tx FIFO buffer is near to empty; TNEAREF is cleared when enough data is  */
    323            /* written to FIFO buffer                                                   */
    324            if((tmp & SPI_S_TNEAREF_MASK) && (SPI1_C3 & SPI_C3_TNEARIEN_MASK))
   \                     ??spi1_isr_2: (+1)
   \   00000030   0x2004             MOVS     R0,#+4
   \   00000032   0x4205             TST      R5,R0
   \   00000034   0xD006             BEQ      ??spi1_isr_3
   \   00000036   0x7AE1             LDRB     R1,[R4, #+11]
   \   00000038   0x4201             TST      R1,R0
   \   0000003A   0xD003             BEQ      ??spi1_isr_3
    325            {
    326              pCallbackSPI1 (SPI1_CALLBACK,SPI_TXFNE_CALLBACK);
   \   0000003C   0x2120             MOVS     R1,#+32
   \   0000003E   0x2002             MOVS     R0,#+2
   \   00000040   0x6832             LDR      R2,[R6, #+0]
   \   00000042   0x4790             BLX      R2
    327            }
    328          
    329            /* Rx FIFO buffer is near to full; RNFULLF is cleared when enough data is   */
    330            /* read from FIFO buffer                                                    */
    331            if((tmp & SPI_S_RNFULLF_MASK) && (SPI1_C3 & SPI_C3_RNFULLIEN_MASK))
   \                     ??spi1_isr_3: (+1)
   \   00000044   0x0728             LSLS     R0,R5,#+28
   \   00000046   0xD506             BPL      ??spi1_isr_4
   \   00000048   0x7AE0             LDRB     R0,[R4, #+11]
   \   0000004A   0x0780             LSLS     R0,R0,#+30
   \   0000004C   0xD503             BPL      ??spi1_isr_4
    332            {
    333              pCallbackSPI1 (SPI1_CALLBACK,SPI_RXFNF_CALLBACK);
   \   0000004E   0x2110             MOVS     R1,#+16
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0x6832             LDR      R2,[R6, #+0]
   \   00000054   0x4790             BLX      R2
    334            }
    335          
    336            /* Mode fault error detected (Only for MSTR=1, MODFEN=1, SSOE=0)            */
    337            if(tmp & SPI_S_MODF_MASK)
   \                     ??spi1_isr_4: (+1)
   \   00000056   0x06E8             LSLS     R0,R5,#+27
   \   00000058   0xD505             BPL      ??spi1_isr_5
    338            {
    339              SPI1_C1 = SPI1_C1;                                     /* clear MODF flag */
   \   0000005A   0x78E0             LDRB     R0,[R4, #+3]
   \   0000005C   0x70E0             STRB     R0,[R4, #+3]
    340              pCallbackSPI1 (SPI1_CALLBACK,SPI_FAULT_CALLBACK);
   \   0000005E   0x2108             MOVS     R1,#+8
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x6832             LDR      R2,[R6, #+0]
   \   00000064   0x4790             BLX      R2
    341            }
    342          }
   \                     ??spi1_isr_5: (+1)
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     pCallbackSPI0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0xE000E404         DC32     0xe000e404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x40075001         DC32     0x40075001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     pCallbackSPI1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x40076001         DC32     0x40076001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40075000         DC32     0x40075000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x40076000         DC32     0x40076000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     pCallbackSPI1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x40076000         DC32     0x40076000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x40075000         DC32     0x40075000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     pCallbackSPI0
    343          /******************************************************************************
    344           * End of module                                                              *
    345           ******************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SPI0_CommByte
        24   -- Indirect call
      24   SPI0_CommWord
        24   -- Indirect call
      16   SPI0_Init
        16   -- Indirect call
       0   SPI0_TxRxByte
       0   SPI0_TxRxWord
      24   SPI1_CommByte
        24   -- Indirect call
      24   SPI1_CommWord
        24   -- Indirect call
       4   SPI1_GetByteFromFifo
       8   SPI1_GetWordFromFifo
      16   SPI1_Init
        16   -- Indirect call
       8   SPI1_PutByteToFifo
       8   SPI1_PutWordToFifo
       0   SPI1_TxRxByte
       0   SPI1_TxRxWord
      16   spi0_isr
        16   -- Indirect call
      16   spi1_isr
        16   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable9
     122  SPI0_CommByte
     138  SPI0_CommWord
     100  SPI0_Init
      24  SPI0_TxRxByte
      34  SPI0_TxRxWord
     122  SPI1_CommByte
     138  SPI1_CommWord
      36  SPI1_GetByteFromFifo
      42  SPI1_GetWordFromFifo
     106  SPI1_Init
      38  SPI1_PutByteToFifo
      42  SPI1_PutWordToFifo
      24  SPI1_TxRxByte
      34  SPI1_TxRxWord
       8  pCallbackSPI0
          pCallbackSS0
       8  pCallbackSPI1
          pCallbackSS1
      76  spi0_isr
     104  spi1_isr

 
    16 bytes in section .bss
 1 232 bytes in section .text
 
 1 232 bytes of CODE memory
    16 bytes of DATA memory

Errors: none
Warnings: none
