###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        20/Mar/2017  09:47:58
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_scope.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_scope.c -D
#        NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\Release\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\projects\i2c_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\toolchain\iar\
#        -On
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\Release\List\freemaster_scope.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\Release\Obj\freemaster_scope.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_scope.c
      1          /*******************************************************************************
      2          *
      3          * Copyright 2004-2013 Freescale Semiconductor, Inc.
      4          *
      5          * This software is owned or controlled by Freescale Semiconductor.
      6          * Use of this software is governed by the Freescale FreeMASTER License
      7          * distributed with this Material.
      8          * See the license file distributed for more details.
      9          *
     10          ****************************************************************************//*!
     11          *
     12          * @brief  FreeMASTER Oscilloscope implementation
     13          *
     14          *******************************************************************************/
     15          
     16          #include "freemaster.h"
     17          #include "freemaster_private.h"
     18          #include "freemaster_protocol.h"
     19          
     20          #if (FMSTR_USE_SCOPE) && (!(FMSTR_DISABLE))
     21          
     22          /***********************************
     23          *  local variables
     24          ***********************************/
     25          

   \                                 In section .bss, align 1
     26          static FMSTR_U8  pcm_nScopeVarCount;        /* number of active scope variables */
   \                     pcm_nScopeVarCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     27          static FMSTR_ADDR  pcm_pScopeVarAddr[FMSTR_MAX_SCOPE_VARS]; /* addresses of scope variables */
   \                     pcm_pScopeVarAddr:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
     28          static FMSTR_SIZE8 pcm_pScopeVarSize[FMSTR_MAX_SCOPE_VARS]; /* sizes of scope variables */
   \                     pcm_pScopeVarSize:
   \   00000000                      DS8 8
     29          
     30          /**************************************************************************//*!
     31          *
     32          * @brief    Scope Initialization
     33          *
     34          ******************************************************************************/
     35          

   \                                 In section .text, align 2, keep-with-next
     36          void FMSTR_InitScope(void)
     37          {
     38          }
   \                     FMSTR_InitScope: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     39          
     40          /**************************************************************************//*!
     41          *
     42          * @brief    Handling SETUPSCOPE and SETUPSCOPE_EX command
     43          *
     44          * @param    pMessageIO - original command (in) and response buffer (out)
     45          *
     46          * @return   As all command handlers, the return value should be the buffer
     47          *           pointer where the response output finished (except checksum)
     48          *
     49          ******************************************************************************/
     50          

   \                                 In section .text, align 2, keep-with-next
     51          FMSTR_BPTR FMSTR_SetUpScope(FMSTR_BPTR pMessageIO)
     52          {
   \                     FMSTR_SetUpScope: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0006             MOVS     R6,R0
     53              FMSTR_BPTR pResponse = pMessageIO;
   \   00000004   0x0035             MOVS     R5,R6
     54              FMSTR_U8 i, sz, nVarCnt;
     55          
     56              /* uninitialize scope */
     57              pcm_nScopeVarCount = 0U;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR      R1,??DataTable1
   \   0000000A   0x7008             STRB     R0,[R1, #+0]
     58          
     59              /* seek the setup data */
     60              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
   \   0000000C   0x1CB6             ADDS     R6,R6,#+2
     61          
     62              /* scope variable count  */
     63              pMessageIO = FMSTR_ValueFromBuffer8(&nVarCnt, pMessageIO);
   \   0000000E   0x7830             LDRB     R0,[R6, #+0]
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x7008             STRB     R0,[R1, #+0]
   \   00000014   0x1C76             ADDS     R6,R6,#+1
     64          
     65              /* scope variable information must fit into our buffers */
     66              if(!nVarCnt || nVarCnt > (FMSTR_U8)FMSTR_MAX_SCOPE_VARS)
   \   00000016   0x4668             MOV      R0,SP
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ      ??FMSTR_SetUpScope_0
   \   0000001E   0x4668             MOV      R0,SP
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x2809             CMP      R0,#+9
   \   00000024   0xDB04             BLT      ??FMSTR_SetUpScope_1
     67              {
     68                  return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_INVBUFF);
   \                     ??FMSTR_SetUpScope_0: (+1)
   \   00000026   0x2085             MOVS     R0,#+133
   \   00000028   0x7028             STRB     R0,[R5, #+0]
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0xE02A             B        ??FMSTR_SetUpScope_2
     69              }
     70          
     71              /* get all addresses and sizes */
     72              for(i=0U; i<nVarCnt; i++)
   \                     ??FMSTR_SetUpScope_1: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x0004             MOVS     R4,R0
   \                     ??FMSTR_SetUpScope_3: (+1)
   \   00000034   0x4668             MOV      R0,SP
   \   00000036   0x7800             LDRB     R0,[R0, #+0]
   \   00000038   0xB2E4             UXTB     R4,R4
   \   0000003A   0x4284             CMP      R4,R0
   \   0000003C   0xD21B             BCS      ??FMSTR_SetUpScope_4
     73              {
     74                  /* variable size */
     75                  pMessageIO = FMSTR_ValueFromBuffer8(&sz, pMessageIO);
   \   0000003E   0x7830             LDRB     R0,[R6, #+0]
   \   00000040   0x0007             MOVS     R7,R0
   \   00000042   0x1C76             ADDS     R6,R6,#+1
     76                  pcm_pScopeVarSize[i] = sz;
   \   00000044   0x....             LDR      R0,??DataTable1_1
   \   00000046   0xB2E4             UXTB     R4,R4
   \   00000048   0x5507             STRB     R7,[R0, R4]
     77          
     78                  /* variable address */
     79                  pMessageIO = FMSTR_AddressFromBuffer(&pcm_pScopeVarAddr[i], pMessageIO);
   \   0000004A   0x0031             MOVS     R1,R6
   \   0000004C   0x....             LDR      R0,??DataTable1_2
   \   0000004E   0xB2E4             UXTB     R4,R4
   \   00000050   0x2204             MOVS     R2,#+4
   \   00000052   0x4362             MULS     R2,R4,R2
   \   00000054   0x1880             ADDS     R0,R0,R2
   \   00000056   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   0000005A   0x0006             MOVS     R6,R0
     80          
     81                  /* valid numeric variable sizes only */
     82                  if(sz == 0U || sz > 8U)
   \   0000005C   0xB2FF             UXTB     R7,R7
   \   0000005E   0x2F00             CMP      R7,#+0
   \   00000060   0xD002             BEQ      ??FMSTR_SetUpScope_5
   \   00000062   0xB2FF             UXTB     R7,R7
   \   00000064   0x2F09             CMP      R7,#+9
   \   00000066   0xD304             BCC      ??FMSTR_SetUpScope_6
     83                  {
     84                      return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_INVSIZE);
   \                     ??FMSTR_SetUpScope_5: (+1)
   \   00000068   0x2086             MOVS     R0,#+134
   \   0000006A   0x7028             STRB     R0,[R5, #+0]
   \   0000006C   0x1C6D             ADDS     R5,R5,#+1
   \   0000006E   0x0028             MOVS     R0,R5
   \   00000070   0xE009             B        ??FMSTR_SetUpScope_2
     85                  }
     86          
     87          #if FMSTR_CFG_BUS_WIDTH > 1U
     88                  /* even sizes only */
     89                  if(sz & 0x1)
     90                  {
     91                      return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_INVSIZE);
     92                  }
     93          #endif
     94          
     95          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
     96                  if(!FMSTR_CheckTsaSpace(pcm_pScopeVarAddr[i], (FMSTR_SIZE8) sz, 0U))
     97                  {
     98                      return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_EACCESS);
     99                  }
    100          #endif
    101          
    102              }
   \                     ??FMSTR_SetUpScope_6: (+1)
   \   00000072   0x1C64             ADDS     R4,R4,#+1
   \   00000074   0xE7DE             B        ??FMSTR_SetUpScope_3
    103          
    104              /* activate scope */
    105              pcm_nScopeVarCount = nVarCnt;
   \                     ??FMSTR_SetUpScope_4: (+1)
   \   00000076   0x4668             MOV      R0,SP
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0x....             LDR      R1,??DataTable1
   \   0000007C   0x7008             STRB     R0,[R1, #+0]
    106          
    107              /* return just a status */
    108              return FMSTR_ConstToBuffer8(pResponse, FMSTR_STS_OK);
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x7028             STRB     R0,[R5, #+0]
   \   00000082   0x1C6D             ADDS     R5,R5,#+1
   \   00000084   0x0028             MOVS     R0,R5
   \                     ??FMSTR_SetUpScope_2: (+1)
   \   00000086   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    109          }
    110          
    111          /**************************************************************************//*!
    112          *
    113          * @brief    Handling READSCOPE command
    114          *
    115          * @param    pMessageIO - original command (in) and response buffer (out)
    116          *
    117          * @return   As all command handlers, the return value should be the buffer
    118          *           pointer where the response output finished (except checksum)
    119          *
    120          ******************************************************************************/
    121          

   \                                 In section .text, align 2, keep-with-next
    122          FMSTR_BPTR FMSTR_ReadScope(FMSTR_BPTR pMessageIO)
    123          {
   \                     FMSTR_ReadScope: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    124              FMSTR_U8 i;
    125          
    126              if(!pcm_nScopeVarCount)
   \   00000004   0x....             LDR      R0,??DataTable1
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD104             BNE      ??FMSTR_ReadScope_0
    127              {
    128                  return FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STC_NOTINIT);
   \   0000000C   0x2088             MOVS     R0,#+136
   \   0000000E   0x7020             STRB     R0,[R4, #+0]
   \   00000010   0x1C64             ADDS     R4,R4,#+1
   \   00000012   0x0020             MOVS     R0,R4
   \   00000014   0xE018             B        ??FMSTR_ReadScope_1
    129              }
    130          
    131              /* success */
    132              pMessageIO = FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STS_OK);
   \                     ??FMSTR_ReadScope_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x7020             STRB     R0,[R4, #+0]
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
    133          
    134              for (i=0U; i<pcm_nScopeVarCount; i++)
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0005             MOVS     R5,R0
   \                     ??FMSTR_ReadScope_2: (+1)
   \   00000020   0x....             LDR      R0,??DataTable1
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0xB2ED             UXTB     R5,R5
   \   00000026   0x4285             CMP      R5,R0
   \   00000028   0xD20D             BCS      ??FMSTR_ReadScope_3
    135              {
    136                  pMessageIO = FMSTR_CopyToBuffer(pMessageIO, pcm_pScopeVarAddr[i], pcm_pScopeVarSize[i]);
   \   0000002A   0x....             LDR      R0,??DataTable1_1
   \   0000002C   0xB2ED             UXTB     R5,R5
   \   0000002E   0x5D42             LDRB     R2,[R0, R5]
   \   00000030   0x....             LDR      R0,??DataTable1_2
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0x2104             MOVS     R1,#+4
   \   00000036   0x4369             MULS     R1,R5,R1
   \   00000038   0x5841             LDR      R1,[R0, R1]
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       FMSTR_CopyToBuffer
   \   00000040   0x0004             MOVS     R4,R0
    137              }
   \   00000042   0x1C6D             ADDS     R5,R5,#+1
   \   00000044   0xE7EC             B        ??FMSTR_ReadScope_2
    138          
    139              /* return end position */
    140              return pMessageIO;
   \                     ??FMSTR_ReadScope_3: (+1)
   \   00000046   0x0020             MOVS     R0,R4
   \                     ??FMSTR_ReadScope_1: (+1)
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    141          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     pcm_nScopeVarCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     pcm_pScopeVarSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     pcm_pScopeVarAddr
    142          
    143          #else  /* (FMSTR_USE_SCOPE) && !(FMSTR_DISABLE) */
    144          
    145          /*lint -efile(766, freemaster_protocol.h) include file is not used in this case */
    146          
    147          #endif /* (FMSTR_USE_SCOPE) && !(FMSTR_DISABLE) */
    148          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FMSTR_InitScope
      16   FMSTR_ReadScope
        16   -> FMSTR_CopyToBuffer
      24   FMSTR_SetUpScope
        24   -> FMSTR_AddressFromBuffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       2  FMSTR_InitScope
      74  FMSTR_ReadScope
     136  FMSTR_SetUpScope
       1  pcm_nScopeVarCount
      32  pcm_pScopeVarAddr
       8  pcm_pScopeVarSize

 
  41 bytes in section .bss
 224 bytes in section .text
 
 224 bytes of CODE memory
  41 bytes of DATA memory

Errors: none
Warnings: none
