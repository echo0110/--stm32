###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        29/Mar/2017  18:13:27
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\projects\i2c_test\i2c_test.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\projects\i2c_test\i2c_test.c -D
#        NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\Release\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\projects\i2c_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\toolchain\iar\
#        -On
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\Release\List\i2c_test.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\Release\Obj\i2c_test.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\projects\i2c_test\i2c_test.c
      1          /******************************************************************************
      2           * (c) Copyright 2010-2015, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ******************************************************************************
      5           * i2c_test.c
      6           ******************************************************************************/
      7          #include "drivers.h"
      8          #include "i2c/flash.h"
      9          #include "stdio.h"
     10          #include "i2c/24c16.h"
     11          
     12          #define BYTES (uint8)5                    /* number of bytes to read or write */
     13          /* Private define ------------------------------------------------------------*/
     14          #define TxBufferSize1   (countof(TxBuffer1) - 1)
     15          #define RxBufferSize1   (countof(TxBuffer1) - 1)
     16          
     17          /* Private macro -------------------------------------------------------------*/
     18          #define countof(a)   (sizeof(a) / sizeof(*(a)))
     19          static uint8 volatile ui8_data[BYTES];
     20          static uint8 i;

   \                                 In section .bss, align 4
     21          uint32 temp_read;
   \                     temp_read:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     22          uint8  temp_read1;
   \                     temp_read1:
   \   00000000                      DS8 1

   \                                 In section .data, align 4
     23          uint8  TXBuffer1[]="this is SPI TEST";
   \                     TXBuffer1:
   \   00000000   0x74 0x68          DC8 "this is SPI TEST"
   \              0x69 0x73    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x53 0x50    
   \              0x49 0x20    
   \              0x54 0x45    
   \              0x53 0x54    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     24          

   \                                 In section .rodata, align 2
     25          const uint8 TxBuffer1[]={"9"};//要写入到SPI FLASH的字符串数组
   \                     TxBuffer1:
   \   00000000   0x39 0x00          DC8 "9"
     26          static void spi0_ss_callback (SS_CONTROL ss_pin); /* SS pin callback          */
     27          
     28          
     29          
     30          /* data type definitions                                                      */

   \                                 In section .bss, align 1
     31          volatile char c;
   \                     c:
   \   00000000                      DS8 1
     32           

   \                                 In section .text, align 4, keep-with-next
     33          void main (void)
     34          {
   \                     main: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
     35            /*************************** INITIALIZING SECTION ***************************/
     36            /* initialize SIM module                                                    */
     37            SIM_Init  (SIM_MODULE_ALL_PERIPH_ON_CONFIG);
   \   00000004   0xA801             ADD      R0,SP,#+4
   \   00000006   0x4964             LDR      R1,??main_0
   \   00000008   0x2228             MOVS     R2,#+40
   \   0000000A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000000E   0x9801             LDR      R0,[SP, #+4]
   \   00000010   0x4962             LDR      R1,??main_0+0x4  ;; 0x4003e000
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0xA801             ADD      R0,SP,#+4
   \   00000016   0x4962             LDR      R1,??main_0+0x8
   \   00000018   0x2228             MOVS     R2,#+40
   \   0000001A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000001E   0x9802             LDR      R0,[SP, #+8]
   \   00000020   0x4960             LDR      R1,??main_0+0xC  ;; 0x4003e004
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0xA801             ADD      R0,SP,#+4
   \   00000026   0x4960             LDR      R1,??main_0+0x10
   \   00000028   0x2228             MOVS     R2,#+40
   \   0000002A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002E   0x9803             LDR      R0,[SP, #+12]
   \   00000030   0x495E             LDR      R1,??main_0+0x14  ;; 0x4003f004
   \   00000032   0x6008             STR      R0,[R1, #+0]
   \   00000034   0xA801             ADD      R0,SP,#+4
   \   00000036   0x495E             LDR      R1,??main_0+0x18
   \   00000038   0x2228             MOVS     R2,#+40
   \   0000003A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000003E   0x9804             LDR      R0,[SP, #+16]
   \   00000040   0x495C             LDR      R1,??main_0+0x1C  ;; 0x78000020
   \   00000042   0x4301             ORRS     R1,R1,R0
   \   00000044   0x485C             LDR      R0,??main_0+0x20  ;; 0x4003f034
   \   00000046   0x6001             STR      R1,[R0, #+0]
   \   00000048   0xA801             ADD      R0,SP,#+4
   \   0000004A   0x495C             LDR      R1,??main_0+0x24
   \   0000004C   0x2228             MOVS     R2,#+40
   \   0000004E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000052   0x9805             LDR      R0,[SP, #+20]
   \   00000054   0x495A             LDR      R1,??main_0+0x28  ;; 0x4003f038
   \   00000056   0x6008             STR      R0,[R1, #+0]
   \   00000058   0xA801             ADD      R0,SP,#+4
   \   0000005A   0x495A             LDR      R1,??main_0+0x2C
   \   0000005C   0x2228             MOVS     R2,#+40
   \   0000005E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000062   0x9806             LDR      R0,[SP, #+24]
   \   00000064   0x2180             MOVS     R1,#+128
   \   00000066   0x0609             LSLS     R1,R1,#+24       ;; #-2147483648
   \   00000068   0x4301             ORRS     R1,R1,R0
   \   0000006A   0x4857             LDR      R0,??main_0+0x30  ;; 0x4003f03c
   \   0000006C   0x6001             STR      R1,[R0, #+0]
   \   0000006E   0xA801             ADD      R0,SP,#+4
   \   00000070   0x4956             LDR      R1,??main_0+0x34
   \   00000072   0x2228             MOVS     R2,#+40
   \   00000074   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000078   0x9807             LDR      R0,[SP, #+28]
   \   0000007A   0x4955             LDR      R1,??main_0+0x38  ;; 0x4003f040
   \   0000007C   0x6008             STR      R0,[R1, #+0]
   \   0000007E   0xA801             ADD      R0,SP,#+4
   \   00000080   0x4954             LDR      R1,??main_0+0x3C
   \   00000082   0x2228             MOVS     R2,#+40
   \   00000084   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000088   0x9808             LDR      R0,[SP, #+32]
   \   0000008A   0x4953             LDR      R1,??main_0+0x40  ;; 0x4003f044
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   \   0000008E   0xA801             ADD      R0,SP,#+4
   \   00000090   0x4952             LDR      R1,??main_0+0x44
   \   00000092   0x2228             MOVS     R2,#+40
   \   00000094   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000098   0x9809             LDR      R0,[SP, #+36]
   \   0000009A   0x4951             LDR      R1,??main_0+0x48  ;; 0x4003f04c
   \   0000009C   0x6008             STR      R0,[R1, #+0]
   \   0000009E   0xA801             ADD      R0,SP,#+4
   \   000000A0   0x4950             LDR      R1,??main_0+0x4C
   \   000000A2   0x2228             MOVS     R2,#+40
   \   000000A4   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000A8   0x980A             LDR      R0,[SP, #+40]
   \   000000AA   0x494F             LDR      R1,??main_0+0x50  ;; 0x4003f06c
   \   000000AC   0x6008             STR      R0,[R1, #+0]
     38          // /* route core clock to PTF7                                                 */
     39          //  SIM_SelClkout (CLKOUT_SRC2);
     40          //  PORT_Init (PORTF,PORT_MODULE_ALT3_MODE,PIN7);
     41          //  /* clock mode 2:1:1, 48MHz                                                  */
     42            SIM_SetClkMode (SYSCLK_MODE1);
   \   000000AE   0x2080             MOVS     R0,#+128
   \   000000B0   0x0500             LSLS     R0,R0,#+20       ;; #+134217728
   \   000000B2   0x494E             LDR      R1,??main_0+0x54  ;; 0x5d83f044
   \   000000B4   0x6008             STR      R0,[R1, #+0]
     43            SIM_SetClkDiv  (SYSCLK_DIV1);
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0x494D             LDR      R1,??main_0+0x58  ;; 0x5e1bf044
   \   000000BA   0x6008             STR      R0,[R1, #+0]
     44            SIM_EnableModule(PORTF);
   \   000000BC   0x484D             LDR      R0,??main_0+0x5C
   \   000000BE   0xC803             LDM      R0,{R0,R1}
   \   000000C0   0x0002             MOVS     R2,R0
   \   000000C2   0x000B             MOVS     R3,R1
   \   000000C4   0x0018             MOVS     R0,R3
   \   000000C6   0x0011             MOVS     R1,R2
   \   000000C8   0x2280             MOVS     R2,#+128
   \   000000CA   0x0512             LSLS     R2,R2,#+20       ;; #+134217728
   \   000000CC   0x430A             ORRS     R2,R2,R1
   \   000000CE   0x6010             STR      R0,[R2, #+0]
     45            FLL_Init(FLL_MODULE_FEE_48MHZ_CONFIG);
   \   000000D0   0x4849             LDR      R0,??main_0+0x60
   \   000000D2   0xC803             LDM      R0,{R0,R1}
   \   000000D4   0x.... 0x....      BL       FLL_Init
     46             
     47            /* PORTs initialize, PTD7_SCL, PTE0_SDA                                     */
     48            // PORT_Init (PORTF, PORT_MODULE_ALT3_MODE, PIN6|PIN5);
     49           // PORT_Init (PORTF, PORT_MODULE_ALT3_MODE, PIN5);
     50             PORT_Init (PORTF, PORT_MODULE_LED_MODE, PIN6|PIN5);//配置SCL   SDA为输出
   \   000000D8   0x2260             MOVS     R2,#+96
   \   000000DA   0x4848             LDR      R0,??main_0+0x64
   \   000000DC   0xC803             LDM      R0,{R0,R1}
   \   000000DE   0x.... 0x....      BL       PORTF_Init
     51             GPIO_Init (GPIOF, GPIO_OUT_LOGIC0_MODE, PIN6|PIN5);//配置SCL   SDA为输出
   \   000000E2   0x4847             LDR      R0,??main_0+0x68
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0x9000             STR      R0,[SP, #+0]
   \   000000E8   0x4846             LDR      R0,??main_0+0x6C  ;; 0x400ff041
   \   000000EA   0x7800             LDRB     R0,[R0, #+0]
   \   000000EC   0x219F             MOVS     R1,#+159
   \   000000EE   0x4001             ANDS     R1,R1,R0
   \   000000F0   0x4668             MOV      R0,SP
   \   000000F2   0x7840             LDRB     R0,[R0, #+1]
   \   000000F4   0x2260             MOVS     R2,#+96
   \   000000F6   0x4002             ANDS     R2,R2,R0
   \   000000F8   0x430A             ORRS     R2,R2,R1
   \   000000FA   0x4842             LDR      R0,??main_0+0x6C  ;; 0x400ff041
   \   000000FC   0x7002             STRB     R2,[R0, #+0]
   \   000000FE   0x4842             LDR      R0,??main_0+0x70
   \   00000100   0x6800             LDR      R0,[R0, #+0]
   \   00000102   0x9000             STR      R0,[SP, #+0]
   \   00000104   0x4841             LDR      R0,??main_0+0x74  ;; 0x400ff055
   \   00000106   0x7800             LDRB     R0,[R0, #+0]
   \   00000108   0x219F             MOVS     R1,#+159
   \   0000010A   0x4001             ANDS     R1,R1,R0
   \   0000010C   0x4668             MOV      R0,SP
   \   0000010E   0x7800             LDRB     R0,[R0, #+0]
   \   00000110   0x2260             MOVS     R2,#+96
   \   00000112   0x4002             ANDS     R2,R2,R0
   \   00000114   0x430A             ORRS     R2,R2,R1
   \   00000116   0x483D             LDR      R0,??main_0+0x74  ;; 0x400ff055
   \   00000118   0x7002             STRB     R2,[R0, #+0]
     52          
     53              /* I2C module initialization (100 kBps @24MHz)                              */
     54              I2C_Init(I2C1, I2C_MODULE_IRQ_DI_CONFIG(0x1f));
   \   0000011A   0x483D             LDR      R0,??main_0+0x78
   \   0000011C   0xC807             LDM      R0,{R0-R2}
   \   0000011E   0x.... 0x....      BL       I2C1_Init
     55               SCK_1;
   \   00000122   0x4838             LDR      R0,??main_0+0x6C  ;; 0x400ff041
   \   00000124   0x7800             LDRB     R0,[R0, #+0]
   \   00000126   0x2120             MOVS     R1,#+32
   \   00000128   0x4301             ORRS     R1,R1,R0
   \   0000012A   0x4836             LDR      R0,??main_0+0x6C  ;; 0x400ff041
   \   0000012C   0x7001             STRB     R1,[R0, #+0]
     56               SDA_1;
   \   0000012E   0x4835             LDR      R0,??main_0+0x6C  ;; 0x400ff041
   \   00000130   0x7800             LDRB     R0,[R0, #+0]
   \   00000132   0x2140             MOVS     R1,#+64
   \   00000134   0x4301             ORRS     R1,R1,R0
   \   00000136   0x4833             LDR      R0,??main_0+0x6C  ;; 0x400ff041
   \   00000138   0x7001             STRB     R1,[R0, #+0]
     57            
     58              /* UART0 init 9600bd                                                        */
     59              PORT_Init (PORTF, PORT_MODULE_ALT4_MODE, PIN3|PIN4);
   \   0000013A   0x2218             MOVS     R2,#+24
   \   0000013C   0x4835             LDR      R0,??main_0+0x7C
   \   0000013E   0xC803             LDM      R0,{R0,R1}
   \   00000140   0x.... 0x....      BL       PORTF_Init
     60              UART_Init (UART0, UART_MODULE_POLLMODE_CONFIG(9600,24e6));
   \   00000144   0x4834             LDR      R0,??main_0+0x80
   \   00000146   0xC807             LDM      R0,{R0-R2}
   \   00000148   0x.... 0x....      BL       UART0_Init
     61              
     62              
     63               //  PTD4初始化用于拉高485 
     64              PORT_Init (PORTD, PORT_MODULE_LED_MODE, PIN4);
   \   0000014C   0x2210             MOVS     R2,#+16
   \   0000014E   0x4833             LDR      R0,??main_0+0x84
   \   00000150   0xC803             LDM      R0,{R0,R1}
   \   00000152   0x.... 0x....      BL       PORTD_Init
     65              GPIO_Init (GPIOD, GPIO_OUT_LOGIC0_MODE, PIN4);
   \   00000156   0x4832             LDR      R0,??main_0+0x88
   \   00000158   0x6800             LDR      R0,[R0, #+0]
   \   0000015A   0x9000             STR      R0,[SP, #+0]
   \   0000015C   0x4831             LDR      R0,??main_0+0x8C  ;; 0x400ff003
   \   0000015E   0x7800             LDRB     R0,[R0, #+0]
   \   00000160   0x21EF             MOVS     R1,#+239
   \   00000162   0x4001             ANDS     R1,R1,R0
   \   00000164   0x4668             MOV      R0,SP
   \   00000166   0x7840             LDRB     R0,[R0, #+1]
   \   00000168   0x2210             MOVS     R2,#+16
   \   0000016A   0x4010             ANDS     R0,R0,R2
   \   0000016C   0x4308             ORRS     R0,R0,R1
   \   0000016E   0x492D             LDR      R1,??main_0+0x8C  ;; 0x400ff003
   \   00000170   0x7008             STRB     R0,[R1, #+0]
   \   00000172   0x482D             LDR      R0,??main_0+0x90
   \   00000174   0x6800             LDR      R0,[R0, #+0]
   \   00000176   0x9000             STR      R0,[SP, #+0]
   \   00000178   0x482C             LDR      R0,??main_0+0x94  ;; 0x400ff017
   \   0000017A   0x7800             LDRB     R0,[R0, #+0]
   \   0000017C   0x21EF             MOVS     R1,#+239
   \   0000017E   0x4001             ANDS     R1,R1,R0
   \   00000180   0x4668             MOV      R0,SP
   \   00000182   0x7800             LDRB     R0,[R0, #+0]
   \   00000184   0x2210             MOVS     R2,#+16
   \   00000186   0x4010             ANDS     R0,R0,R2
   \   00000188   0x4308             ORRS     R0,R0,R1
   \   0000018A   0x4928             LDR      R1,??main_0+0x94  ;; 0x400ff017
   \   0000018C   0x7008             STRB     R0,[R1, #+0]
     66            /* SPI0 initialization                                                      */
     67           //   PORT_Init (PORTG, PORT_MODULE_ALT2_MODE, SPI0_MOSI | SPI0_MISO | SPI0_SCK );
     68           //   SPI_Init (SPI0, SPI_MODULE_DIV12_8B_POLL_CONFIG,spi0_ss_callback,PRI_LVL0,NULL);
     69                /* 将测试用的数组写到缓存区里 */
     70          //   for(i=0; i<TxBufferSize1;i++) SST25_buffer[i]=TxBuffer1[i]; 
     71           while(1)
     72           {
     73             /************flash  test programm***********/
     74           /*   uint8 a=0;
     75              SST25_ReadID();
     76             // SST25_write(0x00,2);//向地址0写入1数据 
     77              SST25_W_BLOCK(0, SST25_buffer,4096);	  
     78              arch_delay(50000);//1ms
     79               //temp_read=SST25_read(0);
     80             SST25_R_BLOCK(0, SST25_buffer,4096);*/
     81             
     82             /************i2c  test programm***********/
     83             //  StartI2C();
     84              //Check();
     85           //     write_add(0,0x88);
     86              //  arch_delay(50000);//1ms
     87             //  temp_read1=read_add(0);
     88           // SCK_1;
     89           // arch_delay(250000);//150--5us  25--1us  60-2us
     90           // SCK_0;
     91           // arch_delay(250000);
     92            //  arch_delay(250);
     93             
     94               
     95             //  spi_buff[1]=(uint8)SST25_read(1);
     96             // spi_buffer[0]=SST25_ReadID();
     97              //  arch_delay(50000);//1ms  
     98                 //spi_buffer[0]=SST25_read(0); 
     99           //UART_PutChar(UART0,temp_id);
    100            // NOP;  system clock --50Mhz  1000000--0.0002s
    101             //  arch_delay(2000000);//1s
    102           //  GPIO_Set(GPIOD,PIN4);
    103           UART_PutChar(UART0,'b');
   \                     ??main_1: (+1)
   \   0000018E   0x2062             MOVS     R0,#+98
   \   00000190   0x4927             LDR      R1,??main_0+0x98  ;; 0x4006a007
   \   00000192   0x7008             STRB     R0,[R1, #+0]
   \   00000194   0xE7FB             B        ??main_1
   \   00000196   0xBF00             Nop      
   \                     ??main_0:
   \   00000198   0x........         DC32     ?_0
   \   0000019C   0x4003E000         DC32     0x4003e000
   \   000001A0   0x........         DC32     ?_1
   \   000001A4   0x4003E004         DC32     0x4003e004
   \   000001A8   0x........         DC32     ?_2
   \   000001AC   0x4003F004         DC32     0x4003f004
   \   000001B0   0x........         DC32     ?_3
   \   000001B4   0x78000020         DC32     0x78000020
   \   000001B8   0x4003F034         DC32     0x4003f034
   \   000001BC   0x........         DC32     ?_4
   \   000001C0   0x4003F038         DC32     0x4003f038
   \   000001C4   0x........         DC32     ?_5
   \   000001C8   0x4003F03C         DC32     0x4003f03c
   \   000001CC   0x........         DC32     ?_6
   \   000001D0   0x4003F040         DC32     0x4003f040
   \   000001D4   0x........         DC32     ?_7
   \   000001D8   0x4003F044         DC32     0x4003f044
   \   000001DC   0x........         DC32     ?_8
   \   000001E0   0x4003F04C         DC32     0x4003f04c
   \   000001E4   0x........         DC32     ?_9
   \   000001E8   0x4003F06C         DC32     0x4003f06c
   \   000001EC   0x5D83F044         DC32     0x5d83f044
   \   000001F0   0x5E1BF044         DC32     0x5e1bf044
   \   000001F4   0x........         DC32     ?_20
   \   000001F8   0x........         DC32     ?_10
   \   000001FC   0x........         DC32     ?_11
   \   00000200   0x........         DC32     ?_12
   \   00000204   0x400FF041         DC32     0x400ff041
   \   00000208   0x........         DC32     ?_13
   \   0000020C   0x400FF055         DC32     0x400ff055
   \   00000210   0x........         DC32     ?_14
   \   00000214   0x........         DC32     ?_15
   \   00000218   0x........         DC32     ?_16
   \   0000021C   0x........         DC32     ?_17
   \   00000220   0x........         DC32     ?_18
   \   00000224   0x400FF003         DC32     0x400ff003
   \   00000228   0x........         DC32     ?_19
   \   0000022C   0x400FF017         DC32     0x400ff017
   \   00000230   0x4006A007         DC32     0x4006a007
    104            //GPIO_Set (FGPIOF, PIN3);
    105              
    106              
    107           //   while (!UART_RxFull(UART0));
    108           //       c=UART_GetChar(UART0);
    109          
    110             //GPIO_Clr (FGPIOF, PIN3);
    111            //c = UART_GetChar (UART0);
    112           //printf("c=%d\n",c);
    113           // printf("b\n");
    114           }
    115            
    116            
    117            
    118            
    119            
    120            
    121          } 

   \                                 In section .rodata, align 4
   \                     ?_20:
   \   00000000   0x4003F038         DC32 4003F038H, 2048
   \              0x00000800   

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x00000000         DC32 0, 0, 1, 7126482, 128679880, 1343318559, 3, 134217728, 0, 0
   \              0x00000000   
   \              0x00000001   
   \              0x006CBDD2   
   \              0x07AB7FC8   
   \              0x50116A1F   
   \              0x00000003   
   \              0x08000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x00000000         DC32 0, 0, 1, 7126482, 128679880, 1343318559, 3, 134217728, 0, 0
   \              0x00000000   
   \              0x00000001   
   \              0x006CBDD2   
   \              0x07AB7FC8   
   \              0x50116A1F   
   \              0x00000003   
   \              0x08000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x00000000         DC32 0, 0, 1, 7126482, 128679880, 1343318559, 3, 134217728, 0, 0
   \              0x00000000   
   \              0x00000001   
   \              0x006CBDD2   
   \              0x07AB7FC8   
   \              0x50116A1F   
   \              0x00000003   
   \              0x08000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x00000000         DC32 0, 0, 1, 7126482, 128679880, 1343318559, 3, 134217728, 0, 0
   \              0x00000000   
   \              0x00000001   
   \              0x006CBDD2   
   \              0x07AB7FC8   
   \              0x50116A1F   
   \              0x00000003   
   \              0x08000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x00000000         DC32 0, 0, 1, 7126482, 128679880, 1343318559, 3, 134217728, 0, 0
   \              0x00000000   
   \              0x00000001   
   \              0x006CBDD2   
   \              0x07AB7FC8   
   \              0x50116A1F   
   \              0x00000003   
   \              0x08000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x00000000         DC32 0, 0, 1, 7126482, 128679880, 1343318559, 3, 134217728, 0, 0
   \              0x00000000   
   \              0x00000001   
   \              0x006CBDD2   
   \              0x07AB7FC8   
   \              0x50116A1F   
   \              0x00000003   
   \              0x08000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x00000000         DC32 0, 0, 1, 7126482, 128679880, 1343318559, 3, 134217728, 0, 0
   \              0x00000000   
   \              0x00000001   
   \              0x006CBDD2   
   \              0x07AB7FC8   
   \              0x50116A1F   
   \              0x00000003   
   \              0x08000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x00000000         DC32 0, 0, 1, 7126482, 128679880, 1343318559, 3, 134217728, 0, 0
   \              0x00000000   
   \              0x00000001   
   \              0x006CBDD2   
   \              0x07AB7FC8   
   \              0x50116A1F   
   \              0x00000003   
   \              0x08000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x00000000         DC32 0, 0, 1, 7126482, 128679880, 1343318559, 3, 134217728, 0, 0
   \              0x00000000   
   \              0x00000001   
   \              0x006CBDD2   
   \              0x07AB7FC8   
   \              0x50116A1F   
   \              0x00000003   
   \              0x08000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x00000000         DC32 0, 0, 1, 7126482, 128679880, 1343318559, 3, 134217728, 0, 0
   \              0x00000000   
   \              0x00000001   
   \              0x006CBDD2   
   \              0x07AB7FC8   
   \              0x50116A1F   
   \              0x00000003   
   \              0x08000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x00 0x80          DC8 0, 128, 160, 8, 2, 1, 128, 0
   \              0xA0 0x08    
   \              0x02 0x01    
   \              0x80 0x00    

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x00000104         DC32 260, 0
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0xFF 0x00          DC8 255, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0xFF 0x00          DC8 255, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x00 0x1F          DC8 0, 31, 128, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x80 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_15:
   \   00000000   0x00000400         DC32 1024, 0
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_16:
   \   00000000   0x00 0x9C          DC8 0, 156, 0, 12, 0, 0, 0, 0, 8, 0, 0, 0
   \              0x00 0x0C    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x08 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_17:
   \   00000000   0x00000104         DC32 260, 0
   \              0x00000000   

   \                                 In section .rodata, align 4
   \                     ?_18:
   \   00000000   0xFF 0x00          DC8 255, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 4
   \                     ?_19:
   \   00000000   0xFF 0x00          DC8 255, 0, 0, 0
   \              0x00 0x00    
    122            
    123          /* callback function implementation for manual driving of slave select pin    */
    124          static void spi0_ss_callback (SS_CONTROL ss_pin)
    125          {
    126            if      (ss_pin == SS_SET  ) { GPIO_Set (GPIOG,SPI0_SS); }
    127            else if (ss_pin == SS_CLEAR) { GPIO_Clr (GPIOG,SPI0_SS); }
    128            else if (ss_pin == SS_INIT )
    129            {
    130              PORT_Init (PORTG, PORT_MODULE_LED_MODE, SPI0_SS);
    131              GPIO_Init (GPIOG, GPIO_OUT_LOGIC0_MODE, SPI0_SS);
    132              GPIO_Set  (GPIOG, SPI0_SS);
    133            }
    134          }  
    135            
    136            
    137            
    138            
    139            
    140            
    141            
    142            
    143            
    144            
    145            
    146            
    147            /****************************** WRITING SECTION *****************************/
    148          //  I2C_SetTxMode(I2C0);                 /* Set TX mode                         */
    149          //  I2C_StartSignal(I2C0);               /* Generate START on I2C bus           */
    150          //
    151          //  I2CWRITE(0xA0);                      /* 0xA0= device (EEPROM) select byte   */
    152          //  I2CWRITE(0x00);                      /* 0x00= device starting address       */
    153          //
    154          //  for (i=0; i<BYTES; i++)              /* Writing i-bytes to the memory       */
    155          //    I2CWRITE(2*i);                     /* Writing byte = address * 2          */
    156          //
    157          //  I2C_StopSignal(I2C0);                /* Generate STOP signal on I2C bus     */
    158          //  arch_delay(1000000);                 /* Bus recovering between write/read   */
    159          //
    160          //  /****************************** READING SECTION *****************************/
    161          //  I2C_SetTxMode(I2C0);                 /* Set TX mode                         */
    162          //  I2C_StartSignal(I2C0);               /* Generate START on I2C bus           */
    163          //
    164          //  I2CWRITE(0xA0);                      /* 0xA0= device (EEPROM) select byte   */
    165          //  I2CWRITE(0x00);                      /* 0x00= device starting address       */
    166          //
    167          //  I2C_RepeatStartSignal(I2C0);         /* Generate Repeat START on I2C bus    */
    168          //  while(!(I2C_GetTcFlag(I2C0)));       /* Waiting for bus releasing           */
    169          //
    170          //  I2CWRITE(0xA1);                      /* 0xA1= activate device reading mode  */
    171          //
    172          //  I2C_SetRxMode(I2C0);                 /* Set to RX Mode                      */
    173          //  (void) I2C_RdData(I2C0);             /* Dummy reading                       */
    174          //
    175          //  for (i=0; i<BYTES; i++)              /* Reading i-bytes from the memory     */
    176          //  {
    177          //    if (i == (BYTES-1))                /* Last byte?                          */
    178          //    {
    179          //      I2C_SetNackMode(I2C0);           /* No acknowledge is needed now        */
    180          //      while(I2C_GetIsrFlag(I2C0) == 0);
    181          //      I2C_StopSignal(I2C0);            /* Generate STOP signal on I2C bus     */
    182          //      ui8_data[i] = I2C_RdData(I2C0);  /* Reading the last byte               */
    183          //      I2C_ClrIsrFlag(I2C0);
    184          //      I2C_ClrNackMode(I2C0);           /* next acknowledge is allowed         */
    185          //    }
    186          //    else
    187          //    {
    188          //      I2CREAD(ui8_data[i]);            /* Reading the i-th byte               */
    189          //    }
    190          //  }
    191          
    192            /* main loop - check the results                                            */
    193            //while(1);
    194          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   main
        48   -> FLL_Init
        48   -> I2C1_Init
        48   -> PORTD_Init
        48   -> PORTF_Init
        48   -> UART0_Init
        48   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      40  ?_0
      40  ?_1
       8  ?_10
       8  ?_11
       4  ?_12
       4  ?_13
      12  ?_14
       8  ?_15
      12  ?_16
       8  ?_17
       4  ?_18
       4  ?_19
      40  ?_2
       8  ?_20
      40  ?_3
      40  ?_4
      40  ?_5
      40  ?_6
      40  ?_7
      40  ?_8
      40  ?_9
      20  TXBuffer1
       2  TxBuffer1
       1  c
     564  main
       4  temp_read
       1  temp_read1

 
   6 bytes in section .bss
  20 bytes in section .data
 482 bytes in section .rodata
 564 bytes in section .text
 
 564 bytes of CODE  memory
 482 bytes of CONST memory
  26 bytes of DATA  memory

Errors: none
Warnings: 2
