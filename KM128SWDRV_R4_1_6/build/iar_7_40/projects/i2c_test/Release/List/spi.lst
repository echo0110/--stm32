###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        20/Mar/2017  09:48:02
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\spi\spi.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\spi\spi.c -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\Release\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\projects\i2c_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\..\..\..\..\src\toolchain\iar\
#        -On
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\Release\List\spi.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\i2c_test\Release\Obj\spi.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\spi\spi.c
      1          /******************************************************************************
      2           * (c) Copyright 2010-2015, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ***************************************************************************//*!
      5           * @file      spi.c
      6           * @version   1.0.7.0
      7           * @date      Apr-20-2015
      8           * @brief     Serial Peripheral Interface (SPI) driver source code.
      9          ******************************************************************************/
     10          #include "common.h"
     11          #include "spi.h"
     12          
     13          #if !defined(MCU_MKM34ZA5)
     14            #error "The spi.c module is specific to the MKMxxZxxACxx5 microcontrollers."
     15          #endif
     16          
     17          /******************************************************************************
     18           * data type definitions                                                      *
     19           ******************************************************************************/

   \                                 In section .bss, align 4
     20          static SPI_CALLBACK     pCallbackSPI0, pCallbackSPI1;
   \                     pCallbackSPI0:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     pCallbackSPI1:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     21          static SPI_SSCALLBACK   pCallbackSS0, pCallbackSS1;
   \                     pCallbackSS0:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     pCallbackSS1:
   \   00000000                      DS8 4
     22          
     23          /******************************************************************************
     24           * public function definitions                                                *
     25           ******************************************************************************/
     26          #if defined(__ICCARM__)
     27            #pragma diag_suppress=Pa082
     28          #endif

   \                                 In section .text, align 2, keep-with-next
     29          void SPI0_Init (tSPI spi,SPI_SSCALLBACK pC2,uint8 ip,SPI_CALLBACK pC1)
     30          {
   \                     SPI0_Init: (+1)
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x0014             MOVS     R4,R2
   \   00000004   0x001D             MOVS     R5,R3
   \   00000006   0x9E06             LDR      R6,[SP, #+24]
     31            /* main callback function initialization                                    */
     32            if (pC1) { pCallbackSPI0 = pC1; NVIC_SetIsr(INT_SPI0,ip); }
   \   00000008   0x0030             MOVS     R0,R6
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD014             BEQ      ??SPI0_Init_0
   \   0000000E   0x....             LDR      R0,??DataTable6
   \   00000010   0x6006             STR      R6,[R0, #+0]
   \   00000012   0x....             LDR      R0,??DataTable6_1  ;; 0xe000e280
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2110             MOVS     R1,#+16
   \   00000018   0x4301             ORRS     R1,R1,R0
   \   0000001A   0x....             LDR      R0,??DataTable6_1  ;; 0xe000e280
   \   0000001C   0x6001             STR      R1,[R0, #+0]
   \   0000001E   0x....             LDR      R0,??DataTable6_2  ;; 0xe000e100
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2110             MOVS     R1,#+16
   \   00000024   0x4301             ORRS     R1,R1,R0
   \   00000026   0x....             LDR      R0,??DataTable6_2  ;; 0xe000e100
   \   00000028   0x6001             STR      R1,[R0, #+0]
   \   0000002A   0x....             LDR      R0,??DataTable7  ;; 0xe000e404
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xB2ED             UXTB     R5,R5
   \   00000030   0x01A9             LSLS     R1,R5,#+6
   \   00000032   0x4301             ORRS     R1,R1,R0
   \   00000034   0x....             LDR      R0,??DataTable7  ;; 0xe000e404
   \   00000036   0x6001             STR      R1,[R0, #+0]
     33          
     34            /* initialization of SS callback function where SS will be driven manually  */
     35            if (pC2) { pCallbackSS0 = pC2; pCallbackSS0 (SS_INIT);  }
   \                     ??SPI0_Init_0: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD005             BEQ      ??SPI0_Init_1
   \   0000003E   0x....             LDR      R0,??DataTable7_1
   \   00000040   0x6004             STR      R4,[R0, #+0]
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x....             LDR      R1,??DataTable7_1
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0x4788             BLX      R1
     36          
     37            /* SPI configuration (without C3 register)                                  */
     38            SPI0_C1  = spi.C1;              /* SPI control register 1                   */
   \                     ??SPI0_Init_1: (+1)
   \   0000004A   0x4668             MOV      R0,SP
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x....             LDR      R1,??DataTable8  ;; 0x40075003
   \   00000050   0x7008             STRB     R0,[R1, #+0]
     39            SPI0_C2  = spi.C2;              /* SPI control register 2                   */
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x7840             LDRB     R0,[R0, #+1]
   \   00000056   0x....             LDR      R1,??DataTable7_2  ;; 0x40075002
   \   00000058   0x7008             STRB     R0,[R1, #+0]
     40            SPI0_BR  = spi.BR;              /* SPI baud rate register                   */
   \   0000005A   0x4668             MOV      R0,SP
   \   0000005C   0x78C0             LDRB     R0,[R0, #+3]
   \   0000005E   0x....             LDR      R1,??DataTable7_3  ;; 0x40075001
   \   00000060   0x7008             STRB     R0,[R1, #+0]
     41            SPI0_ML  = spi.ML;              /* SPI match register low                   */
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x7900             LDRB     R0,[R0, #+4]
   \   00000066   0x....             LDR      R1,??DataTable7_4  ;; 0x40075004
   \   00000068   0x7008             STRB     R0,[R1, #+0]
     42            SPI0_MH  = spi.MH;              /* SPI match register high                  */
   \   0000006A   0x4668             MOV      R0,SP
   \   0000006C   0x7940             LDRB     R0,[R0, #+5]
   \   0000006E   0x....             LDR      R1,??DataTable7_5  ;; 0x40075005
   \   00000070   0x7008             STRB     R0,[R1, #+0]
     43            SPI0_C1 |= SPI_C1_SPE_MASK;     /* Enable SPI                               */
   \   00000072   0x....             LDR      R0,??DataTable8  ;; 0x40075003
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0x2140             MOVS     R1,#+64
   \   00000078   0x4301             ORRS     R1,R1,R0
   \   0000007A   0x....             LDR      R0,??DataTable8  ;; 0x40075003
   \   0000007C   0x7001             STRB     R1,[R0, #+0]
     44            /* Note: FIFO functionality is not supported in SPI0 module                 */
     45          }
   \   0000007E   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
     46          

   \                                 In section .text, align 2, keep-with-next
     47          void SPI1_Init (tSPI spi,SPI_SSCALLBACK pC2,uint8 ip, SPI_CALLBACK pC1)
     48          {
   \                     SPI1_Init: (+1)
   \   00000000   0xB573             PUSH     {R0,R1,R4-R6,LR}
   \   00000002   0x0014             MOVS     R4,R2
   \   00000004   0x001D             MOVS     R5,R3
   \   00000006   0x9E06             LDR      R6,[SP, #+24]
     49            /* main callback function initialization                                    */
     50            if (pC1) { pCallbackSPI1 = pC1; NVIC_SetIsr(INT_SPI1,ip); }
   \   00000008   0x0030             MOVS     R0,R6
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD014             BEQ      ??SPI1_Init_0
   \   0000000E   0x....             LDR      R0,??DataTable8_1
   \   00000010   0x6006             STR      R6,[R0, #+0]
   \   00000012   0x....             LDR      R0,??DataTable6_1  ;; 0xe000e280
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2120             MOVS     R1,#+32
   \   00000018   0x4301             ORRS     R1,R1,R0
   \   0000001A   0x....             LDR      R0,??DataTable6_1  ;; 0xe000e280
   \   0000001C   0x6001             STR      R1,[R0, #+0]
   \   0000001E   0x....             LDR      R0,??DataTable6_2  ;; 0xe000e100
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0x2120             MOVS     R1,#+32
   \   00000024   0x4301             ORRS     R1,R1,R0
   \   00000026   0x....             LDR      R0,??DataTable6_2  ;; 0xe000e100
   \   00000028   0x6001             STR      R1,[R0, #+0]
   \   0000002A   0x....             LDR      R0,??DataTable7  ;; 0xe000e404
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0xB2ED             UXTB     R5,R5
   \   00000030   0x03A9             LSLS     R1,R5,#+14
   \   00000032   0x4301             ORRS     R1,R1,R0
   \   00000034   0x....             LDR      R0,??DataTable7  ;; 0xe000e404
   \   00000036   0x6001             STR      R1,[R0, #+0]
     51          
     52            /* initialization of SS callback function where SS will be driven manually  */
     53            if (pC2) { pCallbackSS1 = pC2; pCallbackSS1 (SS_INIT); }
   \                     ??SPI1_Init_0: (+1)
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD005             BEQ      ??SPI1_Init_1
   \   0000003E   0x....             LDR      R0,??DataTable8_2
   \   00000040   0x6004             STR      R4,[R0, #+0]
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x....             LDR      R1,??DataTable8_2
   \   00000046   0x6809             LDR      R1,[R1, #+0]
   \   00000048   0x4788             BLX      R1
     54          
     55            /* SPI configuration (with C3 register)                                     */
     56            SPI1_C1  = spi.C1;              /* SPI control register 1                   */
   \                     ??SPI1_Init_1: (+1)
   \   0000004A   0x4668             MOV      R0,SP
   \   0000004C   0x7800             LDRB     R0,[R0, #+0]
   \   0000004E   0x....             LDR      R1,??DataTable10  ;; 0x40076003
   \   00000050   0x7008             STRB     R0,[R1, #+0]
     57            SPI1_C2  = spi.C2;              /* SPI control register 2                   */
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x7840             LDRB     R0,[R0, #+1]
   \   00000056   0x....             LDR      R1,??DataTable9  ;; 0x40076002
   \   00000058   0x7008             STRB     R0,[R1, #+0]
     58            SPI1_C3  = spi.C3;              /* SPI control register 3                   */
   \   0000005A   0x4668             MOV      R0,SP
   \   0000005C   0x7880             LDRB     R0,[R0, #+2]
   \   0000005E   0x....             LDR      R1,??DataTable9_1  ;; 0x4007600b
   \   00000060   0x7008             STRB     R0,[R1, #+0]
     59            SPI1_BR  = spi.BR;              /* SPI baud rate register                   */
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x78C0             LDRB     R0,[R0, #+3]
   \   00000066   0x....             LDR      R1,??DataTable9_2  ;; 0x40076001
   \   00000068   0x7008             STRB     R0,[R1, #+0]
     60            SPI1_ML  = spi.ML;              /* SPI match register low                   */
   \   0000006A   0x4668             MOV      R0,SP
   \   0000006C   0x7900             LDRB     R0,[R0, #+4]
   \   0000006E   0x....             LDR      R1,??DataTable9_3  ;; 0x40076004
   \   00000070   0x7008             STRB     R0,[R1, #+0]
     61            SPI1_MH  = spi.MH;              /* SPI match register high                  */
   \   00000072   0x4668             MOV      R0,SP
   \   00000074   0x7940             LDRB     R0,[R0, #+5]
   \   00000076   0x....             LDR      R1,??DataTable9_4  ;; 0x40076005
   \   00000078   0x7008             STRB     R0,[R1, #+0]
     62            SPI1_C1 |= SPI_C1_SPE_MASK;     /* Enable SPI                               */
   \   0000007A   0x....             LDR      R0,??DataTable10  ;; 0x40076003
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0x2140             MOVS     R1,#+64
   \   00000080   0x4301             ORRS     R1,R1,R0
   \   00000082   0x....             LDR      R0,??DataTable10  ;; 0x40076003
   \   00000084   0x7001             STRB     R1,[R0, #+0]
     63          }
   \   00000086   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
     64          
     65          /******************************************************************************
     66           * Simple SPI Tx/Rx function (1 word Tx + 1 word Rx)                          *
     67           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     68          uint16 SPI0_TxRxWord(uint16 txdata)
     69          {
   \                     SPI0_TxRxWord: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
     70            while (!SPI_TxCmpl(SPI0));      /* wait until Tx buffer is empty            */
   \                     ??SPI0_TxRxWord_0: (+1)
   \   00000004   0x....             LDR      R0,??DataTable10_1  ;; 0x40075000
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x0680             LSLS     R0,R0,#+26
   \   0000000A   0xD5FB             BPL      ??SPI0_TxRxWord_0
     71            SPI_PutWord(SPI0,txdata);       /* write a 16-bit data                      */
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0x0002             MOVS     R2,R0
   \   00000010   0x....             LDR      R3,??DataTable10_2  ;; 0x40075006
   \   00000012   0x701A             STRB     R2,[R3, #+0]
   \   00000014   0xB280             UXTH     R0,R0
   \   00000016   0x0A00             LSRS     R0,R0,#+8
   \   00000018   0x....             LDR      R2,??DataTable11  ;; 0x40075007
   \   0000001A   0x7010             STRB     R0,[R2, #+0]
     72            while(!SPI_RxFull(SPI0));       /* wait until Rx buffer is full             */
   \                     ??SPI0_TxRxWord_1: (+1)
   \   0000001C   0x....             LDR      R0,??DataTable10_1  ;; 0x40075000
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD5FB             BPL      ??SPI0_TxRxWord_1
     73            return (SPI_GetWord(SPI0));     /* read data and exit                       */
   \   00000024   0x....             LDR      R0,??DataTable10_2  ;; 0x40075006
   \   00000026   0x7802             LDRB     R2,[R0, #+0]
   \   00000028   0xB2D2             UXTB     R2,R2
   \   0000002A   0x....             LDR      R0,??DataTable11  ;; 0x40075007
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0xB2C0             UXTB     R0,R0
   \   00000030   0x0200             LSLS     R0,R0,#+8
   \   00000032   0x4310             ORRS     R0,R0,R2
   \   00000034   0xB280             UXTH     R0,R0
   \   00000036   0xBD00             POP      {PC}             ;; return
     74          }
     75          

   \                                 In section .text, align 2, keep-with-next
     76          uint16 SPI1_TxRxWord(uint16 txdata)
     77          {
   \                     SPI1_TxRxWord: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
     78            while (!SPI_TxCmpl(SPI1));      /* wait until Tx buffer is empty            */
   \                     ??SPI1_TxRxWord_0: (+1)
   \   00000004   0x....             LDR      R0,??DataTable11_1  ;; 0x40076000
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x0680             LSLS     R0,R0,#+26
   \   0000000A   0xD5FB             BPL      ??SPI1_TxRxWord_0
     79            SPI_PutWord(SPI1,txdata);       /* write a 16-bit data                      */
   \   0000000C   0x0008             MOVS     R0,R1
   \   0000000E   0x0002             MOVS     R2,R0
   \   00000010   0x....             LDR      R3,??DataTable11_2  ;; 0x40076006
   \   00000012   0x701A             STRB     R2,[R3, #+0]
   \   00000014   0xB280             UXTH     R0,R0
   \   00000016   0x0A00             LSRS     R0,R0,#+8
   \   00000018   0x....             LDR      R2,??DataTable12  ;; 0x40076007
   \   0000001A   0x7010             STRB     R0,[R2, #+0]
     80            while(!SPI_RxFull(SPI1));       /* wait until Rx buffer is full             */
   \                     ??SPI1_TxRxWord_1: (+1)
   \   0000001C   0x....             LDR      R0,??DataTable11_1  ;; 0x40076000
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x0600             LSLS     R0,R0,#+24
   \   00000022   0xD5FB             BPL      ??SPI1_TxRxWord_1
     81            return (SPI_GetWord(SPI1));     /* read data and exit                       */
   \   00000024   0x....             LDR      R0,??DataTable11_2  ;; 0x40076006
   \   00000026   0x7802             LDRB     R2,[R0, #+0]
   \   00000028   0xB2D2             UXTB     R2,R2
   \   0000002A   0x....             LDR      R0,??DataTable12  ;; 0x40076007
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0xB2C0             UXTB     R0,R0
   \   00000030   0x0200             LSLS     R0,R0,#+8
   \   00000032   0x4310             ORRS     R0,R0,R2
   \   00000034   0xB280             UXTH     R0,R0
   \   00000036   0xBD00             POP      {PC}             ;; return
     82          }
     83          
     84          /******************************************************************************
     85           * Simple SPI Tx/Rx function (1 byte Tx + 1 byte Rx)                          *
     86           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     87          uint8 SPI0_TxRxByte(uint8 txdata)
     88          {
   \                     SPI0_TxRxByte: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
     89            while (!SPI_TxCmpl(SPI0));      /* wait until Tx buffer is empty            */
   \                     ??SPI0_TxRxByte_0: (+1)
   \   00000004   0x....             LDR      R0,??DataTable10_1  ;; 0x40075000
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x0680             LSLS     R0,R0,#+26
   \   0000000A   0xD5FB             BPL      ??SPI0_TxRxByte_0
     90            SPI_PutByte(SPI0,txdata);       /* write an 8-bit data                      */
   \   0000000C   0x....             LDR      R0,??DataTable10_2  ;; 0x40075006
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
     91            while(!SPI_RxFull(SPI0));       /* wait until Rx buffer is full             */
   \                     ??SPI0_TxRxByte_1: (+1)
   \   00000010   0x....             LDR      R0,??DataTable10_1  ;; 0x40075000
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x0600             LSLS     R0,R0,#+24
   \   00000016   0xD5FB             BPL      ??SPI0_TxRxByte_1
     92            return (SPI_GetByte(SPI0));     /* read data and exit                       */
   \   00000018   0x....             LDR      R0,??DataTable10_2  ;; 0x40075006
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0xBD00             POP      {PC}             ;; return
     93          }
     94          

   \                                 In section .text, align 2, keep-with-next
     95          uint8 SPI1_TxRxByte(uint8 txdata)
     96          {
   \                     SPI1_TxRxByte: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
     97            while (!SPI_TxCmpl(SPI1));      /* wait until Tx buffer is empty            */
   \                     ??SPI1_TxRxByte_0: (+1)
   \   00000004   0x....             LDR      R0,??DataTable11_1  ;; 0x40076000
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x0680             LSLS     R0,R0,#+26
   \   0000000A   0xD5FB             BPL      ??SPI1_TxRxByte_0
     98            SPI_PutByte(SPI1,txdata);       /* write an 8-bit data                      */
   \   0000000C   0x....             LDR      R0,??DataTable11_2  ;; 0x40076006
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
     99            while(!SPI_RxFull(SPI1));       /* wait until Rx buffer is full             */
   \                     ??SPI1_TxRxByte_1: (+1)
   \   00000010   0x....             LDR      R0,??DataTable11_1  ;; 0x40076000
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x0600             LSLS     R0,R0,#+24
   \   00000016   0xD5FB             BPL      ??SPI1_TxRxByte_1
    100            return (SPI_GetByte(SPI1));     /* read data and exit                       */
   \   00000018   0x....             LDR      R0,??DataTable11_2  ;; 0x40076006
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0xB2C0             UXTB     R0,R0
   \   0000001E   0xBD00             POP      {PC}             ;; return
    101          }
    102          
    103          /******************************************************************************
    104           * Communication via an SPI (Tx+Rx data packet) with driving a slave select   *
    105           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    106          void SPI0_CommWord(uint16 *txdata, uint16 txcnt,uint16 *rxdata, uint16 rxcnt)
    107          {
   \                     SPI0_CommWord: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   \   00000006   0x001F             MOVS     R7,R3
    108            register uint16 i;
    109          
    110            /* SS=0                                                                     */
    111            if (pCallbackSS0)  { pCallbackSS0 (SS_CLEAR); }
   \   00000008   0x....             LDR      R0,??DataTable7_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ      ??SPI0_CommWord_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR      R1,??DataTable7_1
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x4788             BLX      R1
    112          
    113            if (txdata) {                   /* any data for transmitting?               */
   \                     ??SPI0_CommWord_0: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD00C             BEQ      ??SPI0_CommWord_1
    114              for (i=0; i<txcnt; i++) {     /* writing cycle                            */
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0006             MOVS     R6,R0
   \                     ??SPI0_CommWord_2: (+1)
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x8800             LDRH     R0,[R0, #+0]
   \   00000024   0xB2B6             UXTH     R6,R6
   \   00000026   0x4286             CMP      R6,R0
   \   00000028   0xD205             BCS      ??SPI0_CommWord_1
    115                SPI_TxRxWord(SPI0,*txdata); /* Write a 16-bit data                      */
   \   0000002A   0x8820             LDRH     R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       SPI0_TxRxWord
    116                txdata++;                   /* increment a source address               */
   \   00000030   0x1CA4             ADDS     R4,R4,#+2
    117              }
   \   00000032   0x1C76             ADDS     R6,R6,#+1
   \   00000034   0xE7F4             B        ??SPI0_CommWord_2
    118            }
    119          
    120            if (rxdata) {                   /* any data for receiving?                  */
   \                     ??SPI0_CommWord_1: (+1)
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD00C             BEQ      ??SPI0_CommWord_3
    121              for (i=0; i<rxcnt; i++) {     /* reading cycle                            */
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x0006             MOVS     R6,R0
   \                     ??SPI0_CommWord_4: (+1)
   \   0000003E   0xB2B6             UXTH     R6,R6
   \   00000040   0xB2BF             UXTH     R7,R7
   \   00000042   0x42BE             CMP      R6,R7
   \   00000044   0xD206             BCS      ??SPI0_CommWord_3
    122                /* read a 16-bit data with writing a dummy data to generate SCLK signal */
    123                *rxdata=SPI_TxRxWord(SPI0,0xFF);/* 0xFF is dummy data for writing!      */
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0x.... 0x....      BL       SPI0_TxRxWord
   \   0000004C   0x8028             STRH     R0,[R5, #+0]
    124                rxdata++;                   /* increment a destination address          */
   \   0000004E   0x1CAD             ADDS     R5,R5,#+2
    125              }
   \   00000050   0x1C76             ADDS     R6,R6,#+1
   \   00000052   0xE7F4             B        ??SPI0_CommWord_4
    126            }
    127          
    128            /* SS=1                                                                     */
    129            if (pCallbackSS0) { pCallbackSS0 (SS_SET); }
   \                     ??SPI0_CommWord_3: (+1)
   \   00000054   0x....             LDR      R0,??DataTable7_1
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD003             BEQ      ??SPI0_CommWord_5
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x....             LDR      R1,??DataTable7_1
   \   00000060   0x6809             LDR      R1,[R1, #+0]
   \   00000062   0x4788             BLX      R1
    130          }
   \                     ??SPI0_CommWord_5: (+1)
   \   00000064   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    131          

   \                                 In section .text, align 2, keep-with-next
    132          void SPI0_CommByte(uint8 *txdata, uint16 txcnt,uint8 *rxdata, uint16 rxcnt)
    133          {
   \                     SPI0_CommByte: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   \   00000006   0x001F             MOVS     R7,R3
    134            register uint16 i;
    135          
    136            /* SS=0                                                                     */
    137            if (pCallbackSS0) { pCallbackSS0 (SS_CLEAR); }
   \   00000008   0x....             LDR      R0,??DataTable7_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ      ??SPI0_CommByte_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR      R1,??DataTable7_1
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x4788             BLX      R1
    138          
    139            if (txdata) {                   /* any data for transmitting?               */
   \                     ??SPI0_CommByte_0: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD00C             BEQ      ??SPI0_CommByte_1
    140              for (i=0; i<txcnt; i++) {     /* writing cycle                            */
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0006             MOVS     R6,R0
   \                     ??SPI0_CommByte_2: (+1)
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x8800             LDRH     R0,[R0, #+0]
   \   00000024   0xB2B6             UXTH     R6,R6
   \   00000026   0x4286             CMP      R6,R0
   \   00000028   0xD205             BCS      ??SPI0_CommByte_1
    141                SPI_TxRxByte(SPI0,*txdata); /* write an 8-bit data                      */
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       SPI0_TxRxByte
    142                txdata++;                   /* increment a source address               */
   \   00000030   0x1C64             ADDS     R4,R4,#+1
    143              }
   \   00000032   0x1C76             ADDS     R6,R6,#+1
   \   00000034   0xE7F4             B        ??SPI0_CommByte_2
    144            }
    145          
    146            if (rxdata) {                   /* any data for receiving?                  */
   \                     ??SPI0_CommByte_1: (+1)
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD00C             BEQ      ??SPI0_CommByte_3
    147              for (i=0; i<rxcnt; i++) {     /* reading cycle                            */
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x0006             MOVS     R6,R0
   \                     ??SPI0_CommByte_4: (+1)
   \   0000003E   0xB2B6             UXTH     R6,R6
   \   00000040   0xB2BF             UXTH     R7,R7
   \   00000042   0x42BE             CMP      R6,R7
   \   00000044   0xD206             BCS      ??SPI0_CommByte_3
    148                /* read an 8-bit data with writing a dummy data to generate SCLK signal */
    149                *rxdata=SPI_TxRxByte(SPI0,0xFF);/* 0xFF is dummy data for writing!      */
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0x.... 0x....      BL       SPI0_TxRxByte
   \   0000004C   0x7028             STRB     R0,[R5, #+0]
    150                rxdata++;                   /* increment a destination address          */
   \   0000004E   0x1C6D             ADDS     R5,R5,#+1
    151              }
   \   00000050   0x1C76             ADDS     R6,R6,#+1
   \   00000052   0xE7F4             B        ??SPI0_CommByte_4
    152            }
    153          
    154            /* SS=1                                                                     */
    155            if (pCallbackSS0) { pCallbackSS0 (SS_SET); }
   \                     ??SPI0_CommByte_3: (+1)
   \   00000054   0x....             LDR      R0,??DataTable7_1
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD003             BEQ      ??SPI0_CommByte_5
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x....             LDR      R1,??DataTable7_1
   \   00000060   0x6809             LDR      R1,[R1, #+0]
   \   00000062   0x4788             BLX      R1
    156          }
   \                     ??SPI0_CommByte_5: (+1)
   \   00000064   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    157          

   \                                 In section .text, align 2, keep-with-next
    158          void SPI1_CommWord(uint16 *txdata, uint16 txcnt,uint16 *rxdata, uint16 rxcnt)
    159          {
   \                     SPI1_CommWord: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   \   00000006   0x001F             MOVS     R7,R3
    160            register uint16 i;
    161          
    162            /* SS=0                                                                     */
    163            if (pCallbackSS1) { pCallbackSS1 (SS_CLEAR); }
   \   00000008   0x....             LDR      R0,??DataTable8_2
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ      ??SPI1_CommWord_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR      R1,??DataTable8_2
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x4788             BLX      R1
    164          
    165            if (txdata) {                   /* any data for transmitting?               */
   \                     ??SPI1_CommWord_0: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD00C             BEQ      ??SPI1_CommWord_1
    166              for (i=0; i<txcnt; i++) {     /* writing cycle                            */
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0006             MOVS     R6,R0
   \                     ??SPI1_CommWord_2: (+1)
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x8800             LDRH     R0,[R0, #+0]
   \   00000024   0xB2B6             UXTH     R6,R6
   \   00000026   0x4286             CMP      R6,R0
   \   00000028   0xD205             BCS      ??SPI1_CommWord_1
    167                SPI_TxRxWord(SPI1,*txdata); /* write a 16-bit data                      */
   \   0000002A   0x8820             LDRH     R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       SPI1_TxRxWord
    168                txdata++;                   /* increment a source address               */
   \   00000030   0x1CA4             ADDS     R4,R4,#+2
    169              }
   \   00000032   0x1C76             ADDS     R6,R6,#+1
   \   00000034   0xE7F4             B        ??SPI1_CommWord_2
    170            }
    171          
    172            if (rxdata) {                   /* any data for receiving?                  */
   \                     ??SPI1_CommWord_1: (+1)
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD00C             BEQ      ??SPI1_CommWord_3
    173              for (i=0; i<rxcnt; i++) {     /* reading cycle                            */
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x0006             MOVS     R6,R0
   \                     ??SPI1_CommWord_4: (+1)
   \   0000003E   0xB2B6             UXTH     R6,R6
   \   00000040   0xB2BF             UXTH     R7,R7
   \   00000042   0x42BE             CMP      R6,R7
   \   00000044   0xD206             BCS      ??SPI1_CommWord_3
    174                /* read a 16-bit data with writing a dummy data to generate SCLK signal */
    175                *rxdata=SPI_TxRxWord(SPI1,0xFF);/* 0xFF is dummy data for writing!      */
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0x.... 0x....      BL       SPI1_TxRxWord
   \   0000004C   0x8028             STRH     R0,[R5, #+0]
    176                rxdata++;                   /* increment a destination address          */
   \   0000004E   0x1CAD             ADDS     R5,R5,#+2
    177              }
   \   00000050   0x1C76             ADDS     R6,R6,#+1
   \   00000052   0xE7F4             B        ??SPI1_CommWord_4
    178            }
    179          
    180            /* SS=1                                                                     */
    181            if (pCallbackSS1) { pCallbackSS1 (SS_SET); }
   \                     ??SPI1_CommWord_3: (+1)
   \   00000054   0x....             LDR      R0,??DataTable8_2
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD003             BEQ      ??SPI1_CommWord_5
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x....             LDR      R1,??DataTable8_2
   \   00000060   0x6809             LDR      R1,[R1, #+0]
   \   00000062   0x4788             BLX      R1
    182          }
   \                     ??SPI1_CommWord_5: (+1)
   \   00000064   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    183          

   \                                 In section .text, align 2, keep-with-next
    184          void SPI1_CommByte(uint8 *txdata, uint16 txcnt,uint8 *rxdata, uint16 rxcnt)
    185          {
   \                     SPI1_CommByte: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0015             MOVS     R5,R2
   \   00000006   0x001F             MOVS     R7,R3
    186            register uint16 i;
    187          
    188            /* SS=0                                                                     */
    189            if (pCallbackSS1) { pCallbackSS1 (SS_CLEAR); }
   \   00000008   0x....             LDR      R0,??DataTable15
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD003             BEQ      ??SPI1_CommByte_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x....             LDR      R1,??DataTable15
   \   00000014   0x6809             LDR      R1,[R1, #+0]
   \   00000016   0x4788             BLX      R1
    190          
    191            if (txdata) {                   /* any data for transmitting?               */
   \                     ??SPI1_CommByte_0: (+1)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD00C             BEQ      ??SPI1_CommByte_1
    192              for (i=0; i<txcnt; i++) {     /* writing cycle                            */
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x0006             MOVS     R6,R0
   \                     ??SPI1_CommByte_2: (+1)
   \   00000020   0x4668             MOV      R0,SP
   \   00000022   0x8800             LDRH     R0,[R0, #+0]
   \   00000024   0xB2B6             UXTH     R6,R6
   \   00000026   0x4286             CMP      R6,R0
   \   00000028   0xD205             BCS      ??SPI1_CommByte_1
    193                SPI_TxRxByte(SPI1,*txdata); /* write an 8-bit data                      */
   \   0000002A   0x7820             LDRB     R0,[R4, #+0]
   \   0000002C   0x.... 0x....      BL       SPI1_TxRxByte
    194                txdata++;                   /* increment a source address               */
   \   00000030   0x1C64             ADDS     R4,R4,#+1
    195              }
   \   00000032   0x1C76             ADDS     R6,R6,#+1
   \   00000034   0xE7F4             B        ??SPI1_CommByte_2
    196            }
    197          
    198            if (rxdata) {                   /* any data for receiving?                  */
   \                     ??SPI1_CommByte_1: (+1)
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD00C             BEQ      ??SPI1_CommByte_3
    199              for (i=0; i<rxcnt; i++) {     /* reading cycle                            */
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x0006             MOVS     R6,R0
   \                     ??SPI1_CommByte_4: (+1)
   \   0000003E   0xB2B6             UXTH     R6,R6
   \   00000040   0xB2BF             UXTH     R7,R7
   \   00000042   0x42BE             CMP      R6,R7
   \   00000044   0xD206             BCS      ??SPI1_CommByte_3
    200                /*read an 8-bit data with writing a dummy data to generate SCLK signal  */
    201                *rxdata=SPI_TxRxByte(SPI1,0xFF);/* 0xFF is dummy data for writing!      */
   \   00000046   0x20FF             MOVS     R0,#+255
   \   00000048   0x.... 0x....      BL       SPI1_TxRxByte
   \   0000004C   0x7028             STRB     R0,[R5, #+0]
    202                rxdata++;                   /* increment a destination address          */
   \   0000004E   0x1C6D             ADDS     R5,R5,#+1
    203              }
   \   00000050   0x1C76             ADDS     R6,R6,#+1
   \   00000052   0xE7F4             B        ??SPI1_CommByte_4
    204            }
    205          
    206            /* SS=1                                                                     */
    207            if (pCallbackSS1) { pCallbackSS1 (SS_SET); }
   \                     ??SPI1_CommByte_3: (+1)
   \   00000054   0x....             LDR      R0,??DataTable15
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD003             BEQ      ??SPI1_CommByte_5
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x....             LDR      R1,??DataTable15
   \   00000060   0x6809             LDR      R1,[R1, #+0]
   \   00000062   0x4788             BLX      R1
    208          }
   \                     ??SPI1_CommByte_5: (+1)
   \   00000064   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    209          

   \                                 In section .text, align 2, keep-with-next
    210          void SPI1_PutWordToFifo(uint16 *txdata, uint32 txcnt)
    211          {
   \                     SPI1_PutWordToFifo: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    212            register uint32 i;
    213          
    214            if (txdata) {                   /* any data for transmitting?               */
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD014             BEQ      ??SPI1_PutWordToFifo_0
    215              for (i=0; i<txcnt; i++) {     /* writing cycle                            */
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x001A             MOVS     R2,R3
   \                     ??SPI1_PutWordToFifo_1: (+1)
   \   0000000A   0x428A             CMP      R2,R1
   \   0000000C   0xD210             BCS      ??SPI1_PutWordToFifo_0
    216                if(!(SPI_TxFifoFull(SPI1))) {  /* isn't transmit FIFO full?             */
   \   0000000E   0x....             LDR      R3,??DataTable11_1  ;; 0x40076000
   \   00000010   0x781B             LDRB     R3,[R3, #+0]
   \   00000012   0x061B             LSLS     R3,R3,#+24
   \   00000014   0xD40B             BMI      ??SPI1_PutWordToFifo_2
    217                  SPI_PutWord(SPI1,*txdata);/* write 16-bit data                        */
   \   00000016   0x8804             LDRH     R4,[R0, #+0]
   \   00000018   0x0023             MOVS     R3,R4
   \   0000001A   0x001C             MOVS     R4,R3
   \   0000001C   0x....             LDR      R5,??DataTable11_2  ;; 0x40076006
   \   0000001E   0x702C             STRB     R4,[R5, #+0]
   \   00000020   0xB29B             UXTH     R3,R3
   \   00000022   0x0A1B             LSRS     R3,R3,#+8
   \   00000024   0x....             LDR      R4,??DataTable15_1  ;; 0x40076007
   \   00000026   0x7023             STRB     R3,[R4, #+0]
    218                  txdata++;                 /* increment a source address               */
   \   00000028   0x1C80             ADDS     R0,R0,#+2
    219                }
   \   0000002A   0x1C52             ADDS     R2,R2,#+1
   \   0000002C   0xE7ED             B        ??SPI1_PutWordToFifo_1
    220                else {
    221                  return;
   \                     ??SPI1_PutWordToFifo_2: (+1)
   \   0000002E   0xE7FF             B        ??SPI1_PutWordToFifo_3
    222                }
    223              }
    224            }
    225          }
   \                     ??SPI1_PutWordToFifo_0: (+1)
   \                     ??SPI1_PutWordToFifo_3: (+1)
   \   00000030   0xBD30             POP      {R4,R5,PC}       ;; return
    226          

   \                                 In section .text, align 2, keep-with-next
    227          void SPI1_PutByteToFifo(uint8 *txdata, uint32 txcnt)
    228          {
   \                     SPI1_PutByteToFifo: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    229            register uint32 i;
    230          
    231            if (txdata) {                   /* any data for transmitting?               */
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD00E             BEQ      ??SPI1_PutByteToFifo_0
    232              for (i=0; i<txcnt; i++) {     /* writing cycle                            */
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x001A             MOVS     R2,R3
   \                     ??SPI1_PutByteToFifo_1: (+1)
   \   0000000A   0x428A             CMP      R2,R1
   \   0000000C   0xD20A             BCS      ??SPI1_PutByteToFifo_0
    233                if(!(SPI_TxFifoFull(SPI1))) {  /* isn't transmit FIFO full?             */
   \   0000000E   0x....             LDR      R3,??DataTable11_1  ;; 0x40076000
   \   00000010   0x781B             LDRB     R3,[R3, #+0]
   \   00000012   0x061B             LSLS     R3,R3,#+24
   \   00000014   0xD405             BMI      ??SPI1_PutByteToFifo_2
    234                  SPI_PutByte(SPI1,*txdata);/* write 8-bit data                         */
   \   00000016   0x7803             LDRB     R3,[R0, #+0]
   \   00000018   0x....             LDR      R4,??DataTable15_2  ;; 0x40076006
   \   0000001A   0x7023             STRB     R3,[R4, #+0]
    235                  txdata++;                 /* increment a source address               */
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
    236                }
   \   0000001E   0x1C52             ADDS     R2,R2,#+1
   \   00000020   0xE7F3             B        ??SPI1_PutByteToFifo_1
    237                else {
    238                  return;
   \                     ??SPI1_PutByteToFifo_2: (+1)
   \   00000022   0xE7FF             B        ??SPI1_PutByteToFifo_3
    239                }
    240              }
    241            }
    242          }
   \                     ??SPI1_PutByteToFifo_0: (+1)
   \                     ??SPI1_PutByteToFifo_3: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    243          

   \                                 In section .text, align 2, keep-with-next
    244          void SPI1_GetWordFromFifo(uint16 *rxdata, uint32 rxcnt)
    245          {
   \                     SPI1_GetWordFromFifo: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    246            register uint32 i;
    247          
    248            if (rxdata) {                   /* any data for receiving?                  */
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD013             BEQ      ??SPI1_GetWordFromFifo_0
    249              for (i=0; i<rxcnt; i++) {     /* reading cycle                            */
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x001A             MOVS     R2,R3
   \                     ??SPI1_GetWordFromFifo_1: (+1)
   \   0000000A   0x428A             CMP      R2,R1
   \   0000000C   0xD20F             BCS      ??SPI1_GetWordFromFifo_0
    250                  *rxdata = SPI_GetWord(SPI1); /* read 16-bit data                      */
   \   0000000E   0x....             LDR      R3,??DataTable15_2  ;; 0x40076006
   \   00000010   0x781B             LDRB     R3,[R3, #+0]
   \   00000012   0xB2DB             UXTB     R3,R3
   \   00000014   0x....             LDR      R4,??DataTable12  ;; 0x40076007
   \   00000016   0x7824             LDRB     R4,[R4, #+0]
   \   00000018   0xB2E4             UXTB     R4,R4
   \   0000001A   0x0224             LSLS     R4,R4,#+8
   \   0000001C   0x431C             ORRS     R4,R4,R3
   \   0000001E   0x8004             STRH     R4,[R0, #+0]
    251                  if(SPI_RxFifoEmpty(SPI1)) {  /* is receive FIFO empty?                */
   \   00000020   0x....             LDR      R3,??DataTable15_3  ;; 0x40076000
   \   00000022   0x781B             LDRB     R3,[R3, #+0]
   \   00000024   0x07DB             LSLS     R3,R3,#+31
   \   00000026   0xD402             BMI      ??SPI1_GetWordFromFifo_2
    252                  return;
    253                }
    254                  rxdata++;                 /* increment a destination address          */
   \                     ??SPI1_GetWordFromFifo_3: (+1)
   \   00000028   0x1C80             ADDS     R0,R0,#+2
    255              }
   \   0000002A   0x1C52             ADDS     R2,R2,#+1
   \   0000002C   0xE7ED             B        ??SPI1_GetWordFromFifo_1
    256            }
    257          }
   \                     ??SPI1_GetWordFromFifo_0: (+1)
   \                     ??SPI1_GetWordFromFifo_2: (+1)
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
    258          

   \                                 In section .text, align 2, keep-with-next
    259          void SPI1_GetByteFromFifo(uint8 *rxdata, uint32 rxcnt)
    260          {
   \                     SPI1_GetByteFromFifo: (+1)
   \   00000000   0xB500             PUSH     {LR}
    261            register uint32 i;
    262          
    263            if (rxdata) {                   /* any data for receiving?                  */
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD00D             BEQ      ??SPI1_GetByteFromFifo_0
    264              for (i=0; i<rxcnt; i++) {     /* reading cycle                            */
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0x001A             MOVS     R2,R3
   \                     ??SPI1_GetByteFromFifo_1: (+1)
   \   0000000A   0x428A             CMP      R2,R1
   \   0000000C   0xD209             BCS      ??SPI1_GetByteFromFifo_0
    265                  *rxdata = SPI_GetByte(SPI1); /* read 8-bit data                       */
   \   0000000E   0x....             LDR      R3,??DataTable15_2  ;; 0x40076006
   \   00000010   0x781B             LDRB     R3,[R3, #+0]
   \   00000012   0x7003             STRB     R3,[R0, #+0]
    266                  if(SPI_RxFifoEmpty(SPI1)) {  /* is receive FIFO empty?                */
   \   00000014   0x....             LDR      R3,??DataTable15_3  ;; 0x40076000
   \   00000016   0x781B             LDRB     R3,[R3, #+0]
   \   00000018   0x07DB             LSLS     R3,R3,#+31
   \   0000001A   0xD402             BMI      ??SPI1_GetByteFromFifo_2
    267                  return;
    268                }
    269              rxdata++;                     /* increment a destination address          */
   \                     ??SPI1_GetByteFromFifo_3: (+1)
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
    270              }
   \   0000001E   0x1C52             ADDS     R2,R2,#+1
   \   00000020   0xE7F3             B        ??SPI1_GetByteFromFifo_1
    271            }
    272          }
   \                     ??SPI1_GetByteFromFifo_0: (+1)
   \                     ??SPI1_GetByteFromFifo_2: (+1)
   \   00000022   0xBD00             POP      {PC}             ;; return
    273          /******************************************************************************
    274           * interrupt function definitions                                             *
    275           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    276          weak void spi0_isr (void)
    277          {
   \                     spi0_isr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    278            register uint8 tmp = SPI0_S;
   \   00000002   0x....             LDR      R0,??DataTable15_4  ;; 0x40075000
   \   00000004   0x7804             LDRB     R4,[R0, #+0]
    279          
    280            /* Rx buffer or FIFO buffer is full; SPRF is cleared by reading data        */
    281            /* registers DH:DL                                                          */
    282            if(tmp & SPI_S_SPRF_MASK) { pCallbackSPI0 (SPI0_CALLBACK,SPI_RX_CALLBACK); }
   \   00000006   0x0620             LSLS     R0,R4,#+24
   \   00000008   0xD504             BPL      ??spi0_isr_0
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x....             LDR      R2,??DataTable15_5
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0x4790             BLX      R2
    283          
    284            /* Tx buffer or FIFO buffer is empty; SPTEF is cleared by writing a value   */
    285            /* to DH:DL                                                                 */
    286            if(tmp & SPI_S_SPTEF_MASK){ pCallbackSPI0 (SPI0_CALLBACK,SPI_TX_CALLBACK); }
   \                     ??spi0_isr_0: (+1)
   \   00000014   0x06A0             LSLS     R0,R4,#+26
   \   00000016   0xD504             BPL      ??spi0_isr_1
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x....             LDR      R2,??DataTable15_5
   \   0000001E   0x6812             LDR      R2,[R2, #+0]
   \   00000020   0x4790             BLX      R2
    287          
    288            /* Receive data buffer matches the value in MH:ML registers                 */
    289            if(tmp & SPI_S_SPMF_MASK)
   \                     ??spi0_isr_1: (+1)
   \   00000022   0x0660             LSLS     R0,R4,#+25
   \   00000024   0xD507             BPL      ??spi0_isr_2
    290            {
    291              SPI0_S = SPI_S_SPMF_MASK;                              /* clear SPMF flag */
   \   00000026   0x2040             MOVS     R0,#+64
   \   00000028   0x....             LDR      R1,??DataTable15_4  ;; 0x40075000
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    292              pCallbackSPI0 (SPI0_CALLBACK,SPI_MATCH_CALLBACK);
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x....             LDR      R2,??DataTable15_5
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0x4790             BLX      R2
    293            }
    294          
    295            /* Mode fault error detected (Only for MSTR=1, MODFEN=1, SSOE=0)            */
    296            if(tmp & SPI_S_MODF_MASK)
   \                     ??spi0_isr_2: (+1)
   \   00000036   0x06E0             LSLS     R0,R4,#+27
   \   00000038   0xD508             BPL      ??spi0_isr_3
    297            {
    298              SPI0_C1 = SPI0_C1;                                     /* clear MODF flag */
   \   0000003A   0x....             LDR      R0,??DataTable15_6  ;; 0x40075003
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x....             LDR      R1,??DataTable15_6  ;; 0x40075003
   \   00000040   0x7008             STRB     R0,[R1, #+0]
    299              pCallbackSPI0 (SPI0_CALLBACK,SPI_FAULT_CALLBACK);
   \   00000042   0x2108             MOVS     R1,#+8
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x....             LDR      R2,??DataTable15_5
   \   00000048   0x6812             LDR      R2,[R2, #+0]
   \   0000004A   0x4790             BLX      R2
    300            }
    301          }
   \                     ??spi0_isr_3: (+1)
   \   0000004C   0xBD10             POP      {R4,PC}          ;; return
    302          

   \                                 In section .text, align 2, keep-with-next
    303          weak void spi1_isr (void)
    304          {
   \                     spi1_isr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    305            register uint8 tmp = SPI1_S;
   \   00000002   0x....             LDR      R0,??DataTable15_3  ;; 0x40076000
   \   00000004   0x7804             LDRB     R4,[R0, #+0]
    306          
    307            /* Rx buffer or Rx FIFO buffer is full; SPRF is cleared by reading data     */
    308            /* registers DH:DL                                                          */
    309            if(tmp & SPI_S_SPRF_MASK) { pCallbackSPI1 (SPI1_CALLBACK,SPI_RX_CALLBACK); }
   \   00000006   0x0620             LSLS     R0,R4,#+24
   \   00000008   0xD504             BPL      ??spi1_isr_0
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E   0x....             LDR      R2,??DataTable15_7
   \   00000010   0x6812             LDR      R2,[R2, #+0]
   \   00000012   0x4790             BLX      R2
    310          
    311            /* Tx buffer or Tx FIFO buffer is empty; SPTEF is cleared by writing a      */
    312            /* value to DH:DL                                                           */
    313            if(tmp & SPI_S_SPTEF_MASK){ pCallbackSPI1 (SPI1_CALLBACK,SPI_TX_CALLBACK); }
   \                     ??spi1_isr_0: (+1)
   \   00000014   0x06A0             LSLS     R0,R4,#+26
   \   00000016   0xD504             BPL      ??spi1_isr_1
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0x....             LDR      R2,??DataTable15_7
   \   0000001E   0x6812             LDR      R2,[R2, #+0]
   \   00000020   0x4790             BLX      R2
    314          
    315            /* Receive data buffer matches the value in MH:ML registers                 */
    316            if(tmp & SPI_S_SPMF_MASK)
   \                     ??spi1_isr_1: (+1)
   \   00000022   0x0660             LSLS     R0,R4,#+25
   \   00000024   0xD507             BPL      ??spi1_isr_2
    317            {
    318              SPI1_S = SPI_S_SPMF_MASK;                              /* clear SPMF flag */
   \   00000026   0x2040             MOVS     R0,#+64
   \   00000028   0x....             LDR      R1,??DataTable15_3  ;; 0x40076000
   \   0000002A   0x7008             STRB     R0,[R1, #+0]
    319              pCallbackSPI1 (SPI1_CALLBACK,SPI_MATCH_CALLBACK);
   \   0000002C   0x2104             MOVS     R1,#+4
   \   0000002E   0x2002             MOVS     R0,#+2
   \   00000030   0x....             LDR      R2,??DataTable15_7
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0x4790             BLX      R2
    320            }
    321          
    322            /* Tx FIFO buffer is near to empty; TNEAREF is cleared when enough data is  */
    323            /* written to FIFO buffer                                                   */
    324            if((tmp & SPI_S_TNEAREF_MASK) && (SPI1_C3 & SPI_C3_TNEARIEN_MASK))
   \                     ??spi1_isr_2: (+1)
   \   00000036   0x0760             LSLS     R0,R4,#+29
   \   00000038   0xD508             BPL      ??spi1_isr_3
   \   0000003A   0x....             LDR      R0,??DataTable15_8  ;; 0x4007600b
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x0740             LSLS     R0,R0,#+29
   \   00000040   0xD504             BPL      ??spi1_isr_3
    325            {
    326              pCallbackSPI1 (SPI1_CALLBACK,SPI_TXFNE_CALLBACK);
   \   00000042   0x2120             MOVS     R1,#+32
   \   00000044   0x2002             MOVS     R0,#+2
   \   00000046   0x....             LDR      R2,??DataTable15_7
   \   00000048   0x6812             LDR      R2,[R2, #+0]
   \   0000004A   0x4790             BLX      R2
    327            }
    328          
    329            /* Rx FIFO buffer is near to full; RNFULLF is cleared when enough data is   */
    330            /* read from FIFO buffer                                                    */
    331            if((tmp & SPI_S_RNFULLF_MASK) && (SPI1_C3 & SPI_C3_RNFULLIEN_MASK))
   \                     ??spi1_isr_3: (+1)
   \   0000004C   0x0720             LSLS     R0,R4,#+28
   \   0000004E   0xD508             BPL      ??spi1_isr_4
   \   00000050   0x....             LDR      R0,??DataTable15_8  ;; 0x4007600b
   \   00000052   0x7800             LDRB     R0,[R0, #+0]
   \   00000054   0x0780             LSLS     R0,R0,#+30
   \   00000056   0xD504             BPL      ??spi1_isr_4
    332            {
    333              pCallbackSPI1 (SPI1_CALLBACK,SPI_RXFNF_CALLBACK);
   \   00000058   0x2110             MOVS     R1,#+16
   \   0000005A   0x2002             MOVS     R0,#+2
   \   0000005C   0x....             LDR      R2,??DataTable15_7
   \   0000005E   0x6812             LDR      R2,[R2, #+0]
   \   00000060   0x4790             BLX      R2
    334            }
    335          
    336            /* Mode fault error detected (Only for MSTR=1, MODFEN=1, SSOE=0)            */
    337            if(tmp & SPI_S_MODF_MASK)
   \                     ??spi1_isr_4: (+1)
   \   00000062   0x06E0             LSLS     R0,R4,#+27
   \   00000064   0xD508             BPL      ??spi1_isr_5
    338            {
    339              SPI1_C1 = SPI1_C1;                                     /* clear MODF flag */
   \   00000066   0x....             LDR      R0,??DataTable15_9  ;; 0x40076003
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x....             LDR      R1,??DataTable15_9  ;; 0x40076003
   \   0000006C   0x7008             STRB     R0,[R1, #+0]
    340              pCallbackSPI1 (SPI1_CALLBACK,SPI_FAULT_CALLBACK);
   \   0000006E   0x2108             MOVS     R1,#+8
   \   00000070   0x2002             MOVS     R0,#+2
   \   00000072   0x....             LDR      R2,??DataTable15_7
   \   00000074   0x6812             LDR      R2,[R2, #+0]
   \   00000076   0x4790             BLX      R2
    341            }
    342          }
   \                     ??spi1_isr_5: (+1)
   \   00000078   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     pCallbackSPI0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0xE000E404         DC32     0xe000e404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     pCallbackSS0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x40075002         DC32     0x40075002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x40075001         DC32     0x40075001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x40075004         DC32     0x40075004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x40075005         DC32     0x40075005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x40075003         DC32     0x40075003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     pCallbackSPI1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     pCallbackSS1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40076002         DC32     0x40076002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x4007600B         DC32     0x4007600b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40076001         DC32     0x40076001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40076004         DC32     0x40076004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x40076005         DC32     0x40076005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x40076003         DC32     0x40076003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x40075000         DC32     0x40075000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x40075006         DC32     0x40075006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x40075007         DC32     0x40075007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x40076000         DC32     0x40076000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x40076006         DC32     0x40076006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x40076007         DC32     0x40076007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     pCallbackSS1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x40076007         DC32     0x40076007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x40076006         DC32     0x40076006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x40076000         DC32     0x40076000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x40075000         DC32     0x40075000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_5:
   \   00000000   0x........         DC32     pCallbackSPI0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_6:
   \   00000000   0x40075003         DC32     0x40075003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_7:
   \   00000000   0x........         DC32     pCallbackSPI1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_8:
   \   00000000   0x4007600B         DC32     0x4007600b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_9:
   \   00000000   0x40076003         DC32     0x40076003
    343          /******************************************************************************
    344           * End of module                                                              *
    345           ******************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SPI0_CommByte
        24   -- Indirect call
        24   -> SPI0_TxRxByte
      24   SPI0_CommWord
        24   -- Indirect call
        24   -> SPI0_TxRxWord
      24   SPI0_Init
        24   -- Indirect call
       4   SPI0_TxRxByte
       4   SPI0_TxRxWord
      24   SPI1_CommByte
        24   -- Indirect call
        24   -> SPI1_TxRxByte
      24   SPI1_CommWord
        24   -- Indirect call
        24   -> SPI1_TxRxWord
       4   SPI1_GetByteFromFifo
       8   SPI1_GetWordFromFifo
      24   SPI1_Init
        24   -- Indirect call
       8   SPI1_PutByteToFifo
      12   SPI1_PutWordToFifo
       4   SPI1_TxRxByte
       4   SPI1_TxRxWord
       8   spi0_isr
         8   -- Indirect call
       8   spi1_isr
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable12
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
     102  SPI0_CommByte
     102  SPI0_CommWord
     128  SPI0_Init
      32  SPI0_TxRxByte
      56  SPI0_TxRxWord
     102  SPI1_CommByte
     102  SPI1_CommWord
      36  SPI1_GetByteFromFifo
      48  SPI1_GetWordFromFifo
     136  SPI1_Init
      38  SPI1_PutByteToFifo
      50  SPI1_PutWordToFifo
      32  SPI1_TxRxByte
      56  SPI1_TxRxWord
       4  pCallbackSPI0
       4  pCallbackSPI1
       4  pCallbackSS0
       4  pCallbackSS1
      78  spi0_isr
     122  spi1_isr

 
    16 bytes in section .bss
 1 356 bytes in section .text
 
 1 356 bytes of CODE memory
    16 bytes of DATA memory

Errors: none
Warnings: none
