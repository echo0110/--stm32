###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        07/Mar/2017  09:12:05
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_protocol.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_protocol.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\..\..\..\..\src\projects\irtc1hzpulse_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\Release\List\freemaster_protocol.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\Release\Obj\freemaster_protocol.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_protocol.c
      1          /*******************************************************************************
      2          *
      3          * Copyright 2004-2014 Freescale Semiconductor, Inc.
      4          *
      5          * This software is owned or controlled by Freescale Semiconductor.
      6          * Use of this software is governed by the Freescale FreeMASTER License
      7          * distributed with this Material.
      8          * See the license file distributed for more details.
      9          *
     10          ****************************************************************************//*!
     11          *
     12          * @brief  FreeMASTER protocol handler
     13          *
     14          *******************************************************************************/
     15          
     16          #include "freemaster.h"
     17          #include "freemaster_private.h"
     18          #include "freemaster_protocol.h"
     19          
     20          #if !(FMSTR_DISABLE)
     21          /**************************************************************************//*!
     22          *
     23          * @brief    FreeMASTER driver initialization
     24          *
     25          ******************************************************************************/
     26          

   \                                 In section .text, align 2, keep-with-next
     27          FMSTR_BOOL FMSTR_Init(void)
     28          {
   \                     FMSTR_Init: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
     29          #if FMSTR_USE_TSA
     30              /* initialize TSA */
     31              FMSTR_InitTsa();
   \   00000004   0x.... 0x....      BL       FMSTR_InitTsa
     32          #endif
     33          
     34          #if FMSTR_USE_SCOPE
     35              /* initialize Scope */
     36              FMSTR_InitScope();
   \   00000008   0x.... 0x....      BL       FMSTR_InitScope
     37          #endif
     38          
     39          #if FMSTR_USE_RECORDER
     40              /* initialize Recorder */
     41              FMSTR_InitRec();
   \   0000000C   0x.... 0x....      BL       FMSTR_InitRec
     42          #endif
     43          
     44          #if FMSTR_USE_APPCMD
     45              /* initialize application commands */
     46              FMSTR_InitAppCmds();
     47          #endif
     48          
     49          #if FMSTR_USE_SFIO
     50              /* initialize SFIO encapsulation layer */
     51              FMSTR_InitSfio();
     52          #endif
     53          
     54          #if FMSTR_USE_PIPES
     55              /* initialize PIPES interface */
     56              FMSTR_InitPipes();
     57          #endif
     58          
     59          #if FMSTR_USE_CAN
     60              /* initialize CAN communication */
     61              FMSTR_InitCan();
     62          #endif
     63          
     64          #if FMSTR_USE_PDBDM
     65              /* initialize Packet Driven BDM communication */
     66              FMSTR_InitPDBdm();
     67          #endif
     68          
     69          #if FMSTR_USE_SERIAL
     70              /* initialize communication and start listening for commands */
     71              if (!FMSTR_InitSerial())
   \   00000010   0x.... 0x....      BL       FMSTR_InitSerial
   \   00000014   0x1E40             SUBS     R0,R0,#+1
   \   00000016   0x4180             SBCS     R0,R0,R0
   \   00000018   0x43C0             MVNS     R0,R0
   \   0000001A   0x0FC0             LSRS     R0,R0,#+31
     72                return FMSTR_FALSE;
   \   0000001C   0xB001             ADD      SP,SP,#+4
   \   0000001E   0xBD00             POP      {PC}             ;; return
     73          #endif
     74              return FMSTR_TRUE;
     75          }
     76          
     77          /**************************************************************************//*!
     78          *
     79          * @brief    Decodes the FreeMASTER protocol and calls appropriate handlers
     80          *
     81          * @param    pMessageIO - message in/out buffer
     82          *
     83          * @return   TRUE if frame was valid and any output was generated to IO buffer
     84          *
     85          * This Function decodes given message and invokes proper command handler
     86          * which fills in the response. The response transmission is initiated
     87          * in this call as well.
     88          *
     89          ******************************************************************************/
     90          

   \                                 In section .text, align 4, keep-with-next
     91          FMSTR_BOOL FMSTR_ProtocolDecoder(FMSTR_BPTR pMessageIO)
     92          {
   \                     FMSTR_ProtocolDecoder: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
     93              FMSTR_BPTR pResponseEnd;
     94              FMSTR_U8 nCmd;
     95          
     96              /* no EX access by default */
     97              FMSTR_SetExAddr(FMSTR_FALSE);
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x.... 0x....      BL       FMSTR_SetExAddr
     98          
     99              /* command code comes first in the message */
    100              /*lint -e{534} return value is not used */
    101              (void)FMSTR_ValueFromBuffer8(&nCmd, pMessageIO);
    102          
    103              /* process command   */
    104              switch (nCmd)
   \   0000000C   0x7820             LDRB     R0,[R4, #+0]
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xD01A             BEQ      ??FMSTR_ProtocolDecoder_0
   \   00000012   0x2805             CMP      R0,#+5
   \   00000014   0xD05A             BEQ      ??FMSTR_ProtocolDecoder_1
   \   00000016   0x2806             CMP      R0,#+6
   \   00000018   0xD071             BEQ      ??FMSTR_ProtocolDecoder_2
   \   0000001A   0x280A             CMP      R0,#+10
   \   0000001C   0xD031             BEQ      ??FMSTR_ProtocolDecoder_3
   \   0000001E   0x280B             CMP      R0,#+11
   \   00000020   0xD046             BEQ      ??FMSTR_ProtocolDecoder_4
   \   00000022   0x2812             CMP      R0,#+18
   \   00000024   0xD100             BNE      .+4
   \   00000026   0xE083             B        ??FMSTR_ProtocolDecoder_5
   \   00000028   0x28C0             CMP      R0,#+192
   \   0000002A   0xD100             BNE      .+4
   \   0000002C   0xE08E             B        ??FMSTR_ProtocolDecoder_6
   \   0000002E   0x28C1             CMP      R0,#+193
   \   00000030   0xD036             BEQ      ??FMSTR_ProtocolDecoder_7
   \   00000032   0x28C2             CMP      R0,#+194
   \   00000034   0xD038             BEQ      ??FMSTR_ProtocolDecoder_8
   \   00000036   0x28C3             CMP      R0,#+195
   \   00000038   0xD02E             BEQ      ??FMSTR_ProtocolDecoder_9
   \   0000003A   0x28C5             CMP      R0,#+197
   \   0000003C   0xD028             BEQ      ??FMSTR_ProtocolDecoder_10
   \   0000003E   0x28C9             CMP      R0,#+201
   \   00000040   0xD03D             BEQ      ??FMSTR_ProtocolDecoder_11
   \   00000042   0x28E6             CMP      R0,#+230
   \   00000044   0xD07B             BEQ      ??FMSTR_ProtocolDecoder_12
   \   00000046   0xE0A3             B        ??FMSTR_ProtocolDecoder_13
    105              {
    106          
    107          #if FMSTR_USE_READVAR
    108          
    109                  /* read byte */
    110          #if FMSTR_USE_EX_CMDS
    111                  case FMSTR_CMD_READVAR8_EX:
    112                      FMSTR_SetExAddr(FMSTR_TRUE);
    113          #endif
    114          #if FMSTR_USE_NOEX_CMDS
    115                  /*lint -fallthrough */
    116                  case FMSTR_CMD_READVAR8:
    117          #endif
    118                      pResponseEnd = FMSTR_ReadVar(pMessageIO, 1U);
    119                      break;
    120          
    121                  /* read word */
    122          #if FMSTR_USE_EX_CMDS
    123                  case FMSTR_CMD_READVAR16_EX:
    124                      FMSTR_SetExAddr(FMSTR_TRUE);
    125          #endif
    126          #if FMSTR_USE_NOEX_CMDS
    127                  /*lint -fallthrough */
    128                  case FMSTR_CMD_READVAR16:
    129          #endif
    130                      pResponseEnd = FMSTR_ReadVar(pMessageIO, 2U);
    131                      break;
    132          
    133                  /* read dword */
    134          #if FMSTR_USE_EX_CMDS
    135                  case FMSTR_CMD_READVAR32_EX:
    136                      FMSTR_SetExAddr(FMSTR_TRUE);
    137          #endif
    138          #if FMSTR_USE_NOEX_CMDS
    139                  /*lint -fallthrough */
    140                  case FMSTR_CMD_READVAR32:
    141          #endif
    142                      pResponseEnd = FMSTR_ReadVar(pMessageIO, 4U);
    143                      break;
    144          #endif /* FMSTR_USE_READVAR */
    145          
    146          #if FMSTR_USE_READMEM
    147          
    148                  /* read a block of memory */
    149          #if FMSTR_USE_EX_CMDS
    150                  case FMSTR_CMD_READMEM_EX:
    151                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_0: (+1)
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x.... 0x....      BL       FMSTR_SetExAddr
    152          #endif
    153          #if FMSTR_USE_NOEX_CMDS
    154                  /*lint -fallthrough */
    155                  case FMSTR_CMD_READMEM:
    156          #endif
    157                      pResponseEnd = FMSTR_ReadMem(pMessageIO);
   \   0000004E   0x78A5             LDRB     R5,[R4, #+2]
   \   00000050   0x1CE1             ADDS     R1,R4,#+3
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   00000058   0x2200             MOVS     R2,#+0
   \   0000005A   0x0029             MOVS     R1,R5
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD101             BNE      ??FMSTR_ProtocolDecoder_14
   \   00000066   0x2089             MOVS     R0,#+137
   \   00000068   0xE093             B        ??FMSTR_ProtocolDecoder_15
   \                     ??FMSTR_ProtocolDecoder_14: (+1)
   \   0000006A   0x2DC9             CMP      R5,#+201
   \   0000006C   0xDB01             BLT      ??FMSTR_ProtocolDecoder_16
   \   0000006E   0x2084             MOVS     R0,#+132
   \   00000070   0xE08F             B        ??FMSTR_ProtocolDecoder_15
   \                     ??FMSTR_ProtocolDecoder_16: (+1)
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x7020             STRB     R0,[R4, #+0]
   \   00000076   0x002A             MOVS     R2,R5
   \   00000078   0x9900             LDR      R1,[SP, #+0]
   \   0000007A   0x1C60             ADDS     R0,R4,#+1
   \   0000007C   0x.... 0x....      BL       FMSTR_CopyToBuffer
   \   00000080   0xE089             B        ??FMSTR_ProtocolDecoder_17
    158                      break;
    159          
    160          #endif /* FMSTR_USE_READMEM */
    161          
    162          #if FMSTR_USE_SCOPE
    163          
    164                  /* prepare scope variables */
    165          #if FMSTR_USE_EX_CMDS
    166                  case FMSTR_CMD_SETUPSCOPE_EX:
    167                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_3: (+1)
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x.... 0x....      BL       FMSTR_SetExAddr
    168          #endif
    169          #if FMSTR_USE_NOEX_CMDS
    170                  /*lint -fallthrough */
    171                  case FMSTR_CMD_SETUPSCOPE:
    172          #endif
    173                      pResponseEnd = FMSTR_SetUpScope(pMessageIO);
   \   00000088   0x0020             MOVS     R0,R4
   \   0000008A   0x.... 0x....      BL       FMSTR_SetUpScope
    174                      break;
   \   0000008E   0xE082             B        ??FMSTR_ProtocolDecoder_17
    175          
    176                  case FMSTR_CMD_READSCOPE:
    177                      pResponseEnd = FMSTR_ReadScope(pMessageIO);
   \                     ??FMSTR_ProtocolDecoder_10: (+1)
   \   00000090   0x0020             MOVS     R0,R4
   \   00000092   0x.... 0x....      BL       FMSTR_ReadScope
    178                      break;
   \   00000096   0xE07E             B        ??FMSTR_ProtocolDecoder_17
    179          #endif /* FMSTR_USE_SCOPE */
    180          
    181          #if FMSTR_USE_RECORDER
    182          
    183                  /* get recorder status */
    184                  case FMSTR_CMD_GETRECSTS:
    185                      pResponseEnd = FMSTR_GetRecStatus(pMessageIO);
   \                     ??FMSTR_ProtocolDecoder_9: (+1)
   \   00000098   0x0020             MOVS     R0,R4
   \   0000009A   0x.... 0x....      BL       FMSTR_GetRecStatus
    186                      break;
   \   0000009E   0xE07A             B        ??FMSTR_ProtocolDecoder_17
    187          
    188                  /* start recorder */
    189                  case FMSTR_CMD_STARTREC:
    190                      pResponseEnd = FMSTR_StartRec(pMessageIO);
   \                     ??FMSTR_ProtocolDecoder_7: (+1)
   \   000000A0   0x0020             MOVS     R0,R4
   \   000000A2   0x.... 0x....      BL       FMSTR_StartRec
    191                      break;
   \   000000A6   0xE076             B        ??FMSTR_ProtocolDecoder_17
    192          
    193                  /* stop recorder */
    194                  case FMSTR_CMD_STOPREC:
    195                      pResponseEnd = FMSTR_StopRec(pMessageIO);
   \                     ??FMSTR_ProtocolDecoder_8: (+1)
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       FMSTR_StopRec
    196                      break;
   \   000000AE   0xE072             B        ??FMSTR_ProtocolDecoder_17
    197          
    198                  /* setup recorder */
    199          #if FMSTR_USE_EX_CMDS
    200                  case FMSTR_CMD_SETUPREC_EX:
    201                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_4: (+1)
   \   000000B0   0x2001             MOVS     R0,#+1
   \   000000B2   0x.... 0x....      BL       FMSTR_SetExAddr
    202          #endif
    203          #if FMSTR_USE_NOEX_CMDS
    204                  /*lint -fallthrough */
    205                  case FMSTR_CMD_SETUPREC:
    206          #endif
    207                      pResponseEnd = FMSTR_SetUpRec(pMessageIO);
   \   000000B6   0x0020             MOVS     R0,R4
   \   000000B8   0x.... 0x....      BL       FMSTR_SetUpRec
    208                      break;
   \   000000BC   0xE06B             B        ??FMSTR_ProtocolDecoder_17
    209          
    210                  /* get recorder buffer information (force EX instead of non-EX) */
    211          #if FMSTR_USE_EX_CMDS
    212                  case FMSTR_CMD_GETRECBUFF_EX:
    213                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_11: (+1)
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x.... 0x....      BL       FMSTR_SetExAddr
    214          #elif FMSTR_USE_NOEX_CMDS
    215                  /*lint -fallthrough */
    216                  case FMSTR_CMD_GETRECBUFF:
    217          #endif
    218                      pResponseEnd = FMSTR_GetRecBuff(pMessageIO);
   \   000000C4   0x0020             MOVS     R0,R4
   \   000000C6   0x.... 0x....      BL       FMSTR_GetRecBuff
    219                      break;
   \   000000CA   0xE064             B        ??FMSTR_ProtocolDecoder_17
    220          #endif /* FMSTR_USE_RECORDER */
    221          
    222          #if FMSTR_USE_APPCMD
    223          
    224                  /* accept the application command */
    225                  case FMSTR_CMD_SENDAPPCMD:
    226                      pResponseEnd = FMSTR_StoreAppCmd(pMessageIO);
    227                      break;
    228          
    229                  /* get the application command status */
    230                  case FMSTR_CMD_GETAPPCMDSTS:
    231                      pResponseEnd = FMSTR_GetAppCmdStatus(pMessageIO);
    232                      break;
    233          
    234                  /* get the application command data */
    235                  case FMSTR_CMD_GETAPPCMDDATA:
    236                      pResponseEnd = FMSTR_GetAppCmdRespData(pMessageIO);
    237                      break;
    238          #endif /* FMSTR_USE_APPCMD */
    239          
    240          #if FMSTR_USE_WRITEMEM
    241          
    242                  /* write a block of memory */
    243          #if FMSTR_USE_EX_CMDS
    244                  case FMSTR_CMD_WRITEMEM_EX:
    245                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_1: (+1)
   \   000000CC   0x2001             MOVS     R0,#+1
   \   000000CE   0x.... 0x....      BL       FMSTR_SetExAddr
    246          #endif
    247          #if FMSTR_USE_NOEX_CMDS
    248                  /*lint -fallthrough */
    249                  case FMSTR_CMD_WRITEMEM:
    250          #endif
    251                      pResponseEnd = FMSTR_WriteMem(pMessageIO);
   \   000000D2   0x78A6             LDRB     R6,[R4, #+2]
   \   000000D4   0x1CE1             ADDS     R1,R4,#+3
   \   000000D6   0x4668             MOV      R0,SP
   \   000000D8   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   000000DC   0x0005             MOVS     R5,R0
   \   000000DE   0x2201             MOVS     R2,#+1
   \   000000E0   0x0031             MOVS     R1,R6
   \   000000E2   0x9800             LDR      R0,[SP, #+0]
   \   000000E4   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD101             BNE      ??FMSTR_ProtocolDecoder_18
   \   000000EC   0x2089             MOVS     R0,#+137
   \   000000EE   0xE050             B        ??FMSTR_ProtocolDecoder_15
   \                     ??FMSTR_ProtocolDecoder_18: (+1)
   \   000000F0   0x0032             MOVS     R2,R6
   \   000000F2   0x0029             MOVS     R1,R5
   \   000000F4   0x9800             LDR      R0,[SP, #+0]
   \   000000F6   0x.... 0x....      BL       FMSTR_CopyFromBuffer
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0xE049             B        ??FMSTR_ProtocolDecoder_15
    252                      break;
    253          #endif /* FMSTR_USE_WRITEMEM */
    254          
    255          #if FMSTR_USE_WRITEMEMMASK
    256          
    257                  /* write block of memory with a bit mask */
    258          #if FMSTR_USE_EX_CMDS
    259                  case FMSTR_CMD_WRITEMEMMASK_EX:
    260                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_2: (+1)
   \   000000FE   0x2001             MOVS     R0,#+1
   \   00000100   0x.... 0x....      BL       FMSTR_SetExAddr
    261          #endif
    262          #if FMSTR_USE_NOEX_CMDS
    263                  /*lint -fallthrough */
    264                  case FMSTR_CMD_WRITEMEMMASK:
    265          #endif
    266                      pResponseEnd = FMSTR_WriteMemMask(pMessageIO);
   \   00000104   0x78A6             LDRB     R6,[R4, #+2]
   \   00000106   0x1CE1             ADDS     R1,R4,#+3
   \   00000108   0x4668             MOV      R0,SP
   \   0000010A   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   0000010E   0x0005             MOVS     R5,R0
   \   00000110   0x2201             MOVS     R2,#+1
   \   00000112   0x0031             MOVS     R1,R6
   \   00000114   0x9800             LDR      R0,[SP, #+0]
   \   00000116   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD101             BNE      ??FMSTR_ProtocolDecoder_19
   \   0000011E   0x2089             MOVS     R0,#+137
   \   00000120   0xE037             B        ??FMSTR_ProtocolDecoder_15
   \                     ??FMSTR_ProtocolDecoder_19: (+1)
   \   00000122   0x0032             MOVS     R2,R6
   \   00000124   0x0029             MOVS     R1,R5
   \   00000126   0x9800             LDR      R0,[SP, #+0]
   \   00000128   0x.... 0x....      BL       FMSTR_CopyFromBufferWithMask
   \   0000012C   0x2000             MOVS     R0,#+0
   \   0000012E   0xE030             B        ??FMSTR_ProtocolDecoder_15
    267                      break;
    268          #endif /* FMSTR_USE_WRITEMEMMASK */
    269          
    270          #if FMSTR_USE_WRITEVAR && FMSTR_USE_NOEX_CMDS
    271          
    272                  /* write byte */
    273                  case FMSTR_CMD_WRITEVAR8:
    274                      pResponseEnd = FMSTR_WriteVar(pMessageIO, 1U);
    275                      break;
    276          
    277                  /* write word */
    278                  case FMSTR_CMD_WRITEVAR16:
    279                      pResponseEnd = FMSTR_WriteVar(pMessageIO, 2U);
    280                      break;
    281          
    282                  /* write dword */
    283                  case FMSTR_CMD_WRITEVAR32:
    284                      pResponseEnd = FMSTR_WriteVar(pMessageIO, 4U);
    285                      break;
    286          #endif /* FMSTR_USE_WRITEVAR && FMSTR_USE_NOEX_CMDS */
    287          
    288          #if FMSTR_USE_WRITEVARMASK && FMSTR_USE_NOEX_CMDS
    289          
    290                  /* write byte with mask */
    291                  case FMSTR_CMD_WRITEVAR8MASK:
    292                      pResponseEnd = FMSTR_WriteVarMask(pMessageIO, 1U);
    293                      break;
    294          
    295                  /* write word with mask */
    296                  case FMSTR_CMD_WRITEVAR16MASK:
    297                      pResponseEnd = FMSTR_WriteVarMask(pMessageIO, 2U);
    298                      break;
    299          
    300          #endif /* FMSTR_USE_WRITEVARMASK && FMSTR_USE_NOEX_CMDS */
    301          
    302          #if FMSTR_USE_TSA
    303          
    304                  /* get TSA table (force EX instead of non-EX) */
    305          #if FMSTR_USE_EX_CMDS
    306                  case FMSTR_CMD_GETTSAINFO_EX:
    307                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_5: (+1)
   \   00000130   0x2001             MOVS     R0,#+1
   \   00000132   0x.... 0x....      BL       FMSTR_SetExAddr
    308          #elif FMSTR_USE_NOEX_CMDS
    309                  /*lint -fallthrough */
    310                  case FMSTR_CMD_GETTSAINFO:
    311          #endif
    312                      pResponseEnd = FMSTR_GetTsaInfo(pMessageIO);
   \   00000136   0x0020             MOVS     R0,R4
   \   00000138   0x.... 0x....      BL       FMSTR_GetTsaInfo
    313                      break;
   \   0000013C   0xE02B             B        ??FMSTR_ProtocolDecoder_17
    314          
    315          #if FMSTR_USE_EX_CMDS
    316                  case FMSTR_CMD_GETSTRLEN_EX:
    317                      FMSTR_SetExAddr(FMSTR_TRUE);
   \                     ??FMSTR_ProtocolDecoder_12: (+1)
   \   0000013E   0x2001             MOVS     R0,#+1
   \   00000140   0x.... 0x....      BL       FMSTR_SetExAddr
    318          #endif
    319          #if FMSTR_USE_NOEX_CMDS
    320                  /*lint -fallthrough */
    321                  case FMSTR_CMD_GETSTRLEN:
    322          #endif
    323                      pResponseEnd = FMSTR_GetStringLen(pMessageIO);
   \   00000144   0x0020             MOVS     R0,R4
   \   00000146   0x.... 0x....      BL       FMSTR_GetStringLen
    324                      break;
   \   0000014A   0xE024             B        ??FMSTR_ProtocolDecoder_17
    325          
    326          #endif /* FMSTR_USE_TSA */
    327          
    328          #if FMSTR_USE_BRIEFINFO
    329                  /* retrieve a subset of board information structure */
    330                  case FMSTR_CMD_GETINFOBRIEF:
    331          #else
    332                  /* retrieve board information structure */
    333                  case FMSTR_CMD_GETINFO:
    334          #endif
    335                      pResponseEnd = FMSTR_GetBoardInfo(pMessageIO);
   \                     ??FMSTR_ProtocolDecoder_6: (+1)
   \   0000014C   0x2000             MOVS     R0,#+0
   \   0000014E   0x7020             STRB     R0,[R4, #+0]
   \   00000150   0x2103             MOVS     R1,#+3
   \   00000152   0x7061             STRB     R1,[R4, #+1]
   \   00000154   0x70A0             STRB     R0,[R4, #+2]
   \   00000156   0x2101             MOVS     R1,#+1
   \   00000158   0x70E1             STRB     R1,[R4, #+3]
   \   0000015A   0x2102             MOVS     R1,#+2
   \   0000015C   0x7121             STRB     R1,[R4, #+4]
   \   0000015E   0x7160             STRB     R0,[R4, #+5]
   \   00000160   0x20C8             MOVS     R0,#+200
   \   00000162   0x71A0             STRB     R0,[R4, #+6]
   \   00000164   0x.... 0x....      BL       FMSTR_GetRecBuffSize
   \   00000168   0x0001             MOVS     R1,R0
   \   0000016A   0x1DE0             ADDS     R0,R4,#+7
   \   0000016C   0x.... 0x....      BL       FMSTR_ValueToBuffer16
   \   00000170   0x2180             MOVS     R1,#+128
   \   00000172   0x01C9             LSLS     R1,R1,#+7        ;; #+16384
   \   00000174   0x.... 0x....      BL       FMSTR_ValueToBuffer16
   \   00000178   0x....             ADR.N    R1,?_0
   \   0000017A   0x2219             MOVS     R2,#+25
   \                     ??FMSTR_ProtocolDecoder_20: (+1)
   \   0000017C   0x780B             LDRB     R3,[R1, #+0]
   \   0000017E   0x7003             STRB     R3,[R0, #+0]
   \   00000180   0x1C40             ADDS     R0,R0,#+1
   \   00000182   0x780B             LDRB     R3,[R1, #+0]
   \   00000184   0x2B00             CMP      R3,#+0
   \   00000186   0xD000             BEQ      ??FMSTR_ProtocolDecoder_21
   \   00000188   0x1C49             ADDS     R1,R1,#+1
   \                     ??FMSTR_ProtocolDecoder_21: (+1)
   \   0000018A   0x1E52             SUBS     R2,R2,#+1
   \   0000018C   0xD1F6             BNE      ??FMSTR_ProtocolDecoder_20
    336                      break;
   \   0000018E   0xE002             B        ??FMSTR_ProtocolDecoder_17
    337          
    338          #if FMSTR_USE_SFIO
    339                  case FMSTR_CMD_SFIOFRAME_0:
    340                  case FMSTR_CMD_SFIOFRAME_1:
    341                      pResponseEnd = FMSTR_SfioFrame(pMessageIO);
    342                      break;
    343                  case FMSTR_CMD_SFIOGETRESP_0:
    344                  case FMSTR_CMD_SFIOGETRESP_1:
    345                      pResponseEnd = FMSTR_SfioGetResp(pMessageIO);
    346                      break;
    347          #endif /* FMSTR_USE_SFIO */
    348          
    349          #if FMSTR_USE_PIPES
    350                  case FMSTR_CMD_PIPE:
    351                      pResponseEnd = FMSTR_PipeFrame(pMessageIO);
    352                      break;
    353          #endif /* FMSTR_USE_PIPES */
    354          
    355                  /* unknown command */
    356                  default:
    357                      pResponseEnd = FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STC_INVCMD);
   \                     ??FMSTR_ProtocolDecoder_13: (+1)
   \   00000190   0x2081             MOVS     R0,#+129
   \                     ??FMSTR_ProtocolDecoder_15: (+1)
   \   00000192   0x7020             STRB     R0,[R4, #+0]
   \   00000194   0x1C60             ADDS     R0,R4,#+1
    358                      break;
    359              }
    360          
    361              /* anything to send back? */
    362              if(pResponseEnd != pMessageIO)
   \                     ??FMSTR_ProtocolDecoder_17: (+1)
   \   00000196   0x42A0             CMP      R0,R4
   \   00000198   0xD006             BEQ      ??FMSTR_ProtocolDecoder_22
    363              {
    364                  /*lint -e{946,960} subtracting pointers is appropriate here */
    365                  FMSTR_SIZE8 nSize = (FMSTR_SIZE8)(pResponseEnd - pMessageIO);
    366                  FMSTR_SendResponse(pMessageIO, nSize);
   \   0000019A   0x1B01             SUBS     R1,R0,R4
   \   0000019C   0xB2C9             UXTB     R1,R1
   \   0000019E   0x0020             MOVS     R0,R4
   \   000001A0   0x.... 0x....      BL       FMSTR_SendResponse
    367                  return FMSTR_TRUE;
   \   000001A4   0x2001             MOVS     R0,#+1
   \   000001A6   0xE000             B        ??FMSTR_ProtocolDecoder_23
    368              }
    369              else
    370              {
    371                  /* nothing sent out */
    372                  return FMSTR_FALSE;
   \                     ??FMSTR_ProtocolDecoder_22: (+1)
   \   000001A8   0x2000             MOVS     R0,#+0
   \                     ??FMSTR_ProtocolDecoder_23: (+1)
   \   000001AA   0xB002             ADD      SP,SP,#+8
   \   000001AC   0xBD70             POP      {R4-R6,PC}       ;; return
    373              }
    374          }
    375          
    376          /**************************************************************************//*!
    377          *
    378          * @brief    Handling GETINFO or GETINFO_BRIEF
    379          *
    380          * @param    pMessageIO - original command (in) and response buffer (out)
    381          *
    382          * @return   As all command handlers, the return value should be the buffer
    383          *           pointer where the response output finished (except checksum)
    384          *
    385          ******************************************************************************/
    386          

   \                                 In section .text, align 4, keep-with-next
    387          FMSTR_BPTR FMSTR_GetBoardInfo(FMSTR_BPTR pMessageIO)
    388          {
   \                     FMSTR_GetBoardInfo: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    389              FMSTR_BPTR pResponse = pMessageIO;
    390              FMSTR_U16 wTmp;
    391              FMSTR_U8 *pStr;
    392          
    393              pResponse = FMSTR_ConstToBuffer8(pResponse, FMSTR_STS_OK);
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x7020             STRB     R0,[R4, #+0]
    394              pResponse = FMSTR_ConstToBuffer8(pResponse, (FMSTR_U8)(FMSTR_PROT_VER));            /* protVer */
   \   00000008   0x2103             MOVS     R1,#+3
   \   0000000A   0x7061             STRB     R1,[R4, #+1]
    395              pResponse = FMSTR_ConstToBuffer8(pResponse, (FMSTR_U8)(FMSTR_CFG_FLAGS));           /* cfgFlags */
   \   0000000C   0x70A0             STRB     R0,[R4, #+2]
    396              pResponse = FMSTR_ConstToBuffer8(pResponse, (FMSTR_U8)(FMSTR_CFG_BUS_WIDTH));       /* dataBusWdt */
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0x70E1             STRB     R1,[R4, #+3]
    397              pResponse = FMSTR_ConstToBuffer8(pResponse, (FMSTR_U8)(FMSTR_GLOB_VERSION_MAJOR));  /* globVerMajor */
   \   00000012   0x2102             MOVS     R1,#+2
   \   00000014   0x7121             STRB     R1,[R4, #+4]
    398              pResponse = FMSTR_ConstToBuffer8(pResponse, (FMSTR_U8)(FMSTR_GLOB_VERSION_MINOR));  /* globVerMinor */
   \   00000016   0x7160             STRB     R0,[R4, #+5]
    399              pResponse = FMSTR_ConstToBuffer8(pResponse, (FMSTR_U8)(FMSTR_COMM_BUFFER_SIZE));    /* cmdBuffSize  */
   \   00000018   0x20C8             MOVS     R0,#+200
   \   0000001A   0x71A0             STRB     R0,[R4, #+6]
    400          
    401              /* that is all for brief info */
    402          #if FMSTR_USE_BRIEFINFO
    403              FMSTR_UNUSED(pStr);
    404              FMSTR_UNUSED(wTmp);
    405          
    406          #else /* FMSTR_USE_BRIEFINFO */
    407          
    408          #if FMSTR_USE_RECORDER
    409          
    410              /* recorder buffer size is always measured in bytes */
    411          #if FMSTR_REC_LARGE_MODE
    412              wTmp = FMSTR_GetRecBuffSize()/64;
    413          #else
    414              wTmp = FMSTR_GetRecBuffSize();
   \   0000001C   0x.... 0x....      BL       FMSTR_GetRecBuffSize
    415          #endif
    416              wTmp *= FMSTR_CFG_BUS_WIDTH;
    417          
    418              /* send size and timebase    */
    419              pResponse = FMSTR_ValueToBuffer16(pResponse, wTmp);
   \   00000020   0x0001             MOVS     R1,R0
   \   00000022   0x1DE0             ADDS     R0,R4,#+7
   \   00000024   0x.... 0x....      BL       FMSTR_ValueToBuffer16
    420              pResponse = FMSTR_ConstToBuffer16(pResponse, (FMSTR_U16) FMSTR_REC_TIMEBASE);
   \   00000028   0x2180             MOVS     R1,#+128
   \   0000002A   0x01C9             LSLS     R1,R1,#+7        ;; #+16384
   \   0000002C   0x.... 0x....      BL       FMSTR_ValueToBuffer16
    421          #else /* FMSTR_USE_RECORDER */
    422          
    423              FMSTR_UNUSED(wTmp);
    424          
    425              /* recorder info zeroed */
    426              pResponse = FMSTR_ConstToBuffer16(pResponse, 0);
    427              pResponse = FMSTR_ConstToBuffer16(pResponse, 0);
    428          #endif /* FMSTR_USE_RECORDER */
    429          
    430          #if FMSTR_LIGHT_VERSION
    431          FMSTR_UNUSED(pStr);
    432              pResponse = FMSTR_SkipInBuffer(pResponse, (FMSTR_U8)FMSTR_DESCR_SIZE);
    433          #else
    434              /* description string */
    435              pStr = (FMSTR_U8*)  FMSTR_IDT_STRING;
   \   00000030   0x....             ADR.N    R1,?_0
    436              for(wTmp = 0U; wTmp < (FMSTR_U8)(FMSTR_DESCR_SIZE); wTmp++)
   \   00000032   0x2219             MOVS     R2,#+25
    437              {
    438                  pResponse = FMSTR_ValueToBuffer8(pResponse, *pStr);
   \                     ??FMSTR_GetBoardInfo_0: (+1)
   \   00000034   0x780B             LDRB     R3,[R1, #+0]
   \   00000036   0x7003             STRB     R3,[R0, #+0]
   \   00000038   0x1C40             ADDS     R0,R0,#+1
    439          
    440                  /* terminating zero used to clear the remainder of the buffer */
    441                  if(*pStr)
   \   0000003A   0x780B             LDRB     R3,[R1, #+0]
   \   0000003C   0x2B00             CMP      R3,#+0
   \   0000003E   0xD000             BEQ      ??FMSTR_GetBoardInfo_1
    442                  {
    443                      pStr ++;
   \   00000040   0x1C49             ADDS     R1,R1,#+1
    444                  }
    445              }
   \                     ??FMSTR_GetBoardInfo_1: (+1)
   \   00000042   0x1E52             SUBS     R2,R2,#+1
   \   00000044   0xD1F6             BNE      ??FMSTR_GetBoardInfo_0
    446          #endif /* SEND_IDT_STRING */
    447          
    448          #endif /* FMSTR_USE_BRIEFINFO */
    449          
    450              return pResponse;
   \   00000046   0xBD10             POP      {R4,PC}          ;; return
    451          }
    452          
    453          /**************************************************************************//*!
    454          *
    455          * @brief    Handling READMEM and READMEM_EX commands
    456          *
    457          * @param    pMessageIO - original command (in) and response buffer (out)
    458          *
    459          * @return   As all command handlers, the return value should be the buffer
    460          *           pointer where the response output finished (except checksum)
    461          *
    462          ******************************************************************************/
    463          

   \                                 In section .text, align 2, keep-with-next
    464          FMSTR_BPTR FMSTR_ReadMem(FMSTR_BPTR pMessageIO)
    465          {
   \                     FMSTR_ReadMem: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    466              FMSTR_BPTR pResponse = pMessageIO;
   \   00000004   0x0004             MOVS     R4,R0
    467              FMSTR_ADDR nAddr;
    468              FMSTR_U8 nSize;
    469          
    470              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    471              pMessageIO = FMSTR_ValueFromBuffer8(&nSize, pMessageIO);
   \   00000006   0x7885             LDRB     R5,[R0, #+2]
    472              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000008   0x1CC1             ADDS     R1,R0,#+3
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       FMSTR_AddressFromBuffer
    473          
    474          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    475              if(!FMSTR_CheckTsaSpace(nAddr, (FMSTR_SIZE8) nSize, FMSTR_FALSE))
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD101             BNE      ??FMSTR_ReadMem_0
    476              {
    477                  return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_EACCESS);
   \   0000001E   0x2089             MOVS     R0,#+137
   \   00000020   0xE002             B.N      ??FMSTR_ReadMem_1
    478              }
    479          #endif
    480          
    481              /* check the response will safely fit into comm buffer */
    482              if(nSize > (FMSTR_U8)FMSTR_COMM_BUFFER_SIZE)
   \                     ??FMSTR_ReadMem_0: (+1)
   \   00000022   0x2DC9             CMP      R5,#+201
   \   00000024   0xDB03             BLT      ??FMSTR_ReadMem_2
    483              {
    484                  return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_RSPBUFFOVF);
   \   00000026   0x2084             MOVS     R0,#+132
   \                     ??FMSTR_ReadMem_1: (+1)
   \   00000028   0x7020             STRB     R0,[R4, #+0]
   \   0000002A   0x1C60             ADDS     R0,R4,#+1
   \   0000002C   0xE006             B        ??FMSTR_ReadMem_3
    485              }
    486          
    487              /* success  */
    488              pResponse = FMSTR_ConstToBuffer8(pResponse, FMSTR_STS_OK);
   \                     ??FMSTR_ReadMem_2: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0x7020             STRB     R0,[R4, #+0]
   \   00000032   0x1C60             ADDS     R0,R4,#+1
    489          
    490              return FMSTR_CopyToBuffer(pResponse, nAddr, (FMSTR_SIZE8) nSize);
   \   00000034   0x002A             MOVS     R2,R5
   \   00000036   0x9900             LDR      R1,[SP, #+0]
   \   00000038   0x.... 0x....      BL       FMSTR_CopyToBuffer
   \                     ??FMSTR_ReadMem_3: (+1)
   \   0000003C   0xB001             ADD      SP,SP,#+4
   \   0000003E   0xBD30             POP      {R4,R5,PC}       ;; return
    491          }
    492          
    493          /**************************************************************************//*!
    494          *
    495          * @brief    Handling READVAR and READVAR_EX commands (for all sizes 1,2,4)
    496          *
    497          * @param    pMessageIO - original command (in) and response buffer (out)
    498          *
    499          * @return   As all command handlers, the return value should be the buffer
    500          *           pointer where the response output finished (except checksum)
    501          *
    502          ******************************************************************************/
    503          

   \                                 In section .text, align 2, keep-with-next
    504          FMSTR_BPTR FMSTR_ReadVar(FMSTR_BPTR pMessageIO, FMSTR_SIZE8 nSize)
    505          {
   \                     FMSTR_ReadVar: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    506              FMSTR_BPTR pResponse = pMessageIO;
    507              FMSTR_ADDR nAddr;
    508          
    509              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 1U);
    510              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000008   0x1C61             ADDS     R1,R4,#+1
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       FMSTR_AddressFromBuffer
    511          
    512          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    513              if(!FMSTR_CheckTsaSpace(nAddr, nSize, FMSTR_FALSE))
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x0029             MOVS     R1,R5
   \   00000014   0x9800             LDR      R0,[SP, #+0]
   \   00000016   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD103             BNE      ??FMSTR_ReadVar_0
    514              {
    515                  return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_EACCESS);
   \   0000001E   0x2089             MOVS     R0,#+137
   \   00000020   0x7020             STRB     R0,[R4, #+0]
   \   00000022   0x1C60             ADDS     R0,R4,#+1
   \   00000024   0xE006             B        ??FMSTR_ReadVar_1
    516              }
    517          #endif
    518          
    519              /* success  */
    520              pResponse = FMSTR_ConstToBuffer8(pResponse, FMSTR_STS_OK);
   \                     ??FMSTR_ReadVar_0: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x7020             STRB     R0,[R4, #+0]
    521          
    522              return FMSTR_CopyToBuffer(pResponse, nAddr, nSize);
   \   0000002A   0x002A             MOVS     R2,R5
   \   0000002C   0x9900             LDR      R1,[SP, #+0]
   \   0000002E   0x1C60             ADDS     R0,R4,#+1
   \   00000030   0x.... 0x....      BL       FMSTR_CopyToBuffer
   \                     ??FMSTR_ReadVar_1: (+1)
   \   00000034   0xB001             ADD      SP,SP,#+4
   \   00000036   0xBD30             POP      {R4,R5,PC}       ;; return
    523          }
    524          
    525          /**************************************************************************//*!
    526          *
    527          * @brief    Handling WRITEMEM and WRITEMEM_EX commands
    528          *
    529          * @param    pMessageIO - original command (in) and response buffer (out)
    530          *
    531          * @return   As all command handlers, the return value should be the buffer
    532          *           pointer where the response output finished (except checksum)
    533          *
    534          ******************************************************************************/
    535          

   \                                 In section .text, align 2, keep-with-next
    536          FMSTR_BPTR FMSTR_WriteMem(FMSTR_BPTR pMessageIO)
    537          {
   \                     FMSTR_WriteMem: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    538              FMSTR_BPTR pResponse = pMessageIO;
   \   00000004   0x0005             MOVS     R5,R0
    539              FMSTR_ADDR nAddr;
    540              FMSTR_U8 nSize,nResponseCode;
    541          
    542              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    543              pMessageIO = FMSTR_ValueFromBuffer8(&nSize, pMessageIO);
   \   00000006   0x7886             LDRB     R6,[R0, #+2]
    544              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000008   0x1CC1             ADDS     R1,R0,#+3
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   00000010   0x0004             MOVS     R4,R0
    545          
    546          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    547              if(!FMSTR_CheckTsaSpace(nAddr, (FMSTR_SIZE8) nSize, FMSTR_TRUE))
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x0031             MOVS     R1,R6
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD101             BNE      ??FMSTR_WriteMem_0
    548              {
    549                  nResponseCode = FMSTR_STC_EACCESS;
   \   00000020   0x2089             MOVS     R0,#+137
    550                  goto FMSTR_WriteMem_exit;
   \   00000022   0xE005             B        ??FMSTR_WriteMem_1
    551              }
    552          #endif
    553          
    554              /*lint -e{534} ignoring function return value */
    555              FMSTR_CopyFromBuffer(nAddr, pMessageIO, (FMSTR_SIZE8) nSize);
   \                     ??FMSTR_WriteMem_0: (+1)
   \   00000024   0x0032             MOVS     R2,R6
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x.... 0x....      BL       FMSTR_CopyFromBuffer
    556              nResponseCode = FMSTR_STS_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
    557          
    558          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    559          FMSTR_WriteMem_exit:
    560          #endif
    561          
    562              return FMSTR_ConstToBuffer8(pResponse, nResponseCode);
   \                     ??FMSTR_WriteMem_1: (+1)
   \   00000030   0x7028             STRB     R0,[R5, #+0]
   \   00000032   0x1C68             ADDS     R0,R5,#+1
   \   00000034   0xB002             ADD      SP,SP,#+8
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    563          }
    564          
    565          /**************************************************************************//*!
    566          *
    567          * @brief    Handling WRITEVAR command
    568          *
    569          * @param    pMessageIO - original command (in) and response buffer (out)
    570          * @param    nSize - variable size
    571          *
    572          * @return   As all command handlers, the return value should be the buffer
    573          *           pointer where the response output finished (except checksum)
    574          *
    575          ******************************************************************************/
    576          

   \                                 In section .text, align 2, keep-with-next
    577          FMSTR_BPTR FMSTR_WriteVar(FMSTR_BPTR pMessageIO, FMSTR_SIZE8 nSize)
    578          {
   \                     FMSTR_WriteVar: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x000C             MOVS     R4,R1
    579              FMSTR_BPTR pResponse = pMessageIO;
   \   00000006   0x0006             MOVS     R6,R0
    580              FMSTR_ADDR nAddr;
    581              FMSTR_U8 nResponseCode;
    582          
    583              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 1U);
    584              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000008   0x1C41             ADDS     R1,R0,#+1
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   00000010   0x0005             MOVS     R5,R0
    585          
    586          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    587              if(!FMSTR_CheckTsaSpace(nAddr, nSize, FMSTR_TRUE))
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD101             BNE      ??FMSTR_WriteVar_0
    588              {
    589                  nResponseCode = FMSTR_STC_EACCESS;
   \   00000020   0x2089             MOVS     R0,#+137
    590                  goto FMSTR_WriteVar_exit;
   \   00000022   0xE005             B        ??FMSTR_WriteVar_1
    591              }
    592          #endif
    593          
    594              /*lint -e{534} ignoring function return value */
    595              FMSTR_CopyFromBuffer(nAddr, pMessageIO, nSize);
   \                     ??FMSTR_WriteVar_0: (+1)
   \   00000024   0x0022             MOVS     R2,R4
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x.... 0x....      BL       FMSTR_CopyFromBuffer
    596              nResponseCode = FMSTR_STS_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
    597          
    598          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    599          FMSTR_WriteVar_exit:
    600          #endif
    601          
    602              return FMSTR_ConstToBuffer8(pResponse, nResponseCode);
   \                     ??FMSTR_WriteVar_1: (+1)
   \   00000030   0x7030             STRB     R0,[R6, #+0]
   \   00000032   0x1C70             ADDS     R0,R6,#+1
   \   00000034   0xB002             ADD      SP,SP,#+8
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    603          }
    604          
    605          
    606          /**************************************************************************//*!
    607          *
    608          * @brief    Handling WRITEMEMMASK and WRITEMEMMASK_EX commands
    609          *
    610          * @param    pMessageIO - original command (in) and response buffer (out)
    611          *
    612          * @return   As all command handlers, the return value should be the buffer
    613          *           pointer where the response output finished (except checksum)
    614          *
    615          ******************************************************************************/
    616          

   \                                 In section .text, align 2, keep-with-next
    617          FMSTR_BPTR FMSTR_WriteMemMask(FMSTR_BPTR pMessageIO)
    618          {
   \                     FMSTR_WriteMemMask: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    619              FMSTR_BPTR pResponse = pMessageIO;
   \   00000004   0x0005             MOVS     R5,R0
    620              FMSTR_ADDR nAddr;
    621              FMSTR_U8 nSize,nResponseCode;
    622          
    623              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    624              pMessageIO = FMSTR_ValueFromBuffer8(&nSize, pMessageIO);
   \   00000006   0x7886             LDRB     R6,[R0, #+2]
    625              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000008   0x1CC1             ADDS     R1,R0,#+3
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   00000010   0x0004             MOVS     R4,R0
    626          
    627          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    628              if(!FMSTR_CheckTsaSpace(nAddr, (FMSTR_SIZE8)nSize, FMSTR_TRUE))
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x0031             MOVS     R1,R6
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD101             BNE      ??FMSTR_WriteMemMask_0
    629              {
    630                  nResponseCode = FMSTR_STC_EACCESS;
   \   00000020   0x2089             MOVS     R0,#+137
    631                  goto FMSTR_WriteMemMask_exit;
   \   00000022   0xE005             B        ??FMSTR_WriteMemMask_1
    632              }
    633          #endif
    634          
    635          #if FMSTR_CFG_BUS_WIDTH > 1U
    636              /* size must be divisible by bus width (mask must not begin in half of memory word) */
    637              if(nSize % FMSTR_CFG_BUS_WIDTH)
    638              {
    639                  nResponseCode = FMSTR_STC_INVSIZE;
    640                  goto FMSTR_WriteMemMask_exit;
    641              }
    642          #endif
    643          
    644              /* put the data */
    645              FMSTR_CopyFromBufferWithMask(nAddr, pMessageIO, (FMSTR_SIZE8)nSize);
   \                     ??FMSTR_WriteMemMask_0: (+1)
   \   00000024   0x0032             MOVS     R2,R6
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x.... 0x....      BL       FMSTR_CopyFromBufferWithMask
    646              nResponseCode = FMSTR_STS_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
    647          
    648          #if (FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY) || (FMSTR_CFG_BUS_WIDTH > 1U)
    649          FMSTR_WriteMemMask_exit:
    650          #endif
    651          
    652              return FMSTR_ConstToBuffer8(pResponse, nResponseCode);
   \                     ??FMSTR_WriteMemMask_1: (+1)
   \   00000030   0x7028             STRB     R0,[R5, #+0]
   \   00000032   0x1C68             ADDS     R0,R5,#+1
   \   00000034   0xB002             ADD      SP,SP,#+8
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    653          }
    654          
    655          /**************************************************************************//*!
    656          *
    657          * @brief    Handling WRITEVARMASK command
    658          *
    659          * @param    pMessageIO - original command (in) and response buffer (out)
    660          * @param    nSize - variable size
    661          *
    662          * @return   As all command handlers, the return value should be the buffer
    663          *           pointer where the response output finished (except checksum)
    664          *
    665          ******************************************************************************/
    666          

   \                                 In section .text, align 2, keep-with-next
    667          FMSTR_BPTR FMSTR_WriteVarMask(FMSTR_BPTR pMessageIO, FMSTR_SIZE8 nSize)
    668          {
   \                     FMSTR_WriteVarMask: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x000C             MOVS     R4,R1
    669              FMSTR_BPTR pResponse = pMessageIO;
   \   00000006   0x0006             MOVS     R6,R0
    670              FMSTR_ADDR nAddr;
    671              FMSTR_U8 nResponseCode;
    672          
    673              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 1U);
    674              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000008   0x1C41             ADDS     R1,R0,#+1
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   00000010   0x0005             MOVS     R5,R0
    675          
    676          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    677              if(!FMSTR_CheckTsaSpace(nAddr, nSize, FMSTR_TRUE))
   \   00000012   0x2201             MOVS     R2,#+1
   \   00000014   0x0021             MOVS     R1,R4
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x.... 0x....      BL       FMSTR_CheckTsaSpace
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD101             BNE      ??FMSTR_WriteVarMask_0
    678              {
    679                  nResponseCode = FMSTR_STC_EACCESS;
   \   00000020   0x2089             MOVS     R0,#+137
    680                  goto FMSTR_WriteVarMask_exit;
   \   00000022   0xE005             B        ??FMSTR_WriteVarMask_1
    681              }
    682          #endif
    683          
    684              /* put the data */
    685              FMSTR_CopyFromBufferWithMask(nAddr, pMessageIO, nSize);
   \                     ??FMSTR_WriteVarMask_0: (+1)
   \   00000024   0x0022             MOVS     R2,R4
   \   00000026   0x0029             MOVS     R1,R5
   \   00000028   0x9800             LDR      R0,[SP, #+0]
   \   0000002A   0x.... 0x....      BL       FMSTR_CopyFromBufferWithMask
    686              nResponseCode = FMSTR_STS_OK;
   \   0000002E   0x2000             MOVS     R0,#+0
    687          
    688          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    689          FMSTR_WriteVarMask_exit:
    690          #endif
    691          
    692              return FMSTR_ConstToBuffer8(pResponse, nResponseCode);
   \                     ??FMSTR_WriteVarMask_1: (+1)
   \   00000030   0x7030             STRB     R0,[R6, #+0]
   \   00000032   0x1C70             ADDS     R0,R6,#+1
   \   00000034   0xB002             ADD      SP,SP,#+8
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
    693          }
    694          
    695          
    696          /**************************************************************************//*!
    697          *
    698          * @brief    Private inline implementation of "strlen" used by TSA and Pipes
    699          *
    700          ******************************************************************************/
    701          

   \                                 In section .text, align 2, keep-with-next
    702          FMSTR_U16 FMSTR_StrLen(FMSTR_ADDR nAddr)
    703          {
   \                     FMSTR_StrLen: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    704              const FMSTR_U8* pStr;
    705              FMSTR_U16 nLen = 0U;
   \   00000002   0x2000             MOVS     R0,#+0
    706          
    707              #ifdef __HCS12X__
    708              /* convert from logical to global if needed */
    709              nAddr = FMSTR_FixHcs12xAddr(nAddr);
    710              #endif
    711          
    712              /*lint -e{923} casting address value to pointer */
    713              pStr = (const FMSTR_U8*) nAddr;
    714          
    715              while(*pStr++)
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD004             BEQ      ??FMSTR_StrLen_0
   \                     ??FMSTR_StrLen_1: (+1)
   \   0000000A   0x1C49             ADDS     R1,R1,#+1
    716              {
    717                  nLen++;
   \   0000000C   0x1C40             ADDS     R0,R0,#+1
   \   0000000E   0x780A             LDRB     R2,[R1, #+0]
   \   00000010   0x2A00             CMP      R2,#+0
   \   00000012   0xD1FA             BNE      ??FMSTR_StrLen_1
    718              }
    719          
    720              return nLen;
   \                     ??FMSTR_StrLen_0: (+1)
   \   00000014   0xB280             UXTH     R0,R0
   \   00000016   0x4770             BX       LR               ;; return
    721          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x4B 0x78          DC8 "Kxx FreeMASTER"
   \              0x78 0x20    
   \              0x46 0x72    
   \              0x65 0x65    
   \              0x4D 0x41    
   \              0x53 0x54    
   \              0x45 0x52    
   \              0x00         
   \   0000000F   0x00               DC8 0
    722          #else /* !FMSTR_DISABLE */
    723          
    724          /**************************************************************************//*!
    725          *
    726          * @brief    FreeMASTER driver initialization is disabled
    727          *
    728          ******************************************************************************/
    729          
    730          FMSTR_BOOL FMSTR_Init(void)
    731          {
    732              return FMSTR_FALSE;
    733          }
    734          
    735          /*******************************************************************************
    736          *
    737          * @brief    API: Main "Polling" call from the application main loop
    738          *
    739          *******************************************************************************/
    740          
    741          void FMSTR_Poll(void)
    742          {
    743          }
    744          
    745          /* HC12 interrupt routine declaration, must be in non-paged code memory */
    746          #if defined(FMSTR_PLATFORM_HC12) && (!defined(__S12Z__))
    747              #include "non_bank.sgm"
    748          #endif
    749          
    750          /*******************************************************************************
    751          *
    752          * @brief    API: API: Main SCI / CAN Interrupt handler call
    753          *
    754          *******************************************************************************/
    755          #if !defined(FMSTR_PLATFORM_MQX)
    756          #if defined(FMSTR_PLATFORM_MPC55xx)
    757          void FMSTR_Isr(unsigned long vec)
    758          {
    759              FMSTR_UNUSED(vec);
    760          }
    761          #else
    762          void FMSTR_Isr(void)
    763          {
    764          }
    765          #endif
    766          #endif
    767          
    768          #if defined(FMSTR_PLATFORM_HC12) || defined(FMSTR_PLATFORM_HC08) || defined(FMSTR_PLATFORM_MCF51xx)
    769          /*******************************************************************************
    770          *
    771          * @brief    API: API: The 2nd FMSTR interrupt handler
    772          *
    773          *******************************************************************************/
    774          
    775          void FMSTR_Isr2(void)
    776          {
    777          }
    778          
    779          #endif
    780          
    781          /* restore HC12 code segment */
    782          #if defined(FMSTR_PLATFORM_HC12) && (!defined(__S12Z__))
    783              #include "default.sgm"
    784          #endif
    785          
    786          #endif /* !FMSTR_DISABLE */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FMSTR_GetBoardInfo
         8   -> FMSTR_GetRecBuffSize
         8   -> FMSTR_ValueToBuffer16
       8   FMSTR_Init
         8   -> FMSTR_InitRec
         8   -> FMSTR_InitScope
         8   -> FMSTR_InitSerial
         8   -> FMSTR_InitTsa
      24   FMSTR_ProtocolDecoder
        24   -> FMSTR_AddressFromBuffer
        24   -> FMSTR_CheckTsaSpace
        24   -> FMSTR_CopyFromBuffer
        24   -> FMSTR_CopyFromBufferWithMask
        24   -> FMSTR_CopyToBuffer
        24   -> FMSTR_GetRecBuff
        24   -> FMSTR_GetRecBuffSize
        24   -> FMSTR_GetRecStatus
        24   -> FMSTR_GetStringLen
        24   -> FMSTR_GetTsaInfo
        24   -> FMSTR_ReadScope
        24   -> FMSTR_SendResponse
        24   -> FMSTR_SetExAddr
        24   -> FMSTR_SetUpRec
        24   -> FMSTR_SetUpScope
        24   -> FMSTR_StartRec
        24   -> FMSTR_StopRec
        24   -> FMSTR_ValueToBuffer16
      16   FMSTR_ReadMem
        16   -> FMSTR_AddressFromBuffer
        16   -> FMSTR_CheckTsaSpace
        16   -> FMSTR_CopyToBuffer
      16   FMSTR_ReadVar
        16   -> FMSTR_AddressFromBuffer
        16   -> FMSTR_CheckTsaSpace
        16   -> FMSTR_CopyToBuffer
       0   FMSTR_StrLen
      24   FMSTR_WriteMem
        24   -> FMSTR_AddressFromBuffer
        24   -> FMSTR_CheckTsaSpace
        24   -> FMSTR_CopyFromBuffer
      24   FMSTR_WriteMemMask
        24   -> FMSTR_AddressFromBuffer
        24   -> FMSTR_CheckTsaSpace
        24   -> FMSTR_CopyFromBufferWithMask
      24   FMSTR_WriteVar
        24   -> FMSTR_AddressFromBuffer
        24   -> FMSTR_CheckTsaSpace
        24   -> FMSTR_CopyFromBuffer
      24   FMSTR_WriteVarMask
        24   -> FMSTR_AddressFromBuffer
        24   -> FMSTR_CheckTsaSpace
        24   -> FMSTR_CopyFromBufferWithMask


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?_0
      72  FMSTR_GetBoardInfo
      32  FMSTR_Init
     430  FMSTR_ProtocolDecoder
      64  FMSTR_ReadMem
      56  FMSTR_ReadVar
      24  FMSTR_StrLen
      56  FMSTR_WriteMem
      56  FMSTR_WriteMemMask
      56  FMSTR_WriteVar
      56  FMSTR_WriteVarMask

 
 918 bytes in section .text
 
 918 bytes of CODE memory

Errors: none
Warnings: none
