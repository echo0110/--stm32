###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        07/Mar/2017  09:12:06
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_tsa.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_tsa.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\..\..\..\..\src\projects\irtc1hzpulse_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\Release\List\freemaster_tsa.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\irtc1hzpulse_test\Release\Obj\freemaster_tsa.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_tsa.c
      1          /*******************************************************************************
      2          *
      3          * Copyright 2004-2013 Freescale Semiconductor, Inc.
      4          *
      5          * This software is owned or controlled by Freescale Semiconductor.
      6          * Use of this software is governed by the Freescale FreeMASTER License
      7          * distributed with this Material.
      8          * See the license file distributed for more details.
      9          *
     10          ****************************************************************************//*!
     11          *
     12          * @brief  FreeMASTER TSA implementation
     13          *
     14          * This file implements a new FreeMASTER feature called Targer-side address
     15          * translation.
     16          *
     17          *******************************************************************************/
     18          
     19          #include "freemaster.h"
     20          #include "freemaster_private.h"
     21          #include "freemaster_protocol.h"
     22          
     23          #if (FMSTR_USE_TSA) && (!(FMSTR_DISABLE))
     24          
     25          /**************************************************************************//*!
     26          *
     27          * @brief    TSA Initialization
     28          *
     29          ******************************************************************************/
     30          

   \                                 In section .text, align 2, keep-with-next
     31          void FMSTR_InitTsa(void)
     32          {
     33          }
   \                     FMSTR_InitTsa: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     34          
     35          /**************************************************************************//*!
     36          *
     37          * @brief    Handling GETTSAINFO and GETTSAINFO_EX command
     38          *
     39          * @param    pMessageIO - original command (in) and response buffer (out)
     40          *
     41          * @return   As all command handlers, the return value should be the buffer
     42          *           pointer where the response output finished (except checksum)
     43          *
     44          ******************************************************************************/
     45          

   \                                 In section .text, align 2, keep-with-next
     46          FMSTR_BPTR FMSTR_GetTsaInfo(FMSTR_BPTR pMessageIO)
     47          {
   \                     FMSTR_GetTsaInfo: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     48              volatile FMSTR_BPTR pResponse = pMessageIO;
   \   00000004   0x9000             STR      R0,[SP, #+0]
     49              const FMSTR_TSA_ENTRY* pTbl;
     50              FMSTR_TSA_TINDEX nTblIndex;
     51              FMSTR_TSA_TSIZE nTblSize = 0U;
   \   00000006   0x2400             MOVS     R4,#+0
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x808C             STRH     R4,[R1, #+4]
     52              FMSTR_ADDR tmpAddr;
     53              FMSTR_U16 tmp16;
     54          
     55              /* get index of table the PC is requesting   */
     56              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
     57              pMessageIO = FMSTR_ValueFromBuffer16(&nTblIndex, pMessageIO);
   \   0000000C   0x1C81             ADDS     R1,R0,#+2
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x1C80             ADDS     R0,R0,#+2
   \   00000012   0x.... 0x....      BL       FMSTR_ValueFromBuffer16
     58          
     59              /* TSA flags */
     60              tmp16 = FMSTR_TSA_VERSION | FMSTR_TSA_FLAGS;
     61          
     62              /* sizeof TSA table entry items */
     63              /*lint -e{506,774} constant value boolean */
     64              if((sizeof(FMSTR_TSA_ENTRY)/4U) == 4U)
     65              {
     66                  tmp16 |= FMSTR_TSA_INFO_32BIT;  /* 32bit TSA entries */
     67              }
     68          
     69              /* success, flags */
     70              pResponse = FMSTR_ConstToBuffer8(pResponse, FMSTR_STS_OK);
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x7004             STRB     R4,[R0, #+0]
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
   \   0000001E   0x9000             STR      R0,[SP, #+0]
     71              pResponse = FMSTR_ValueToBuffer16(pResponse, tmp16);
   \   00000020   0x2181             MOVS     R1,#+129
   \   00000022   0x0049             LSLS     R1,R1,#+1        ;; #+258
   \   00000024   0x9800             LDR      R0,[SP, #+0]
   \   00000026   0x.... 0x....      BL       FMSTR_ValueToBuffer16
   \   0000002A   0x9000             STR      R0,[SP, #+0]
     72          
     73              /* get the table (or NULL if no table on given index) */
     74              pTbl = FMSTR_TsaGetTable(nTblIndex, &nTblSize);
   \   0000002C   0xA901             ADD      R1,SP,#+4
   \   0000002E   0x4668             MOV      R0,SP
   \   00000030   0x88C0             LDRH     R0,[R0, #+6]
   \   00000032   0x.... 0x....      BL       FMSTR_TsaGetTable
   \   00000036   0x0004             MOVS     R4,R0
     75              FMSTR_PTR2ADDR(tmpAddr, pTbl);
     76          
     77              /* table size in bytes */
     78              nTblSize *= FMSTR_CFG_BUS_WIDTH;
     79              pResponse = FMSTR_ValueToBuffer16(pResponse, nTblSize);
   \   00000038   0x4668             MOV      R0,SP
   \   0000003A   0x8881             LDRH     R1,[R0, #+4]
   \   0000003C   0x9800             LDR      R0,[SP, #+0]
   \   0000003E   0x.... 0x....      BL       FMSTR_ValueToBuffer16
   \   00000042   0x9000             STR      R0,[SP, #+0]
     80          
     81              /* table address */
     82              return FMSTR_AddressToBuffer(pResponse, tmpAddr);
   \   00000044   0x0021             MOVS     R1,R4
   \   00000046   0x9800             LDR      R0,[SP, #+0]
   \   00000048   0x.... 0x....      BL       FMSTR_AddressToBuffer
   \   0000004C   0xB002             ADD      SP,SP,#+8
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
     83          }
     84          
     85          /**************************************************************************//*!
     86          *
     87          * @brief    Handling GETSTRLEN and GETSTRLEN_EX commands
     88          *
     89          * @param    pMessageIO - original command (in) and response buffer (out)
     90          *
     91          * @return   As all command handlers, the return value should be the buffer
     92          *           pointer where the response output finished (except checksum)
     93          *
     94          ******************************************************************************/
     95          

   \                                 In section .text, align 2, keep-with-next
     96          FMSTR_BPTR FMSTR_GetStringLen(FMSTR_BPTR pMessageIO)
     97          {
   \                     FMSTR_GetStringLen: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
     98              FMSTR_BPTR pResponse = pMessageIO;
     99              FMSTR_ADDR nAddr;
    100              FMSTR_U16 nLen = 0U;
    101          
    102              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 1U);
    103              pMessageIO = FMSTR_AddressFromBuffer(&nAddr, pMessageIO);
   \   00000006   0x1C61             ADDS     R1,R4,#+1
   \   00000008   0x4668             MOV      R0,SP
   \   0000000A   0x.... 0x....      BL       FMSTR_AddressFromBuffer
    104          
    105              nLen = FMSTR_StrLen(nAddr);
   \   0000000E   0x9800             LDR      R0,[SP, #+0]
   \   00000010   0x.... 0x....      BL       FMSTR_StrLen
    106          
    107              /* return strign size in bytes (even on 16bit DSP) */
    108              nLen *= FMSTR_CFG_BUS_WIDTH ;
    109          
    110              pResponse = FMSTR_ConstToBuffer8(pResponse, FMSTR_STS_OK);
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7021             STRB     R1,[R4, #+0]
   \   00000018   0x1C64             ADDS     R4,R4,#+1
    111              return FMSTR_ValueToBuffer16(pResponse, nLen);
   \   0000001A   0x0001             MOVS     R1,R0
   \   0000001C   0x0020             MOVS     R0,R4
   \   0000001E   0x.... 0x....      BL       FMSTR_ValueToBuffer16
   \   00000022   0xB002             ADD      SP,SP,#+8
   \   00000024   0xBD10             POP      {R4,PC}          ;; return
    112          }
    113          
    114          /**************************************************************************//*!
    115          *
    116          * @brief    Helper (inline) function for TSA memory region check
    117          *
    118          * @param    nAddrUser - address of region to be checked
    119          * @param    nSizeUser - size of region to be checked
    120          * @param    nAddrSafe - address of known "safe" region
    121          * @param    wSizeSafe - size of safe region
    122          *
    123          * @return   This function returns non-zero if given user space is safe
    124          *           (i.e. it lies in given safe space)
    125          *
    126          ******************************************************************************/
    127          
    128          #if defined(FMSTR_PLATFORM_56F8xxx) || defined(FMSTR_PLATFORM_56F8xx)
    129          /* make inline */
    130          inline FMSTR_BOOL FMSTR_CheckMemSpace(FMSTR_ADDR nAddrUser, FMSTR_SIZE8 nSizeUser,
    131              FMSTR_ADDR nAddrSafe, FMSTR_SIZE wSizeSafe);
    132          
    133          inline
    134          #else
    135          /* declare function prototype */
    136          static FMSTR_BOOL FMSTR_CheckMemSpace(FMSTR_ADDR nAddrUser, FMSTR_SIZE8 nSizeUser,
    137              FMSTR_ADDR nAddrSafe, FMSTR_SIZE wSizeSafe);
    138          
    139          static
    140          #endif
    141          
    142          FMSTR_BOOL FMSTR_CheckMemSpace(FMSTR_ADDR nAddrUser, FMSTR_SIZE8 nSizeUser,
    143                                         FMSTR_ADDR nAddrSafe, FMSTR_SIZE wSizeSafe)
    144          {
    145              FMSTR_BOOL bRet = FMSTR_FALSE;
    146          
    147              #ifdef __HCS12X__
    148              /* convert from logical to global if needed */
    149              nAddrUser = FMSTR_FixHcs12xAddr(nAddrUser);
    150              nAddrSafe = FMSTR_FixHcs12xAddr(nAddrSafe);
    151              #endif
    152          
    153              if(nAddrUser >= nAddrSafe)
    154              {
    155                  bRet = (FMSTR_BOOL)
    156                      (((nAddrUser + nSizeUser) <= (nAddrSafe + wSizeSafe)) ? FMSTR_TRUE : FMSTR_FALSE);
    157              }
    158          
    159              return bRet;
    160          }
    161          
    162          /**************************************************************************//*!
    163          *
    164          * @brief    Check wether given memory region is "safe" (covered by TSA)
    165          *
    166          * @param    dwAddr - address of the memory to be checked
    167          * @param    nSize  - size of the memory to be checked
    168          * @param    bWriteAccess - write access is required
    169          *
    170          * @return   This function returns non-zero if user space is safe
    171          *
    172          ******************************************************************************/
    173          

   \                                 In section .text, align 2, keep-with-next
    174          FMSTR_BOOL FMSTR_CheckTsaSpace(FMSTR_ADDR dwAddr, FMSTR_SIZE8 nSize, FMSTR_BOOL bWriteAccess)
    175          {
   \                     FMSTR_CheckTsaSpace: (+1)
   \   00000000   0xB5F3             PUSH     {R0,R1,R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0016             MOVS     R6,R2
   \   00000006   0x2700             MOVS     R7,#+0
   \   00000008   0x4669             MOV      R1,SP
   \   0000000A   0x7C09             LDRB     R1,[R1, #+16]
   \   0000000C   0x1840             ADDS     R0,R0,R1
   \   0000000E   0x9001             STR      R0,[SP, #+4]
   \   00000010   0xE019             B        ??FMSTR_CheckTsaSpace_0
    176              const FMSTR_TSA_ENTRY* pte;
    177              FMSTR_TSA_TINDEX nTableIndex;
    178              FMSTR_TSA_TSIZE i, cnt;
    179              FMSTR_SIZE nInfo;
    180          
    181          #if FMSTR_CFG_BUS_WIDTH >= 2U
    182              /* TSA tables use sizeof() operator which returns size in "bus-widths" (e.g. 56F8xx) */
    183              nSize = (nSize + 1) / FMSTR_CFG_BUS_WIDTH;
    184          #endif
    185          
    186              /* to be as fast as possible during normal operation,
    187                 check variable entries in all tables first */
    188              for(nTableIndex=0U; (pte=FMSTR_TsaGetTable(nTableIndex, &cnt)) != NULL; nTableIndex++)
    189              {
    190                  /* number of items in a table */
    191                  cnt /= (FMSTR_TSA_TSIZE) sizeof(FMSTR_TSA_ENTRY);
    192          
    193                  /* all table entries */
    194                  for(i=0U; i<cnt; i++)
    195                  {
    196                      /*lint -e{506,774} condition always true/false */
    197          #if !defined(__S12Z__)
    198                      if(sizeof(pte->addr.p) < sizeof(pte->addr.n))
    199                          nInfo = (FMSTR_SIZE)((unsigned long) pte->info.n);
    200                      else
    201          #endif
    202                      nInfo = (FMSTR_SIZE) ((unsigned long)pte->info.p);
   \                     ??FMSTR_CheckTsaSpace_1: (+1)
   \   00000012   0x68E0             LDR      R0,[R4, #+12]
   \   00000014   0xB280             UXTH     R0,R0
    203          
    204                      /* variable entry only (also check read-write flag) */
    205                      if((nInfo & FMSTR_TSA_INFO_VAR_FLAG) && (!bWriteAccess || (nInfo & FMSTR_TSA_INFO_RWV_FLAG)))
   \   00000016   0x07C1             LSLS     R1,R0,#+31
   \   00000018   0xD50D             BPL      ??FMSTR_CheckTsaSpace_2
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD001             BEQ      ??FMSTR_CheckTsaSpace_3
   \   0000001E   0x0781             LSLS     R1,R0,#+30
   \   00000020   0xD509             BPL      ??FMSTR_CheckTsaSpace_2
    206                      {
    207                          /* need to take the larger of the two in union (will be optimized by compiler anyway) */
    208                          /*lint -e{506,774} condition always true/false */
    209          #if !defined(__S12Z__)
    210                          if(sizeof(pte->addr.p) < sizeof(pte->addr.n))
    211                          {
    212                              if(FMSTR_CheckMemSpace(dwAddr, nSize, (FMSTR_ADDR) pte->addr.n, (FMSTR_SIZE) (nInfo >> 2)))
    213                              {
    214                                  return FMSTR_TRUE; /* access granted! */
    215                              }
    216                          }
    217                          else
    218          #endif
    219                          {
    220                              /*lint -e{923} casting pointer to long (on some architectures) */
    221                              if(FMSTR_CheckMemSpace(dwAddr, nSize, (FMSTR_ADDR) pte->addr.p, (FMSTR_SIZE) (nInfo >> 2)))
   \                     ??FMSTR_CheckTsaSpace_3: (+1)
   \   00000022   0x68A1             LDR      R1,[R4, #+8]
   \   00000024   0x9A03             LDR      R2,[SP, #+12]
   \   00000026   0x428A             CMP      R2,R1
   \   00000028   0xD305             BCC      ??FMSTR_CheckTsaSpace_2
   \   0000002A   0x0380             LSLS     R0,R0,#+14
   \   0000002C   0x0C00             LSRS     R0,R0,#+16
   \   0000002E   0x1808             ADDS     R0,R1,R0
   \   00000030   0x9901             LDR      R1,[SP, #+4]
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xD25C             BCS      ??FMSTR_CheckTsaSpace_4
    222                              {
    223                                  return FMSTR_TRUE; /* access granted! */
    224                              }
    225                          }
    226                      }
    227          
    228                      pte++;
   \                     ??FMSTR_CheckTsaSpace_2: (+1)
   \   00000036   0x3410             ADDS     R4,R4,#+16
    229                  }
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \                     ??FMSTR_CheckTsaSpace_5: (+1)
   \   0000003A   0x4668             MOV      R0,SP
   \   0000003C   0x8800             LDRH     R0,[R0, #+0]
   \   0000003E   0xB2AD             UXTH     R5,R5
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0xD3E6             BCC      ??FMSTR_CheckTsaSpace_1
   \   00000044   0x1C7F             ADDS     R7,R7,#+1
   \                     ??FMSTR_CheckTsaSpace_0: (+1)
   \   00000046   0x4669             MOV      R1,SP
   \   00000048   0xB2B8             UXTH     R0,R7
   \   0000004A   0x.... 0x....      BL       FMSTR_TsaGetTable
   \   0000004E   0x0004             MOVS     R4,R0
   \   00000050   0xD006             BEQ      ??FMSTR_CheckTsaSpace_6
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x8800             LDRH     R0,[R0, #+0]
   \   00000056   0x0900             LSRS     R0,R0,#+4
   \   00000058   0x4669             MOV      R1,SP
   \   0000005A   0x8008             STRH     R0,[R1, #+0]
   \   0000005C   0x2500             MOVS     R5,#+0
   \   0000005E   0xE7EC             B        ??FMSTR_CheckTsaSpace_5
    230              }
    231          
    232              /* no more writable memory chunks available */
    233              if(bWriteAccess)
   \                     ??FMSTR_CheckTsaSpace_6: (+1)
   \   00000060   0x2E00             CMP      R6,#+0
   \   00000062   0xD147             BNE      ??FMSTR_CheckTsaSpace_7
    234              {
    235                  return FMSTR_FALSE;
    236              }
    237          
    238              /* allow reading of recorder buffer */
    239          #if FMSTR_USE_RECORDER
    240              if(FMSTR_IsInRecBuffer(dwAddr, nSize))
   \   00000064   0x4668             MOV      R0,SP
   \   00000066   0x7C01             LDRB     R1,[R0, #+16]
   \   00000068   0x9803             LDR      R0,[SP, #+12]
   \   0000006A   0x.... 0x....      BL       FMSTR_IsInRecBuffer
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD13E             BNE      ??FMSTR_CheckTsaSpace_4
    241              {
    242                  return FMSTR_TRUE;
    243              }
    244          #endif
    245          
    246              /* allow reading of any C-constant string referenced in TSA tables */
    247              for(nTableIndex=0U; (pte=FMSTR_TsaGetTable(nTableIndex, &cnt)) != NULL; nTableIndex++)
   \   00000072   0x2700             MOVS     R7,#+0
   \   00000074   0x9803             LDR      R0,[SP, #+12]
   \   00000076   0x4669             MOV      R1,SP
   \   00000078   0x7C09             LDRB     R1,[R1, #+16]
   \   0000007A   0x1840             ADDS     R0,R0,R1
   \   0000007C   0x9001             STR      R0,[SP, #+4]
   \   0000007E   0xE000             B        ??FMSTR_CheckTsaSpace_8
   \                     ??FMSTR_CheckTsaSpace_9: (+1)
   \   00000080   0x1C7F             ADDS     R7,R7,#+1
   \                     ??FMSTR_CheckTsaSpace_8: (+1)
   \   00000082   0x4669             MOV      R1,SP
   \   00000084   0xB2B8             UXTH     R0,R7
   \   00000086   0x.... 0x....      BL       FMSTR_TsaGetTable
   \   0000008A   0x0004             MOVS     R4,R0
   \   0000008C   0xD032             BEQ      ??FMSTR_CheckTsaSpace_7
    248              {
    249                  FMSTR_ADDR tmpAddr;
    250          
    251                  /* allow reading of the TSA table itself */
    252                  FMSTR_PTR2ADDR(tmpAddr, pte);
    253                  if(FMSTR_CheckMemSpace(dwAddr, nSize, tmpAddr, cnt))
   \   0000008E   0x9803             LDR      R0,[SP, #+12]
   \   00000090   0x42A0             CMP      R0,R4
   \   00000092   0xD305             BCC      ??FMSTR_CheckTsaSpace_10
   \   00000094   0x4668             MOV      R0,SP
   \   00000096   0x8800             LDRH     R0,[R0, #+0]
   \   00000098   0x1820             ADDS     R0,R4,R0
   \   0000009A   0x9901             LDR      R1,[SP, #+4]
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD227             BCS      ??FMSTR_CheckTsaSpace_4
    254                  {
    255                      return FMSTR_TRUE;
    256                  }
    257          
    258                  /* number of items in a table */
    259                  cnt /= (FMSTR_TSA_TSIZE) sizeof(FMSTR_TSA_ENTRY);
   \                     ??FMSTR_CheckTsaSpace_10: (+1)
   \   000000A0   0x4668             MOV      R0,SP
   \   000000A2   0x8800             LDRH     R0,[R0, #+0]
   \   000000A4   0x0900             LSRS     R0,R0,#+4
   \   000000A6   0x4669             MOV      R1,SP
   \   000000A8   0x8008             STRH     R0,[R1, #+0]
    260          
    261                  /* all table entries */
    262                  for(i=0U; i<cnt; i++)
   \   000000AA   0x2500             MOVS     R5,#+0
   \   000000AC   0xE001             B        ??FMSTR_CheckTsaSpace_11
    263                  {
    264                      /* system strings are always accessible at C-pointers */
    265                      FMSTR_PTR2ADDR(tmpAddr, pte->name.p);
    266                      if(pte->name.p)
    267                      {
    268                          if(FMSTR_CheckMemSpace(dwAddr, nSize, tmpAddr, FMSTR_StrLen(tmpAddr)))
    269                          {
    270                              return FMSTR_TRUE;
    271                          }
    272                      }
    273          
    274                      FMSTR_PTR2ADDR(tmpAddr, pte->type.p);
    275                      if(pte->type.p)
    276                      {
    277                          if(FMSTR_CheckMemSpace(dwAddr, nSize, tmpAddr, FMSTR_StrLen(tmpAddr)))
    278                          {
    279                              return FMSTR_TRUE;
    280                          }
    281                      }
    282          
    283                      pte++;
   \                     ??FMSTR_CheckTsaSpace_12: (+1)
   \   000000AE   0x3410             ADDS     R4,R4,#+16
   \   000000B0   0x1C6D             ADDS     R5,R5,#+1
   \                     ??FMSTR_CheckTsaSpace_11: (+1)
   \   000000B2   0x4668             MOV      R0,SP
   \   000000B4   0x8800             LDRH     R0,[R0, #+0]
   \   000000B6   0xB2AD             UXTH     R5,R5
   \   000000B8   0x4285             CMP      R5,R0
   \   000000BA   0xD2E1             BCS      ??FMSTR_CheckTsaSpace_9
   \   000000BC   0x6826             LDR      R6,[R4, #+0]
   \   000000BE   0x2E00             CMP      R6,#+0
   \   000000C0   0xD009             BEQ      ??FMSTR_CheckTsaSpace_13
   \   000000C2   0x0030             MOVS     R0,R6
   \   000000C4   0x.... 0x....      BL       FMSTR_StrLen
   \   000000C8   0x9903             LDR      R1,[SP, #+12]
   \   000000CA   0x42B1             CMP      R1,R6
   \   000000CC   0xD303             BCC      ??FMSTR_CheckTsaSpace_13
   \   000000CE   0x1830             ADDS     R0,R6,R0
   \   000000D0   0x9901             LDR      R1,[SP, #+4]
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xD20C             BCS      ??FMSTR_CheckTsaSpace_4
   \                     ??FMSTR_CheckTsaSpace_13: (+1)
   \   000000D6   0x6866             LDR      R6,[R4, #+4]
   \   000000D8   0x2E00             CMP      R6,#+0
   \   000000DA   0xD0E8             BEQ      ??FMSTR_CheckTsaSpace_12
   \   000000DC   0x0030             MOVS     R0,R6
   \   000000DE   0x.... 0x....      BL       FMSTR_StrLen
   \   000000E2   0x9903             LDR      R1,[SP, #+12]
   \   000000E4   0x42B1             CMP      R1,R6
   \   000000E6   0xD3E2             BCC      ??FMSTR_CheckTsaSpace_12
   \   000000E8   0x1830             ADDS     R0,R6,R0
   \   000000EA   0x9901             LDR      R1,[SP, #+4]
   \   000000EC   0x4288             CMP      R0,R1
   \   000000EE   0xD3DE             BCC      ??FMSTR_CheckTsaSpace_12
   \                     ??FMSTR_CheckTsaSpace_4: (+1)
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0xE000             B        ??FMSTR_CheckTsaSpace_14
    284                  }
    285              }
    286          
    287              /* no valid TSA entry found => not-safe to access the memory */
    288              return FMSTR_FALSE;
   \                     ??FMSTR_CheckTsaSpace_7: (+1)
   \   000000F4   0x2000             MOVS     R0,#+0
   \                     ??FMSTR_CheckTsaSpace_14: (+1)
   \   000000F6   0xB005             ADD      SP,SP,#+20
   \   000000F8   0xBDF0             POP      {R4-R7,PC}       ;; return
    289          }
    290          
    291          #else /* (FMSTR_USE_TSA) && (!(FMSTR_DISABLE)) */
    292          
    293          /*lint -efile(766, freemaster_protocol.h) include file is not used in this case */
    294          
    295          #endif /* (FMSTR_USE_TSA) && (!(FMSTR_DISABLE)) */
    296          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   FMSTR_CheckTsaSpace
        40   -> FMSTR_IsInRecBuffer
        40   -> FMSTR_StrLen
        40   -> FMSTR_TsaGetTable
      16   FMSTR_GetStringLen
        16   -> FMSTR_AddressFromBuffer
        16   -> FMSTR_StrLen
        16   -> FMSTR_ValueToBuffer16
      16   FMSTR_GetTsaInfo
        16   -> FMSTR_AddressToBuffer
        16   -> FMSTR_TsaGetTable
        16   -> FMSTR_ValueFromBuffer16
        16   -> FMSTR_ValueToBuffer16
       0   FMSTR_InitTsa


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     250  FMSTR_CheckTsaSpace
      38  FMSTR_GetStringLen
      80  FMSTR_GetTsaInfo
       2  FMSTR_InitTsa

 
 370 bytes in section .text
 
 370 bytes of CODE memory

Errors: none
Warnings: none
