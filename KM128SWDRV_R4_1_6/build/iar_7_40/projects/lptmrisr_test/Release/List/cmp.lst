###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        19/Apr/2017  10:43:01
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\cmp\cmp.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\cmp\cmp.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\lptmrisr_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\lptmrisr_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\lptmrisr_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\lptmrisr_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\lptmrisr_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\lptmrisr_test\..\..\..\..\src\projects\lptmrisr_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\lptmrisr_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\lptmrisr_test\Release\List\cmp.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\lptmrisr_test\Release\Obj\cmp.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\cmp\cmp.c
      1          /******************************************************************************
      2           * (c) Copyright 2010-2013, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ***************************************************************************//*!
      5           * @file      cmp.c
      6           * @version   1.0.4.0
      7           * @date      Feb-13-2013
      8           * @brief     Analog comparator (CMP) driver source code.
      9           ******************************************************************************/
     10          #include "common.h"
     11          #include "cmp.h"
     12          
     13          #if !defined(MCU_MKM34ZA5)
     14            #error "The cmp.c module is specific to the MKMxxZxxACxx5 microcontrollers."
     15          #endif
     16          
     17          /******************************************************************************
     18           * data type definitions                                                      *
     19           ******************************************************************************/

   \                                 In section .bss, align 4
     20          static CMP_CALLBACK pCallbackCMPx;
   \                     pCallbackCMPx:
   \   00000000                      DS8 4
     21          
     22          /******************************************************************************
     23           * public function definitions                                                *
     24           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     25          void CMP_InstallCallback (uint8 ip, CMP_CALLBACK pCallback)
     26          {
     27            if (pCallback) { pCallbackCMPx = pCallback; NVIC_SetIsr(INT_CMP0_CMP1,ip); }
   \                     CMP_InstallCallback: (+1)
   \   00000000   0x000A             MOVS     R2,R1
   \   00000002   0xD010             BEQ      ??CMP_InstallCallback_0
   \   00000004   0x....             LDR      R2,??DataTable3
   \   00000006   0x6011             STR      R1,[R2, #+0]
   \   00000008   0x2180             MOVS     R1,#+128
   \   0000000A   0x01C9             LSLS     R1,R1,#+7        ;; #+16384
   \   0000000C   0x....             LDR      R2,??DataTable3_1  ;; 0xe000e280
   \   0000000E   0x6813             LDR      R3,[R2, #+0]
   \   00000010   0x430B             ORRS     R3,R3,R1
   \   00000012   0x6013             STR      R3,[R2, #+0]
   \   00000014   0x....             LDR      R2,??DataTable3_2  ;; 0xe000e100
   \   00000016   0x6813             LDR      R3,[R2, #+0]
   \   00000018   0x4319             ORRS     R1,R1,R3
   \   0000001A   0x6011             STR      R1,[R2, #+0]
   \   0000001C   0x....             LDR      R1,??DataTable3_3  ;; 0xe000e40c
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x0580             LSLS     R0,R0,#+22
   \   00000022   0x4310             ORRS     R0,R0,R2
   \   00000024   0x6008             STR      R0,[R1, #+0]
     28          }
   \                     ??CMP_InstallCallback_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
     29          

   \                                 In section .text, align 2, keep-with-next
     30          void CMP0_Init (tCMP cmp, uint8 psel, uint8 msel)
     31          {
   \                     CMP0_Init: (+1)
   \   00000000   0xB403             PUSH     {R0,R1}
     32            CMP0_CR0   = cmp.CR0;
   \   00000002   0x....             LDR      R0,??DataTable3_4  ;; 0x40072000
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x7001             STRB     R1,[R0, #+0]
     33            CMP0_FPR   = cmp.FPR;
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x7889             LDRB     R1,[R1, #+2]
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
     34            CMP0_SCR   = cmp.SCR;
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x78C9             LDRB     R1,[R1, #+3]
   \   00000014   0x70C1             STRB     R1,[R0, #+3]
     35            CMP0_DACCR = cmp.DACCR;
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x7909             LDRB     R1,[R1, #+4]
   \   0000001A   0x7101             STRB     R1,[R0, #+4]
     36            CMP0_MUXCR = (uint8)((psel<<3)|msel);
   \   0000001C   0x00D1             LSLS     R1,R2,#+3
   \   0000001E   0x430B             ORRS     R3,R3,R1
   \   00000020   0x7143             STRB     R3,[R0, #+5]
     37            CMP0_CR1   = cmp.CR1;
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x7849             LDRB     R1,[R1, #+1]
   \   00000026   0x7041             STRB     R1,[R0, #+1]
     38          }
   \   00000028   0xB002             ADD      SP,SP,#+8
   \   0000002A   0x4770             BX       LR               ;; return
     39          

   \                                 In section .text, align 2, keep-with-next
     40          void CMP1_Init (tCMP cmp, uint8 psel, uint8 msel)
     41          {
   \                     CMP1_Init: (+1)
   \   00000000   0xB403             PUSH     {R0,R1}
     42            CMP1_CR0   = cmp.CR0;
   \   00000002   0x....             LDR      R0,??DataTable3_5  ;; 0x40072008
   \   00000004   0x4669             MOV      R1,SP
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x7001             STRB     R1,[R0, #+0]
     43            CMP1_FPR   = cmp.FPR;
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x7889             LDRB     R1,[R1, #+2]
   \   0000000E   0x7081             STRB     R1,[R0, #+2]
     44            CMP1_SCR   = cmp.SCR;
   \   00000010   0x4669             MOV      R1,SP
   \   00000012   0x78C9             LDRB     R1,[R1, #+3]
   \   00000014   0x70C1             STRB     R1,[R0, #+3]
     45            CMP1_DACCR = cmp.DACCR;
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x7909             LDRB     R1,[R1, #+4]
   \   0000001A   0x7101             STRB     R1,[R0, #+4]
     46            CMP1_MUXCR = (uint8)((psel<<3)|msel);
   \   0000001C   0x00D1             LSLS     R1,R2,#+3
   \   0000001E   0x430B             ORRS     R3,R3,R1
   \   00000020   0x7143             STRB     R3,[R0, #+5]
     47            CMP1_CR1   = cmp.CR1;
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x7849             LDRB     R1,[R1, #+1]
   \   00000026   0x7041             STRB     R1,[R0, #+1]
     48          }
   \   00000028   0xB002             ADD      SP,SP,#+8
   \   0000002A   0x4770             BX       LR               ;; return
     49          
     50          /******************************************************************************
     51           * interrupt function definitions                                             *
     52           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     53          weak void cmpx_isr (void)
     54          {
   \                     cmpx_isr: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
     55            /* process CMP0 module callbacks                                            */
     56            if (SIM_SCGC4 & SIM_SCGC4_CMP0_MASK)
   \   00000004   0x....             LDR      R4,??DataTable3_6  ;; 0x4003f034
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x0340             LSLS     R0,R0,#+13
   \   0000000A   0xD51C             BPL      ??cmpx_isr_0
     57            {
     58              /* negedge callback                                                       */
     59              if ((CMP0_SCR & CMP_SCR_IEF_MASK) && (CMP0_SCR & CMP_SCR_CFF_MASK))
   \   0000000C   0x....             LDR      R5,??DataTable3_7  ;; 0x40072003
   \   0000000E   0x7828             LDRB     R0,[R5, #+0]
   \   00000010   0x0700             LSLS     R0,R0,#+28
   \   00000012   0xD50A             BPL      ??cmpx_isr_1
   \   00000014   0x7828             LDRB     R0,[R5, #+0]
   \   00000016   0x0780             LSLS     R0,R0,#+30
   \   00000018   0xD507             BPL      ??cmpx_isr_1
     60              {
     61                ioclrb(CMP0_SCR,CMP_SCR_CFR_MASK);        /* clear CFF but not CFR flag */
   \   0000001A   0x20FB             MOVS     R0,#+251
   \   0000001C   0x....             LDR      R1,??DataTable3_8  ;; 0x44072003
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
     62                pCallbackCMPx (CMP0_CALLBACK, CMP_NEGEDGE_CALLBACK);
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x....             LDR      R2,??DataTable3
   \   00000026   0x6812             LDR      R2,[R2, #+0]
   \   00000028   0x4790             BLX      R2
     63              }
     64              /* process posedge callback                                               */
     65              if ((CMP0_SCR & CMP_SCR_IER_MASK) && (CMP0_SCR & CMP_SCR_CFR_MASK))
   \                     ??cmpx_isr_1: (+1)
   \   0000002A   0x7828             LDRB     R0,[R5, #+0]
   \   0000002C   0x06C0             LSLS     R0,R0,#+27
   \   0000002E   0xD50A             BPL      ??cmpx_isr_0
   \   00000030   0x7828             LDRB     R0,[R5, #+0]
   \   00000032   0x0740             LSLS     R0,R0,#+29
   \   00000034   0xD507             BPL      ??cmpx_isr_0
     66              {
     67                ioclrb(CMP0_SCR,CMP_SCR_CFF_MASK);        /* clear CFR but not CFF flag */
   \   00000036   0x20FD             MOVS     R0,#+253
   \   00000038   0x....             LDR      R1,??DataTable3_8  ;; 0x44072003
   \   0000003A   0x7008             STRB     R0,[R1, #+0]
     68                pCallbackCMPx (CMP0_CALLBACK, CMP_POSEDGE_CALLBACK);
   \   0000003C   0x2102             MOVS     R1,#+2
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x....             LDR      R2,??DataTable3
   \   00000042   0x6812             LDR      R2,[R2, #+0]
   \   00000044   0x4790             BLX      R2
     69              }
     70            }
     71          
     72            /* process CMP1 module callbacks                                            */
     73            if (SIM_SCGC4 & SIM_SCGC4_CMP1_MASK)
   \                     ??cmpx_isr_0: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x0300             LSLS     R0,R0,#+12
   \   0000004A   0xD51C             BPL      ??cmpx_isr_2
     74            {
     75              /* negedge callback                                                       */
     76              if ((CMP1_SCR & CMP_SCR_IEF_MASK) && (CMP1_SCR & CMP_SCR_CFF_MASK))
   \   0000004C   0x....             LDR      R5,??DataTable3_7  ;; 0x40072003
   \   0000004E   0x7A28             LDRB     R0,[R5, #+8]
   \   00000050   0x0700             LSLS     R0,R0,#+28
   \   00000052   0xD50A             BPL      ??cmpx_isr_3
   \   00000054   0x7A28             LDRB     R0,[R5, #+8]
   \   00000056   0x0780             LSLS     R0,R0,#+30
   \   00000058   0xD507             BPL      ??cmpx_isr_3
     77              {
     78                ioclrb(CMP1_SCR,CMP_SCR_CFR_MASK);        /* clear CFF but not CFR flag */
   \   0000005A   0x20FB             MOVS     R0,#+251
   \   0000005C   0x....             LDR      R1,??DataTable3_8  ;; 0x44072003
   \   0000005E   0x7208             STRB     R0,[R1, #+8]
     79                pCallbackCMPx (CMP1_CALLBACK, CMP_NEGEDGE_CALLBACK);
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x....             LDR      R2,??DataTable3
   \   00000066   0x6812             LDR      R2,[R2, #+0]
   \   00000068   0x4790             BLX      R2
     80              }
     81              /* posedge callback                                                       */
     82              if ((CMP1_SCR & CMP_SCR_IER_MASK) && (CMP1_SCR & CMP_SCR_CFR_MASK))
   \                     ??cmpx_isr_3: (+1)
   \   0000006A   0x7A28             LDRB     R0,[R5, #+8]
   \   0000006C   0x06C0             LSLS     R0,R0,#+27
   \   0000006E   0xD50A             BPL      ??cmpx_isr_2
   \   00000070   0x7A28             LDRB     R0,[R5, #+8]
   \   00000072   0x0740             LSLS     R0,R0,#+29
   \   00000074   0xD507             BPL      ??cmpx_isr_2
     83              {
     84                ioclrb(CMP1_SCR,CMP_SCR_CFF_MASK);        /* clear CFR but not CFF flag */
   \   00000076   0x20FD             MOVS     R0,#+253
   \   00000078   0x....             LDR      R1,??DataTable3_8  ;; 0x44072003
   \   0000007A   0x7208             STRB     R0,[R1, #+8]
     85                pCallbackCMPx (CMP1_CALLBACK, CMP_POSEDGE_CALLBACK);
   \   0000007C   0x2102             MOVS     R1,#+2
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0x....             LDR      R2,??DataTable3
   \   00000082   0x6812             LDR      R2,[R2, #+0]
   \   00000084   0x4790             BLX      R2
     86              }
     87            }
     88          
     89          }
   \                     ??cmpx_isr_2: (+1)
   \   00000086   0xB001             ADD      SP,SP,#+4
   \   00000088   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     pCallbackCMPx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0xE000E40C         DC32     0xe000e40c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x40072000         DC32     0x40072000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x40072008         DC32     0x40072008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x4003F034         DC32     0x4003f034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x40072003         DC32     0x40072003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x44072003         DC32     0x44072003
     90          /******************************************************************************
     91           * End of module                                                              *
     92           ******************************************************************************/
     93          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CMP0_Init
       8   CMP1_Init
       0   CMP_InstallCallback
      16   cmpx_isr
        16   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
      44  CMP0_Init
      44  CMP1_Init
      40  CMP_InstallCallback
     138  cmpx_isr
       4  pCallbackCMPx

 
   4 bytes in section .bss
 302 bytes in section .text
 
 302 bytes of CODE memory
   4 bytes of DATA memory

Errors: none
Warnings: none
