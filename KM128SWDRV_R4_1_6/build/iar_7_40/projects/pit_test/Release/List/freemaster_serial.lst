###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        21/Mar/2017  14:13:01
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_serial.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_serial.c -D
#        NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\Release\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\..\..\..\..\src\projects\pit_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\..\..\..\..\src\toolchain\iar\
#        -On
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\Release\List\freemaster_serial.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\Release\Obj\freemaster_serial.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_serial.c
      1          /*******************************************************************************
      2          *
      3          * Copyright 2004-2014 Freescale Semiconductor, Inc.
      4          *
      5          * This software is owned or controlled by Freescale Semiconductor.
      6          * Use of this software is governed by the Freescale FreeMASTER License
      7          * distributed with this Material.
      8          * See the license file distributed for more details.
      9          *
     10          ****************************************************************************//*!
     11          *
     12          * @brief  FreeMASTER serial communication routines
     13          *
     14          *******************************************************************************/
     15          
     16          #include "freemaster.h"
     17          #include "freemaster_private.h"
     18          #include "freemaster_protocol.h"
     19          
     20          #if !(FMSTR_DISABLE)
     21          
     22          #if FMSTR_USE_SERIAL
     23          
     24          /***********************************
     25          *  local variables
     26          ***********************************/
     27          
     28          /* FreeMASTER communication buffer (in/out) plus the STS and LEN bytes */

   \                                 In section .bss, align 4
     29          static FMSTR_BCHR pcm_pCommBuffer[FMSTR_COMM_BUFFER_SIZE+3];
   \                     pcm_pCommBuffer:
   \   00000000                      DS8 204
     30          
     31          /* FreeMASTER runtime flags */
     32          /*lint -e{960} using union */
     33          typedef volatile union
     34          {
     35              FMSTR_FLAGS all;
     36          
     37              struct
     38              {
     39                  unsigned bTxActive : 1;         /* response is being transmitted */
     40          #if (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART)
     41                  unsigned bTxWaitTC : 1;         /* response sent, wait for transmission complete */
     42          #endif
     43                  unsigned bTxLastCharSOB   : 1;  /* last transmitted char was equal to SOB  */
     44                  unsigned bRxLastCharSOB   : 1;  /* last received character was SOB */
     45                  unsigned bRxMsgLengthNext : 1;  /* expect the length byte next time */
     46          #if FMSTR_USE_JTAG
     47                  unsigned bJtagRIEPending  : 1;  /* JTAG RIE bit failed to be set, try again later */
     48          #endif
     49          #if (FMSTR_USE_USB_CDC) || (FMSTR_USE_MQX_IO) || (FMSTR_USE_JTAG)
     50                  unsigned bTxFirstSobSend  : 1;  /* to send SOB char at the begin of the packet */
     51          #endif
     52          #if FMSTR_USE_MQX_IO
     53                  unsigned bMqxReadyToSend  : 1;  /* to send next character in transmit routine */
     54          #endif
     55          #if FMSTR_USE_USB_CDC
     56                  unsigned bUsbCdcStartApp   : 1; /* FreeMASTER USB CDC Application start Init Flag */
     57                  unsigned bUsbCdcStartTrans : 1; /* FreeMASTER USB CDC Application Carrier Activate Flag */
     58                  unsigned bUsbReadyToDecode : 1; /* FreeMASTER packet is received, ready to decode in Poll function in Short Interrupt mode */
     59          #endif
     60              } flg;
     61          
     62          } FMSTR_SERIAL_FLAGS;
     63          

   \                                 In section .bss, align 4
     64          static FMSTR_SERIAL_FLAGS pcm_wFlags;
   \                     pcm_wFlags:
   \   00000000                      DS8 4
     65          
     66          /* receive and transmit buffers and counters */

   \                                 In section .bss, align 1
     67          static FMSTR_SIZE8 pcm_nTxTodo;     /* transmission to-do counter (0 when tx is idle) */
   \                     pcm_nTxTodo:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     68          static FMSTR_SIZE8 pcm_nRxTodo;     /* reception to-do counter (0 when rx is idle) */
   \                     pcm_nRxTodo:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     69          static FMSTR_BPTR  pcm_pTxBuff;     /* pointer to next byte to transmit */
   \                     pcm_pTxBuff:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     70          static FMSTR_BPTR  pcm_pRxBuff;     /* pointer to next free place in RX buffer */
   \                     pcm_pRxBuff:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     71          static FMSTR_BCHR  pcm_nRxCheckSum; /* checksum of data being received */
   \                     pcm_nRxCheckSum:
   \   00000000                      DS8 1
     72          
     73          /***********************************
     74          *  local function prototypes
     75          ***********************************/
     76          
     77          static void FMSTR_Listen(void);
     78          static void FMSTR_SendError(FMSTR_BCHR nErrCode);
     79          
     80          #else /* FMSTR_USE_SERIAL */
     81          
     82          /*lint -efile(766, freemaster_protocol.h) include file is not used in this case */
     83          
     84          #endif /* FMSTR_USE_SERIAL */
     85          
     86          #if (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART) || (FMSTR_USE_JTAG)
     87          /***********************************
     88          *  local variables
     89          ***********************************/
     90          
     91          /* SHORT_INTR receive queue (circular buffer) */
     92          #if FMSTR_SHORT_INTR
     93          static FMSTR_BCHR  pcm_pRQueueBuffer[FMSTR_COMM_RQUEUE_SIZE];
     94          static FMSTR_BPTR  pcm_pRQueueRP;   /* SHORT_INTR queue read-pointer */
     95          static FMSTR_BPTR  pcm_pRQueueWP;   /* SHORT_INTR queue write-pointer */
     96          #endif
     97          
     98          /***********************************
     99          *  local function prototypes
    100          ***********************************/
    101          
    102          #if FMSTR_SHORT_INTR
    103          static void FMSTR_RxQueue(FMSTR_BCHR nRxChar);
    104          static void FMSTR_RxDequeue(void);
    105          #endif
    106          
    107          /*lint -esym(752,FMSTR_RxQueue) this may be unreferenced in some cases */
    108          /*lint -esym(752,FMSTR_RxDequeue) this may be unreferenced in some cases */
    109          
    110          /*******************************************************************************
    111          *
    112          * @brief    Routine to quick-receive a character (put to a queue only)
    113          *
    114          * This function puts received character into a queue and exits as soon as possible.
    115          *
    116          *******************************************************************************/
    117          
    118          #if FMSTR_SHORT_INTR
    119          
    120          static void FMSTR_RxQueue(FMSTR_BCHR nRxChar)
    121          {
    122              /* future value of write pointer */
    123              FMSTR_BPTR wpnext = pcm_pRQueueWP + 1;
    124          
    125              /*lint -e{946} pointer arithmetic is okay here (same array) */
    126              if(wpnext >= (pcm_pRQueueBuffer + FMSTR_COMM_RQUEUE_SIZE))
    127              {
    128                  wpnext = pcm_pRQueueBuffer;
    129              }
    130          
    131              /* any space in queue? */
    132              if(wpnext != pcm_pRQueueRP)
    133              {
    134                  *pcm_pRQueueWP = (FMSTR_U8) nRxChar;
    135                  pcm_pRQueueWP = wpnext;
    136              }
    137          }
    138          
    139          #endif /* FMSTR_SHORT_INTR  */
    140          
    141          /*******************************************************************************
    142          *
    143          * @brief    Late processing of queued characters
    144          *
    145          * This function takes the queued characters and calls FMSTR_Rx() for each of them,
    146          * just like as the characters would be received from SCI one by one.
    147          *
    148          *******************************************************************************/
    149          
    150          #if FMSTR_SHORT_INTR
    151          
    152          static void FMSTR_RxDequeue(void)
    153          {
    154              FMSTR_BCHR nChar = 0U;
    155          
    156              /* get all queued characters */
    157              while(pcm_pRQueueRP != pcm_pRQueueWP)
    158              {
    159                  nChar = *pcm_pRQueueRP++;
    160          
    161                  /*lint -e{946} pointer arithmetic is okay here (same array) */
    162                  if(pcm_pRQueueRP >= (pcm_pRQueueBuffer + FMSTR_COMM_RQUEUE_SIZE))
    163                  {
    164                      pcm_pRQueueRP = pcm_pRQueueBuffer;
    165                  }
    166          
    167                  /* emulate the SCI receive event */
    168                  if(!pcm_wFlags.flg.bTxActive)
    169                  {
    170                      (void)FMSTR_Rx(nChar);
    171                  }
    172              }
    173          }
    174          
    175          #endif /* FMSTR_SHORT_INTR */
    176          
    177          #endif /* (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART) || (FMSTR_USE_JTAG) */
    178          
    179          #if (FMSTR_USE_SCI) || (FMSTR_USE_LPUART) || (FMSTR_USE_ESCI)
    180          
    181          /**************************************************************************//*!
    182          *
    183          * @brief    Handle SCI communication (both TX and RX)
    184          *
    185          * This function checks the SCI flags and calls the Rx and/or Tx functions
    186          *
    187          * @note This function can be called either from SCI ISR or from the polling routine
    188          *
    189          ******************************************************************************/
    190          

   \                                 In section .text, align 2, keep-with-next
    191          void FMSTR_ProcessSCI(void)
    192          {
   \                     FMSTR_ProcessSCI: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    193              /* read & clear status     */
    194              FMSTR_SCISR wSciSR = FMSTR_SCI_RDCLRSR();
   \   00000002   0x....             LDR      R0,??DataTable6  ;; 0x4006b004
   \   00000004   0x7804             LDRB     R4,[R0, #+0]
    195          
    196              /* transmitter active and empty? */
    197              if (pcm_wFlags.flg.bTxActive)
   \   00000006   0x....             LDR      R0,??DataTable6_1
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x07C0             LSLS     R0,R0,#+31
   \   0000000C   0xD512             BPL      ??FMSTR_ProcessSCI_0
    198              {
    199                  /* able to accept another character? */
    200                  if(wSciSR & FMSTR_SCISR_TDRE)
   \   0000000E   0x0620             LSLS     R0,R4,#+24
   \   00000010   0xD508             BPL      ??FMSTR_ProcessSCI_1
    201                  {
    202                      FMSTR_U8 ch;
    203                      /* just put the byte into the SCI transmit buffer */
    204                      if(!FMSTR_Tx(&ch))
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x.... 0x....      BL       FMSTR_Tx
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD103             BNE      ??FMSTR_ProcessSCI_1
    205                          FMSTR_SCI_PUTCHAR((FMSTR_U8) ch);
   \   0000001C   0x4668             MOV      R0,SP
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x....             LDR      R1,??DataTable6_2  ;; 0x4006b007
   \   00000022   0x7008             STRB     R0,[R1, #+0]
    206                  }
    207          
    208          #if FMSTR_SCI_HAS_TXQUEUE
    209                  /* waiting for transmission complete flag? */
    210                  if(pcm_wFlags.flg.bTxWaitTC && (wSciSR & FMSTR_SCISR_TC))
    211                  {
    212                      /* after TC, we can switch to listen mode safely */
    213                      FMSTR_Listen();
    214                  }
    215          #endif
    216          
    217          
    218          #if !FMSTR_SCI_TWOWIRE_ONLY
    219                  /* read-out and ignore any received character (loopback) */
    220                  if(wSciSR & FMSTR_SCISR_RDRF)
   \                     ??FMSTR_ProcessSCI_1: (+1)
   \   00000024   0x06A0             LSLS     R0,R4,#+26
   \   00000026   0xD50F             BPL      ??FMSTR_ProcessSCI_2
    221                  {
    222                      /*lint -esym(550, nRxChar) */
    223                      volatile FMSTR_U16 nRxChar;
    224                      nRxChar = FMSTR_SCI_GETCHAR();
   \   00000028   0x....             LDR      R0,??DataTable6_2  ;; 0x4006b007
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0xB2C0             UXTB     R0,R0
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x8048             STRH     R0,[R1, #+2]
   \   00000032   0xE009             B        ??FMSTR_ProcessSCI_2
    225                  }
    226          #endif
    227              }
    228              /* transmitter not active, able to receive */
    229              else
    230              {
    231                  /* data byte received? */
    232                  if (wSciSR & FMSTR_SCISR_RDRF)
   \                     ??FMSTR_ProcessSCI_0: (+1)
   \   00000034   0x06A0             LSLS     R0,R4,#+26
   \   00000036   0xD507             BPL      ??FMSTR_ProcessSCI_2
    233                  {
    234                      FMSTR_BCHR nRxChar = 0U;
   \   00000038   0x2500             MOVS     R5,#+0
    235                      nRxChar = (FMSTR_BCHR) FMSTR_SCI_GETCHAR();
   \   0000003A   0x....             LDR      R0,??DataTable6_2  ;; 0x4006b007
   \   0000003C   0x7800             LDRB     R0,[R0, #+0]
   \   0000003E   0x0005             MOVS     R5,R0
    236          
    237          #if FMSTR_SHORT_INTR
    238                      FMSTR_RxQueue(nRxChar);
    239          #else
    240                      (void)FMSTR_Rx(nRxChar);
   \   00000040   0x0028             MOVS     R0,R5
   \   00000042   0xB2C0             UXTB     R0,R0
   \   00000044   0x.... 0x....      BL       FMSTR_Rx
    241          #endif
    242                  }
    243              }
    244          }
   \                     ??FMSTR_ProcessSCI_2: (+1)
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    245          
    246          #endif /* (FMSTR_USE_SCI) || (FMSTR_USE_LPUART) || (FMSTR_USE_ESCI) */
    247          
    248          
    249          #if FMSTR_USE_JTAG
    250          
    251          /***********************************
    252          *  local function prototypes
    253          ***********************************/
    254          
    255          static void FMSTR_FlushJtagTx(void);
    256          
    257          /**************************************************************************//*!
    258          *
    259          * @brief    Flush one communication JTAG word
    260          *
    261          * This function gets the 4 bytes from FreeMASTER TX buffer and place them to
    262          * JTAG transmit register.
    263          *
    264          ******************************************************************************/
    265          
    266          static void FMSTR_FlushJtagTx(void)
    267          {
    268              FMSTR_U8 i;
    269              FMSTR_U32 wJtagTxData;
    270              register FMSTR_U16 wJtagSR = FMSTR_JTAG_GETSR();
    271              /* complete word to send */
    272              for (i=0; i<4; i++)
    273              {
    274                  FMSTR_U8 ch;
    275                  if (FMSTR_Tx(&ch))
    276                      ch = 0xff;
    277                  wJtagTxData = (wJtagTxData << 8) | ch;
    278              }
    279          
    280              /* send the word just completed */
    281              FMSTR_JTAG_PUTDWORD(wJtagTxData);
    282          }
    283          
    284          /**************************************************************************//*!
    285          *
    286          * @brief    Handle JTAG communication (both TX and RX)
    287          *
    288          * This function checks the JTAG flags and calls the Rx and/or Tx functions
    289          *
    290          * @note This function can be called either from JTAG ISR or from the polling routine
    291          *
    292          ******************************************************************************/
    293          
    294          void FMSTR_ProcessJTAG(void)
    295          {
    296              /* read & clear status     */
    297              register FMSTR_U16 wJtagSR = FMSTR_JTAG_GETSR();
    298          
    299              /* transmitter active? */
    300              if (pcm_wFlags.flg.bTxActive)
    301              {
    302                  /* able to transmit a new character? (TX must be empty = read-out by PC) */
    303                  if(!(wJtagSR & FMSTR_JTAG_OTXRXSR_TDF))
    304                  {
    305          
    306          #if FMSTR_USE_JTAG_TXFIX
    307                      /* if TDF bit is useless due to silicon bug, use the RX flag */
    308                      /* instead (PC sends us a dummy word to kick the RX flag on) */
    309                      if(wJtagSR & FMSTR_JTAG_OTXRXSR_RDF)
    310          #endif
    311                      {
    312                          FMSTR_FlushJtagTx();
    313                      }
    314                  }
    315          
    316                  /* ignore (read-out) the JTAG-received word */
    317                  if(wJtagSR & FMSTR_JTAG_OTXRXSR_RDF)
    318                  {
    319                      /*lint -esym(550, nRxWord) */
    320                      volatile FMSTR_U16 nRxWord;
    321                      nRxWord = FMSTR_JTAG_GETWORD();
    322                  }
    323              }
    324              /* transmitter not active */
    325              else
    326              {
    327                  /* JTAG 32bit word (four bytes) received? */
    328                  if(wJtagSR & FMSTR_JTAG_OTXRXSR_RDF)
    329                  {
    330                      register FMSTR_U32 nRxDWord;
    331                      FMSTR_INDEX i;
    332          
    333                      nRxDWord = FMSTR_JTAG_GETDWORD();
    334          
    335                      /* process all bytes, MSB first */
    336                      for(i=0; i<4; i++)
    337                      {
    338          #if FMSTR_SHORT_INTR
    339                          FMSTR_RxQueue((FMSTR_BCHR)((nRxDWord >> 24U) & 0xffU));
    340          
    341          #else
    342                          (void)FMSTR_Rx((FMSTR_BCHR)((nRxDWord >> 24U) & 0xffU));
    343          
    344                          /* ignore the rest if previous bytes triggered a transmission */
    345                          /* (i.e. the packet was complete and only filled-up to 32bit word) */
    346                          if(pcm_wFlags.flg.bTxActive)
    347                          {
    348                              break;
    349                          }
    350          #endif
    351                          /* next byte of 32bit word */
    352                          nRxDWord = nRxDWord << 8;
    353                      }
    354                  }
    355              }
    356          }
    357          
    358          #endif /* FMSTR_USE_JTAG */
    359          
    360          /******************************************************************************
    361          ****************************************************************************//*!
    362          *
    363          * FreeMASTER MQX IO serial communication routines
    364          *
    365          *******************************************************************************/
    366          
    367          #if FMSTR_USE_MQX_IO
    368          
    369          #include <mqx.h>
    370          #include <bsp.h>
    371          
    372          /***********************************
    373          *  local variables
    374          ***********************************/
    375          
    376          static FILE_PTR devfd = NULL;       /* pointer to open FreeMASTER communication interface */
    377          
    378          /***********************************
    379          *  local function prototypes
    380          ***********************************/
    381          
    382          static FMSTR_BOOL FMSTR_InitMQX(void);
    383          static void FMSTR_ProcessMQXIO(void);
    384          
    385          /**************************************************************************//*!
    386          *
    387          * @brief    MQX communication interface initialization
    388          *
    389          ******************************************************************************/
    390          
    391          static FMSTR_BOOL FMSTR_InitMQX(void)
    392          {
    393              /* Open communication port */
    394              devfd = fopen (FMSTR_MQX_IO_CHANNEL, (char const *)FMSTR_MQX_IO_PARAMETER);
    395          
    396              return (devfd != NULL);
    397          }
    398          
    399          /*******************************************************************************
    400          *
    401          * @brief    Handle MQX IO serial communication (both TX and RX)
    402          *
    403          * This function calls MQX IO fread() function to get character and process it by
    404          *
    405          * FMSTR_Rx function when FreeMASTER packet is receiving. This function also transmit
    406          *
    407          * FreeMASTER response. Character to be send is provided by call of FMSTR_Tx function
    408          *
    409          * and passed down to fwrite() function.
    410          *
    411          *******************************************************************************/
    412          
    413          static void FMSTR_ProcessMQXIO(void)
    414          {
    415              if (devfd != NULL)
    416              {
    417                   static FMSTR_U8 TxChar = 0;
    418                  /* transmitter not active, able to receive */
    419                  if ((!pcm_wFlags.flg.bTxActive) && (!pcm_wFlags.flg.bMqxReadyToSend))
    420                  {
    421                      FMSTR_U8 nRxChar;
    422                      /* read all available bytes from communication interface */
    423                      while (fread(&nRxChar, 1, 1, devfd)) {
    424                          if(FMSTR_Rx(nRxChar))
    425                              break;
    426                      }
    427                  }
    428          
    429                  /* transmitter active and empty? */
    430                  if (pcm_wFlags.flg.bTxActive || pcm_wFlags.flg.bMqxReadyToSend)
    431                  {
    432                      while (1)
    433                      {
    434                          /* write character when is valid */
    435                          if (pcm_wFlags.flg.bMqxReadyToSend)
    436                          {
    437                              if (fwrite(&TxChar, 1, 1, devfd))
    438                                  /* character was successfully send, ready to get next character */
    439                                  pcm_wFlags.flg.bMqxReadyToSend = 0;
    440                              else
    441                                  /* character write failed, needs to be send next call */
    442                                  break;
    443          
    444                          }
    445                          /* is ready to get next character? */
    446                          if (FMSTR_Tx((FMSTR_U8*)&TxChar))
    447                              /* FreeMASTER packet is sent, exit loop */
    448                              break;
    449                          /* read next character, set its validity to be send */
    450                          pcm_wFlags.flg.bMqxReadyToSend = 1;
    451                      }
    452                  }
    453              }
    454          }
    455          
    456          #else /* FMSTR_USE_MQX_IO */
    457          
    458          /*lint -efile(766, freemaster_protocol.h) include file is not used in this case */
    459          
    460          #endif /* FMSTR_USE_MQX_IO */
    461          
    462          /******************************************************************************
    463          ****************************************************************************//*!
    464          *
    465          * FreeMASTER USB CDC serial communication routines
    466          *
    467          *******************************************************************************/
    468          
    469          #if FMSTR_USE_USB_CDC
    470          #include "usb_cdc.h"        /* USB CDC Class Header File */
    471          
    472          /***********************************
    473          *  Global variables
    474          ***********************************/
    475          FMSTR_U8 send_buf[DIC_BULK_IN_ENDP_PACKET_SIZE]; //buffer for store packet to send
    476          
    477          /***********************************
    478          *  local function prototypes
    479          ***********************************/
    480          
    481          static FMSTR_BOOL FMSTR_InitUSB(void);
    482          static void FMSTR_ProcessUSB(void);
    483          static void FMSTR_SendUsbPacket(void);
    484          
    485          static void FMSTR_USB_CDC_Callback(FMSTR_U8 controller_ID,
    486                                  FMSTR_U8 event_type, void* val);
    487          static void FMSTR_USB_CDC_Notify_Callback(FMSTR_U8 controller_ID,
    488                                  FMSTR_U8 event_type, void* val);
    489          
    490          /**************************************************************************//*!
    491          *
    492          * @brief    USB CDC communication interface initialization
    493          *
    494          ******************************************************************************/
    495          
    496          static FMSTR_BOOL FMSTR_InitUSB(void)
    497          {
    498              FMSTR_U8   error;
    499          
    500              /* Initialize the USB interface */
    501              error = USB_Class_CDC_Init(FMSTR_USB_CDC_ID,FMSTR_USB_CDC_Callback,
    502                                          NULL,FMSTR_USB_CDC_Notify_Callback, TRUE);
    503              if(error != USB_OK)
    504              {
    505                  /* Error initializing USB-CDC Class */
    506                  return FMSTR_FALSE;
    507              }
    508          
    509              return FMSTR_TRUE;
    510          }
    511          
    512          /**************************************************************************//*!
    513          *
    514          * @brief    Handle USB CDC class periodic task and initialize FreeMASTER TX packet
    515          *
    516          * This function perform USB CDC periodic task. In Short Interrupt mode also decode
    517          * received FreeMASTER packet and initialize transmit
    518          *
    519          ******************************************************************************/
    520          static void FMSTR_ProcessUSB(void)
    521          {
    522              /* call the periodic task function */
    523              USB_Class_CDC_Periodic_Task();
    524          
    525          #if FMSTR_SHORT_INTR
    526              /*check whether enumeration is complete or not */
    527              if((pcm_wFlags.flg.bUsbCdcStartApp) && (pcm_wFlags.flg.bUsbCdcStartTrans))
    528              {
    529                  /*transmitter not active, able to receive */
    530                  if ((!pcm_wFlags.flg.bTxActive) && (pcm_wFlags.flg.bUsbReadyToDecode))
    531                  {
    532                      FMSTR_ProtocolDecoder(pcm_pCommBuffer);
    533                      pcm_wFlags.flg.bUsbReadyToDecode = 0;
    534                  }
    535              }
    536          #endif
    537          }
    538          
    539          
    540          /**************************************************************************//*!
    541          *
    542          * @brief    Get data from FreeMASTER TX buffer and send the data to USB device
    543          *
    544          * This function checks the FreeMASTER transmit state and when FreeMASTER is
    545          * ready to send response to PC, copy FreeMASTER TX data to local buffer and
    546          * pass down the buffer to USB CDC TX function.
    547          *
    548          ******************************************************************************/
    549          
    550          static void FMSTR_SendUsbPacket(void)
    551          {
    552              /* transmitter active and empty? */
    553              if (pcm_wFlags.flg.bTxActive)
    554              {
    555                  FMSTR_U8 index;
    556          
    557                  /* fill in the transmitter buffer */
    558                  for (index = 0; index < DIC_BULK_IN_ENDP_PACKET_SIZE; index++){
    559                      FMSTR_U8 TxChar;
    560                      if (FMSTR_Tx(&TxChar))
    561                          break;
    562                      send_buf[index] = TxChar;
    563                  }
    564          
    565                 USB_Class_CDC_Interface_DIC_Send_Data(FMSTR_USB_CDC_ID, send_buf,index);
    566              }
    567          }
    568          
    569          /******************************************************************************
    570           *
    571           *    @name        FMSTR_USB_CDC_Callback
    572           *
    573           *    @brief       This function handles Class callback
    574           *
    575           *    @param       controller_ID    : Controller ID
    576           *    @param       event_type       : Value of the event
    577           *    @param       val              : gives the configuration value
    578           *
    579           *    @return      None
    580           *
    581           *****************************************************************************
    582           * This function is called from the class layer whenever reset occurs or enum
    583           * is complete. After the enum is complete this function sets a variable so
    584           * that the application can start.
    585           * This function also receives DATA Send and RECEIVED Events
    586           *****************************************************************************/
    587          
    588          static void FMSTR_USB_CDC_Callback (
    589              FMSTR_U8 controller_ID,   /* [IN] Controller ID */
    590              FMSTR_U8 event_type,      /* [IN] value of the event */
    591              void* val               /* [IN] gives the configuration value */
    592          )
    593          {
    594              UNUSED (controller_ID)
    595              UNUSED (val)
    596              if(event_type == USB_APP_BUS_RESET)
    597              {
    598                  pcm_wFlags.flg.bUsbCdcStartApp = 0U;
    599              }
    600              else if(event_type == USB_APP_ENUM_COMPLETE)
    601              {
    602                  pcm_wFlags.flg.bUsbCdcStartApp = 1U;
    603              }
    604              else if((event_type == USB_APP_DATA_RECEIVED) && (pcm_wFlags.flg.bUsbCdcStartTrans))
    605              {
    606                  /* manage received data */
    607                  if (pcm_wFlags.flg.bUsbCdcStartApp)
    608                  {
    609                      /* Copy Received Data buffer to Application Buffer */
    610                      USB_PACKET_SIZE BytesToBeCopied;
    611                      APP_DATA_STRUCT* dp_rcv = (APP_DATA_STRUCT*)val;
    612                      BytesToBeCopied = dp_rcv->data_size;
    613          
    614                      /* transmitter not active, able to receive */
    615                      if (!pcm_wFlags.flg.bTxActive)
    616                      {
    617                          FMSTR_U8 index;
    618                          for(index = 0 ; index<BytesToBeCopied ; index++){
    619                              if(FMSTR_Rx(dp_rcv->data_ptr[index])){
    620                                  break;
    621                              }
    622                          }
    623                          /* continue receiving, when packet is not decoded */
    624                          if (index == BytesToBeCopied) /* receive next packet only when are not received all bytes of packet */
    625                              (void)USB_Class_CDC_Interface_DIC_Recv_Data(FMSTR_USB_CDC_ID, NULL, 0);
    626                      }
    627                  }
    628              }
    629              else if((event_type == USB_APP_SEND_COMPLETE) && (pcm_wFlags.flg.bUsbCdcStartTrans))
    630              {
    631                  if ((pcm_wFlags.flg.bUsbCdcStartApp) && (pcm_wFlags.flg.bTxActive))
    632                      /* Finalize USB packet to transmit and send packet */
    633                      FMSTR_SendUsbPacket();
    634                  else
    635                      /* Previous Send is complete. Queue next receive */
    636                      (void)USB_Class_CDC_Interface_DIC_Recv_Data(FMSTR_USB_CDC_ID, NULL, 0);
    637              }
    638          
    639              return;
    640          }
    641          
    642          /******************************************************************************
    643           *
    644           *    @name        FMSTR_USB_CDC_Notify_Callback
    645           *
    646           *    @brief       This function handles PSTN Sub Class callbacks
    647           *
    648           *    @param       controller_ID    : Controller ID
    649           *    @param       event_type       : PSTN Event Type
    650           *    @param       val              : gives the configuration value
    651           *
    652           *    @return      None
    653           *
    654           *****************************************************************************
    655           * This function handles USB_APP_CDC_CARRIER_ACTIVATED and
    656           * USB_APP_CDC_CARRIER_DEACTIVATED PSTN Events
    657           *****************************************************************************/
    658          
    659          static void FMSTR_USB_CDC_Notify_Callback (
    660              FMSTR_U8 controller_ID,   /* [IN] Controller ID */
    661              FMSTR_U8 event_type,      /* [IN] PSTN Event Type */
    662              void* val               /* [IN] gives the configuration value */
    663          )
    664          {
    665              UNUSED (controller_ID)
    666              UNUSED (val)
    667              if(pcm_wFlags.flg.bUsbCdcStartApp)
    668              {
    669                  if(event_type == USB_APP_CDC_CARRIER_ACTIVATED)
    670                  {
    671                      pcm_wFlags.flg.bUsbCdcStartTrans = 1U;
    672                  }
    673                  else if(event_type == USB_APP_CDC_CARRIER_DEACTIVATED)
    674                  {
    675                      pcm_wFlags.flg.bUsbCdcStartTrans = 0U;
    676                  }
    677              }
    678              return;
    679          }
    680          
    681          #else /* FMSTR_USE_USB_CDC */
    682          
    683          /*lint -efile(766, freemaster_protocol.h) include file is not used in this case */
    684          
    685          #endif /* FMSTR_USE_USB_CDC */
    686          
    687          
    688          #if FMSTR_USE_SERIAL
    689          
    690          /**************************************************************************//*!
    691          *
    692          * @brief    Start listening on a serial line
    693          *
    694          * Reset the receiver machine and start listening on a serial line
    695          *
    696          ******************************************************************************/
    697          

   \                                 In section .text, align 2, keep-with-next
    698          static void FMSTR_Listen(void)
    699          {
    700              pcm_nRxTodo = 0U;
   \                     FMSTR_Listen: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR      R1,??DataTable6_3
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    701          
    702              /* disable transmitter state machine */
    703              pcm_wFlags.flg.bTxActive = 0U;
   \   00000006   0x....             LDR      R0,??DataTable6_1
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x4388             BICS     R0,R0,R1
   \   0000000E   0x....             LDR      R1,??DataTable6_1
   \   00000010   0x6008             STR      R0,[R1, #+0]
    704          
    705          #if (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART)
    706              pcm_wFlags.flg.bTxWaitTC = 0U;
   \   00000012   0x....             LDR      R0,??DataTable6_1
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x4388             BICS     R0,R0,R1
   \   0000001A   0x....             LDR      R1,??DataTable6_1
   \   0000001C   0x6008             STR      R0,[R1, #+0]
    707              /* disable transmitter, enable receiver (enables single-wire connection) */
    708          #if !FMSTR_SCI_TWOWIRE_ONLY
    709              FMSTR_SCI_TD();
   \   0000001E   0x....             LDR      R0,??DataTable6_4  ;; 0x4006b003
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0x21F7             MOVS     R1,#+247
   \   00000024   0x4001             ANDS     R1,R1,R0
   \   00000026   0x....             LDR      R0,??DataTable6_4  ;; 0x4006b003
   \   00000028   0x7001             STRB     R1,[R0, #+0]
    710              FMSTR_SCI_RE();
   \   0000002A   0x....             LDR      R0,??DataTable6_4  ;; 0x4006b003
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0x2104             MOVS     R1,#+4
   \   00000030   0x4301             ORRS     R1,R1,R0
   \   00000032   0x....             LDR      R0,??DataTable6_4  ;; 0x4006b003
   \   00000034   0x7001             STRB     R1,[R0, #+0]
    711          #endif
    712          #endif /* (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART) */
    713          
    714              /* disable transmit, enable receive interrupts */
    715          #if FMSTR_SHORT_INTR || FMSTR_LONG_INTR
    716          #if (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART)
    717              FMSTR_SCI_DTXI();   /* disable SCI transmit interrupt */
    718              FMSTR_SCI_ERXI();   /* enable SCI receive interrupt */
    719          
    720          #elif FMSTR_USE_JTAG
    721              FMSTR_JTAG_DTXI();  /* disable JTAG transmit interrupt  */
    722              FMSTR_JTAG_ERXI();  /* enable JTAG receive interrupt  */
    723          
    724              /* RIE bit is forced low by HW until EONCE is first accessed, we will try again in FMSTR_Poll */
    725              if(!FMSTR_JTAG_ERXI_CHECK())
    726                  pcm_wFlags.flg.bJtagRIEPending = 1;
    727          
    728          #endif /* (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART) / FMSTR_USE_JTAG  */
    729          #endif /* FMSTR_SHORT_INTR || FMSTR_LONG_INTR */
    730          }
   \   00000036   0x4770             BX       LR               ;; return
    731          
    732          /**************************************************************************//*!
    733          *
    734          * @brief    Send response of given error code (no data)
    735          *
    736          * @param    nErrCode - error code to be sent
    737          *
    738          ******************************************************************************/
    739          

   \                                 In section .text, align 2, keep-with-next
    740          static void FMSTR_SendError(FMSTR_BCHR nErrCode)
    741          {
   \                     FMSTR_SendError: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    742              /* fill & send single-byte response */
    743              *pcm_pCommBuffer = nErrCode;
   \   00000004   0x....             LDR      R0,??DataTable6_5
   \   00000006   0x7004             STRB     R4,[R0, #+0]
    744              FMSTR_SendResponse(pcm_pCommBuffer, 1U);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x....             LDR      R0,??DataTable6_5
   \   0000000C   0x.... 0x....      BL       FMSTR_SendResponse
    745          }
   \   00000010   0xBD10             POP      {R4,PC}          ;; return
    746          
    747          /**************************************************************************//*!
    748          *
    749          * @brief    Finalize transmit buffer before transmitting
    750          *
    751          * @param    nLength - response length (1 for status + data length)
    752          *
    753          *
    754          * This Function takes the data already prepared in the transmit buffer
    755          * (inlcuding the status byte). It computes the check sum and kicks on tx.
    756          *
    757          ******************************************************************************/
    758          

   \                                 In section .text, align 2, keep-with-next
    759          void FMSTR_SendResponse(FMSTR_BPTR pResponse, FMSTR_SIZE8 nLength)
    760          {
   \                     FMSTR_SendResponse: (+1)
   \   00000000   0xB578             PUSH     {R3-R6,LR}
    761              FMSTR_U16 chSum = 0U;
   \   00000002   0x2200             MOVS     R2,#+0
    762              FMSTR_SIZE8 i;
    763              FMSTR_U8 c;
    764          
    765              /* remember the buffer to be sent */
    766              pcm_pTxBuff = pResponse;
   \   00000004   0x....             LDR      R5,??DataTable6_6
   \   00000006   0x6028             STR      R0,[R5, #+0]
    767          
    768              /* status byte and data are already there, compute checksum only     */
    769              for (i=0U; i<nLength; i++)
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x002B             MOVS     R3,R5
   \                     ??FMSTR_SendResponse_0: (+1)
   \   0000000C   0xB2DB             UXTB     R3,R3
   \   0000000E   0xB2C9             UXTB     R1,R1
   \   00000010   0x428B             CMP      R3,R1
   \   00000012   0xD209             BCS      ??FMSTR_SendResponse_1
    770              {
    771                  c = 0U;
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0x002C             MOVS     R4,R5
    772                  pResponse = FMSTR_ValueFromBuffer8(&c, pResponse);
   \   00000018   0x7805             LDRB     R5,[R0, #+0]
   \   0000001A   0x002C             MOVS     R4,R5
   \   0000001C   0x1C40             ADDS     R0,R0,#+1
    773                  /* add character to checksum */
    774                  chSum += c;
   \   0000001E   0xB2E4             UXTB     R4,R4
   \   00000020   0x1912             ADDS     R2,R2,R4
    775                  /* prevent saturation to happen on DSP platforms */
    776                  chSum &= 0xffU;
   \   00000022   0xB2D2             UXTB     R2,R2
    777              }
   \   00000024   0x1C5B             ADDS     R3,R3,#+1
   \   00000026   0xE7F1             B        ??FMSTR_SendResponse_0
    778          
    779              /* store checksum after the message */
    780              pResponse = FMSTR_ValueToBuffer8(pResponse, (FMSTR_U8) (((FMSTR_U8)(~chSum)) + 1U));
   \                     ??FMSTR_SendResponse_1: (+1)
   \   00000028   0x0015             MOVS     R5,R2
   \   0000002A   0x43EE             MVNS     R6,R5
   \   0000002C   0x1C76             ADDS     R6,R6,#+1
   \   0000002E   0x7006             STRB     R6,[R0, #+0]
   \   00000030   0x1C40             ADDS     R0,R0,#+1
    781          
    782              /* send the message and the checksum and the SOB */
    783              pcm_nTxTodo = (FMSTR_SIZE8) (nLength + 1U);
   \   00000032   0x000D             MOVS     R5,R1
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   \   00000036   0x....             LDR      R6,??DataTable6_7
   \   00000038   0x7035             STRB     R5,[R6, #+0]
    784          
    785              /* now transmitting the response */
    786              pcm_wFlags.flg.bTxActive = 1U;
   \   0000003A   0x....             LDR      R5,??DataTable6_1
   \   0000003C   0x682D             LDR      R5,[R5, #+0]
   \   0000003E   0x2601             MOVS     R6,#+1
   \   00000040   0x432E             ORRS     R6,R6,R5
   \   00000042   0x....             LDR      R5,??DataTable6_1
   \   00000044   0x602E             STR      R6,[R5, #+0]
    787          
    788          #if (FMSTR_USE_USB_CDC) || (FMSTR_USE_MQX_IO) || (FMSTR_USE_JTAG)
    789              pcm_wFlags.flg.bTxFirstSobSend = 1U;
    790          #endif
    791          
    792          #if (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART)
    793              pcm_wFlags.flg.bTxWaitTC = 0U;
   \   00000046   0x....             LDR      R5,??DataTable6_1
   \   00000048   0x682D             LDR      R5,[R5, #+0]
   \   0000004A   0x2602             MOVS     R6,#+2
   \   0000004C   0x43B5             BICS     R5,R5,R6
   \   0000004E   0x....             LDR      R6,??DataTable6_1
   \   00000050   0x6035             STR      R5,[R6, #+0]
    794          #endif
    795          
    796              /* do not replicate the initial SOB  */
    797              pcm_wFlags.flg.bTxLastCharSOB = 0U;
   \   00000052   0x....             LDR      R5,??DataTable6_1
   \   00000054   0x682D             LDR      R5,[R5, #+0]
   \   00000056   0x2604             MOVS     R6,#+4
   \   00000058   0x43B5             BICS     R5,R5,R6
   \   0000005A   0x....             LDR      R6,??DataTable6_1
   \   0000005C   0x6035             STR      R5,[R6, #+0]
    798          
    799          #if (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART)
    800              {
    801                  /*lint -esym(550, dummySR) */
    802                  volatile FMSTR_SCISR dummySR;
    803          
    804                  /* disable receiver, enable transmitter (single-wire communication) */
    805          #if !FMSTR_SCI_TWOWIRE_ONLY
    806                  FMSTR_SCI_RD();
   \   0000005E   0x....             LDR      R5,??DataTable6_4  ;; 0x4006b003
   \   00000060   0x782D             LDRB     R5,[R5, #+0]
   \   00000062   0x26FB             MOVS     R6,#+251
   \   00000064   0x402E             ANDS     R6,R6,R5
   \   00000066   0x....             LDR      R5,??DataTable6_4  ;; 0x4006b003
   \   00000068   0x702E             STRB     R6,[R5, #+0]
    807                  FMSTR_SCI_TE();
   \   0000006A   0x....             LDR      R5,??DataTable6_4  ;; 0x4006b003
   \   0000006C   0x782D             LDRB     R5,[R5, #+0]
   \   0000006E   0x2608             MOVS     R6,#+8
   \   00000070   0x432E             ORRS     R6,R6,R5
   \   00000072   0x....             LDR      R5,??DataTable6_4  ;; 0x4006b003
   \   00000074   0x702E             STRB     R6,[R5, #+0]
    808          #endif
    809                  /* kick on the SCI transmission (also clears TX Empty flag on some platforms) */
    810                  dummySR = FMSTR_SCI_GETSR();
   \   00000076   0x....             LDR      R5,??DataTable6  ;; 0x4006b004
   \   00000078   0x782D             LDRB     R5,[R5, #+0]
   \   0000007A   0x466E             MOV      R6,SP
   \   0000007C   0x7035             STRB     R5,[R6, #+0]
    811                  FMSTR_SCI_PUTCHAR(FMSTR_SOB);
   \   0000007E   0x252B             MOVS     R5,#+43
   \   00000080   0x....             LDR      R6,??DataTable6_2  ;; 0x4006b007
   \   00000082   0x7035             STRB     R5,[R6, #+0]
    812              }
    813          
    814          #elif FMSTR_USE_JTAG
    815              /* kick on the JTAG transmission */
    816              FMSTR_FlushJtagTx();
    817          #endif
    818          
    819              /* TX interrupt enable, RX interrupt disable */
    820          #if (FMSTR_LONG_INTR) || (FMSTR_SHORT_INTR)
    821          #if (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART)
    822              FMSTR_SCI_DRXI();
    823              FMSTR_SCI_ETXI();
    824          
    825          #elif FMSTR_USE_JTAG
    826          #if FMSTR_USE_JTAG_TXFIX
    827              /* in TX-bugfix mode, keep the RX interrupt enabled as it */
    828              /* is used as "able-to-TX" notification from the PC */
    829              FMSTR_JTAG_ERXI();
    830          #else
    831              /* otherwise, JTAG is very same as the SCI */
    832              if(pcm_wFlags.flg.bTxActive) //enable TX interrupt only when is not one word response
    833              {
    834                  FMSTR_JTAG_DRXI();
    835                  FMSTR_JTAG_ETXI();
    836              }
    837          #endif
    838          
    839          #elif FMSTR_USE_USB_CDC
    840              if ((pcm_wFlags.flg.bUsbCdcStartApp) && (pcm_wFlags.flg.bTxActive) && (pcm_wFlags.flg.bUsbCdcStartTrans))
    841                  /* Finalize USB packet to transmit and send packet */
    842                  FMSTR_SendUsbPacket();
    843              else
    844                  /* Previous Send is complete. Queue next receive */
    845                  (void)USB_Class_CDC_Interface_DIC_Recv_Data(FMSTR_USB_CDC_ID, NULL, 0);
    846          #endif
    847          #endif /* FMSTR_LONG_INTR || FMSTR_SHORT_INTR */
    848          }
   \   00000084   0xBD71             POP      {R0,R4-R6,PC}    ;; return
    849          
    850          /**************************************************************************//*!
    851          *
    852          * @brief    Output buffer transmission
    853          *
    854          * @param  pTxChar  The character to be transmit
    855          *
    856          * get ready buffer(prepare data to send)
    857          *
    858          ******************************************************************************/
    859          

   \                                 In section .text, align 2, keep-with-next
    860          FMSTR_BOOL FMSTR_Tx(FMSTR_U8* pTxChar)
    861          {
   \                     FMSTR_Tx: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    862          #if (FMSTR_USE_USB_CDC) || (FMSTR_USE_MQX_IO) || (FMSTR_USE_JTAG)
    863              /* to send first SOB byte*/
    864              if (pcm_wFlags.flg.bTxFirstSobSend)
    865              {
    866                  *pTxChar = FMSTR_SOB;
    867                  pcm_wFlags.flg.bTxFirstSobSend = 0U;
    868                  return FMSTR_FALSE;
    869              }
    870          #endif
    871              if (pcm_nTxTodo)
   \   00000004   0x....             LDR      R0,??DataTable6_7
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD024             BEQ      ??FMSTR_Tx_0
    872              {
    873                  /* fetch & send character ready to transmit */
    874                  /*lint -e{534} ignoring return value */
    875                  (void)FMSTR_ValueFromBuffer8(pTxChar, pcm_pTxBuff);
   \   0000000C   0x....             LDR      R0,??DataTable6_6
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x7020             STRB     R0,[R4, #+0]
   \   00000014   0x....             LDR      R0,??DataTable6_6
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
    876          
    877                  /* first, handle the replicated SOB characters */
    878                  if (*pTxChar == FMSTR_SOB)
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x282B             CMP      R0,#+43
   \   0000001E   0xD10E             BNE      ??FMSTR_Tx_1
    879                  {
    880                      pcm_wFlags.flg.bTxLastCharSOB ^= 1U;
   \   00000020   0x....             LDR      R0,??DataTable6_1
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2104             MOVS     R1,#+4
   \   00000026   0x4041             EORS     R1,R1,R0
   \   00000028   0x....             LDR      R0,??DataTable6_1
   \   0000002A   0x6001             STR      R1,[R0, #+0]
    881                      if ((pcm_wFlags.flg.bTxLastCharSOB))
   \   0000002C   0x....             LDR      R0,??DataTable6_1
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0x0001             MOVS     R1,R0
   \   00000032   0x0749             LSLS     R1,R1,#+29       ;; ZeroExtS R1,R1,#+29,#+31
   \   00000034   0x0FC9             LSRS     R1,R1,#+31
   \   00000036   0x2900             CMP      R1,#+0
   \   00000038   0xD001             BEQ      ??FMSTR_Tx_1
    882                      {
    883                          /* yes, repeat the SOB next time */
    884                          return FMSTR_FALSE;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xE00E             B        ??FMSTR_Tx_2
    885                      }
    886                  }
    887                  /* no, advance tx buffer pointer */
    888                  pcm_nTxTodo--;
   \                     ??FMSTR_Tx_1: (+1)
   \   0000003E   0x....             LDR      R0,??DataTable6_7
   \   00000040   0x7800             LDRB     R0,[R0, #+0]
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x....             LDR      R1,??DataTable6_7
   \   00000046   0x7008             STRB     R0,[R1, #+0]
    889                  pcm_pTxBuff = FMSTR_SkipInBuffer(pcm_pTxBuff, 1U);
   \   00000048   0x....             LDR      R0,??DataTable6_6
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x....             LDR      R1,??DataTable6_6
   \   00000050   0x6008             STR      R0,[R1, #+0]
    890                  return FMSTR_FALSE;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE002             B        ??FMSTR_Tx_2
    891              }
    892          
    893              /* when SCI TX buffering is enabled, we must first wait until all
    894                 characters are physically transmitted (before disabling transmitter) */
    895          #if (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART)
    896            #if FMSTR_SCI_HAS_TXQUEUE
    897              pcm_wFlags.flg.bTxWaitTC = 1;
    898          
    899              /* wait for SCI TC interrupt */
    900              #if FMSTR_SHORT_INTR || FMSTR_LONG_INTR
    901              FMSTR_SCI_ETCI();
    902              #endif
    903            #else
    904              /* start listening immediately */
    905              FMSTR_Listen();
   \                     ??FMSTR_Tx_0: (+1)
   \   00000056   0x.... 0x....      BL       FMSTR_Listen
    906            #endif
    907          #else
    908              /* start listening immediately */
    909              FMSTR_Listen();
    910          #endif
    911          
    912              return FMSTR_TRUE;
   \   0000005A   0x2001             MOVS     R0,#+1
   \                     ??FMSTR_Tx_2: (+1)
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    913          }
    914          
    915          
    916          /**************************************************************************//*!
    917          *
    918          * @brief  Handle received character
    919          *
    920          * @param  nRxChar  The character to be processed
    921          *
    922          * Handle the character received and -if the message is complete- call the
    923          * protocol decode routine.
    924          *
    925          ******************************************************************************/
    926          

   \                                 In section .text, align 2, keep-with-next
    927          FMSTR_BOOL FMSTR_Rx(FMSTR_BCHR nRxChar)
    928          {
   \                     FMSTR_Rx: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    929              FMSTR_SERIAL_FLAGS * pflg = &pcm_wFlags;
   \   00000004   0x....             LDR      R5,??DataTable6_1
    930              /* first, handle the replicated SOB characters */
    931              if(nRxChar == FMSTR_SOB)
   \   00000006   0xB2E4             UXTB     R4,R4
   \   00000008   0x2C2B             CMP      R4,#+43
   \   0000000A   0xD10B             BNE      ??FMSTR_Rx_0
    932              {
    933                  pflg->flg.bRxLastCharSOB ^= 1;
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x2108             MOVS     R1,#+8
   \   00000010   0x4041             EORS     R1,R1,R0
   \   00000012   0x6029             STR      R1,[R5, #+0]
    934                  if(pflg->flg.bRxLastCharSOB)
   \   00000014   0x6828             LDR      R0,[R5, #+0]
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0x0709             LSLS     R1,R1,#+28       ;; ZeroExtS R1,R1,#+28,#+31
   \   0000001A   0x0FC9             LSRS     R1,R1,#+31
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD001             BEQ      ??FMSTR_Rx_0
    935                  {
    936                      /* this is either the first byte of replicated SOB or a  */
    937                      /* real Start-of-Block mark - we will decide next time in FMSTR_Rx */
    938                      return FMSTR_FALSE;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xE07B             B        ??FMSTR_Rx_1
    939                  }
    940              }
    941          
    942              /* we have got a common character preceded by the SOB -  */
    943              /* this is the command code! */
    944              if(pflg->flg.bRxLastCharSOB)
   \                     ??FMSTR_Rx_0: (+1)
   \   00000024   0x6828             LDR      R0,[R5, #+0]
   \   00000026   0x0001             MOVS     R1,R0
   \   00000028   0x0709             LSLS     R1,R1,#+28       ;; ZeroExtS R1,R1,#+28,#+31
   \   0000002A   0x0FC9             LSRS     R1,R1,#+31
   \   0000002C   0x2900             CMP      R1,#+0
   \   0000002E   0xD02A             BEQ      ??FMSTR_Rx_2
    945              {
    946                  /* reset receiving process */
    947                  pcm_pRxBuff = pcm_pCommBuffer;
   \   00000030   0x....             LDR      R0,??DataTable6_5
   \   00000032   0x....             LDR      R1,??DataTable6_8
   \   00000034   0x6008             STR      R0,[R1, #+0]
    948                  *pcm_pRxBuff++ = nRxChar;
   \   00000036   0x....             LDR      R0,??DataTable6_8
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x7004             STRB     R4,[R0, #+0]
   \   0000003C   0x....             LDR      R0,??DataTable6_8
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x....             LDR      R1,??DataTable6_8
   \   00000044   0x6008             STR      R0,[R1, #+0]
    949          
    950                  /* start computing the checksum */
    951                  pcm_nRxCheckSum = nRxChar;
   \   00000046   0x....             LDR      R0,??DataTable6_9
   \   00000048   0x7004             STRB     R4,[R0, #+0]
    952                  pcm_nRxTodo = 0U;
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x....             LDR      R1,??DataTable6_3
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
    953          
    954                  /* if the standard command was received, the message length will come in next byte */
    955                  pflg->flg.bRxMsgLengthNext = 1U;
   \   00000050   0x6828             LDR      R0,[R5, #+0]
   \   00000052   0x2110             MOVS     R1,#+16
   \   00000054   0x4301             ORRS     R1,R1,R0
   \   00000056   0x6029             STR      R1,[R5, #+0]
    956          
    957                  /* fast command? */
    958                  if(!((~nRxChar) & FMSTR_FASTCMD))
   \   00000058   0xB2E4             UXTB     R4,R4
   \   0000005A   0x43E0             MVNS     R0,R4
   \   0000005C   0x21C0             MOVS     R1,#+192
   \   0000005E   0x4208             TST      R0,R1
   \   00000060   0xD10B             BNE      ??FMSTR_Rx_3
    959                  {
    960                      /* fast command received, there will be no length information */
    961                      pflg->flg.bRxMsgLengthNext = 0U;
   \   00000062   0x6828             LDR      R0,[R5, #+0]
   \   00000064   0x2110             MOVS     R1,#+16
   \   00000066   0x4388             BICS     R0,R0,R1
   \   00000068   0x6028             STR      R0,[R5, #+0]
    962                      /* as it is encoded in the command byte directly */
    963                      pcm_nRxTodo = (FMSTR_SIZE8)
    964                          (((((FMSTR_SIZE8)nRxChar) & FMSTR_FASTCMD_DATALEN_MASK) >> FMSTR_FASTCMD_DATALEN_SHIFT) + 1U);
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0xB2C0             UXTB     R0,R0
   \   0000006E   0x08C0             LSRS     R0,R0,#+3
   \   00000070   0x2106             MOVS     R1,#+6
   \   00000072   0x4001             ANDS     R1,R1,R0
   \   00000074   0x1C49             ADDS     R1,R1,#+1
   \   00000076   0x....             LDR      R0,??DataTable6_3
   \   00000078   0x7001             STRB     R1,[R0, #+0]
    965                  }
    966          
    967                  /* command code stored & processed */
    968                  pflg->flg.bRxLastCharSOB = 0U;
   \                     ??FMSTR_Rx_3: (+1)
   \   0000007A   0x6828             LDR      R0,[R5, #+0]
   \   0000007C   0x2108             MOVS     R1,#+8
   \   0000007E   0x4388             BICS     R0,R0,R1
   \   00000080   0x6028             STR      R0,[R5, #+0]
    969                  return FMSTR_FALSE;
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0xE04A             B        ??FMSTR_Rx_1
    970              }
    971          
    972              /* we are waiting for the length byte */
    973              if(pflg->flg.bRxMsgLengthNext)
   \                     ??FMSTR_Rx_2: (+1)
   \   00000086   0x6828             LDR      R0,[R5, #+0]
   \   00000088   0x0001             MOVS     R1,R0
   \   0000008A   0x06C9             LSLS     R1,R1,#+27       ;; ZeroExtS R1,R1,#+27,#+31
   \   0000008C   0x0FC9             LSRS     R1,R1,#+31
   \   0000008E   0x2900             CMP      R1,#+0
   \   00000090   0xD007             BEQ      ??FMSTR_Rx_4
    974              {
    975                  /* this byte, total data length and the checksum */
    976                  pcm_nRxTodo = (FMSTR_SIZE8) (1U + ((FMSTR_SIZE8)nRxChar) + 1U);
   \   00000092   0x0020             MOVS     R0,R4
   \   00000094   0x1C80             ADDS     R0,R0,#+2
   \   00000096   0x....             LDR      R1,??DataTable6_3
   \   00000098   0x7008             STRB     R0,[R1, #+0]
    977                  /* now read the data bytes */
    978                  pflg->flg.bRxMsgLengthNext = 0U;
   \   0000009A   0x6828             LDR      R0,[R5, #+0]
   \   0000009C   0x2110             MOVS     R1,#+16
   \   0000009E   0x4388             BICS     R0,R0,R1
   \   000000A0   0x6028             STR      R0,[R5, #+0]
    979          
    980              }
    981          
    982              /* waiting for a data byte? */
    983              if(pcm_nRxTodo)
   \                     ??FMSTR_Rx_4: (+1)
   \   000000A2   0x....             LDR      R0,??DataTable6_3
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x2800             CMP      R0,#+0
   \   000000A8   0xD037             BEQ      ??FMSTR_Rx_5
    984              {
    985                  /* add this byte to checksum */
    986                  pcm_nRxCheckSum += nRxChar;
   \   000000AA   0x....             LDR      R0,??DataTable6_9
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0x1900             ADDS     R0,R0,R4
   \   000000B0   0x....             LDR      R1,??DataTable6_9
   \   000000B2   0x7008             STRB     R0,[R1, #+0]
    987          
    988                  /* decrease number of expected bytes */
    989                  pcm_nRxTodo--;
   \   000000B4   0x....             LDR      R0,??DataTable6_3
   \   000000B6   0x7800             LDRB     R0,[R0, #+0]
   \   000000B8   0x1E40             SUBS     R0,R0,#+1
   \   000000BA   0x....             LDR      R1,??DataTable6_3
   \   000000BC   0x7008             STRB     R0,[R1, #+0]
    990                  /* was it the last byte of the message (checksum)? */
    991                  if(!pcm_nRxTodo)
   \   000000BE   0x....             LDR      R0,??DataTable6_3
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD114             BNE      ??FMSTR_Rx_6
    992                  {
    993                      /* receive buffer overflow? */
    994                      if(pcm_pRxBuff == NULL)
   \   000000C6   0x....             LDR      R0,??DataTable6_8
   \   000000C8   0x6800             LDR      R0,[R0, #+0]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD103             BNE      ??FMSTR_Rx_7
    995                      {
    996                          FMSTR_SendError(FMSTR_STC_CMDTOOLONG);
   \   000000CE   0x2083             MOVS     R0,#+131
   \   000000D0   0x.... 0x....      BL       FMSTR_SendError
   \   000000D4   0xE00A             B        ??FMSTR_Rx_8
    997                      }
    998                      /* checksum error? */
    999                      else if((pcm_nRxCheckSum & 0xffU) != 0U)
   \                     ??FMSTR_Rx_7: (+1)
   \   000000D6   0x....             LDR      R0,??DataTable6_9
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD003             BEQ      ??FMSTR_Rx_9
   1000                      {
   1001                          FMSTR_SendError(FMSTR_STC_CMDCSERR);
   \   000000DE   0x2082             MOVS     R0,#+130
   \   000000E0   0x.... 0x....      BL       FMSTR_SendError
   \   000000E4   0xE002             B        ??FMSTR_Rx_8
   1002                      }
   1003                      /* message is okay */
   1004                      else
   1005                      {
   1006          #if (FMSTR_USE_USB_CDC) && (FMSTR_SHORT_INTR)
   1007                          /* Decode protocol and send response in Poll function */
   1008                          pflg->flg.bUsbReadyToDecode = 1U;
   1009          #else
   1010                          /* do decode now! */
   1011                          FMSTR_ProtocolDecoder(pcm_pCommBuffer);
   \                     ??FMSTR_Rx_9: (+1)
   \   000000E6   0x....             LDR      R0,??DataTable6_5
   \   000000E8   0x.... 0x....      BL       FMSTR_ProtocolDecoder
   1012          #endif
   1013                      }
   1014          
   1015                      return FMSTR_TRUE;
   \                     ??FMSTR_Rx_8: (+1)
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0xE015             B        ??FMSTR_Rx_1
   1016                  }
   1017                  /* not the last character yet */
   1018                  else
   1019                  {
   1020                      /* is there still a space in the buffer? */
   1021                      if(pcm_pRxBuff)
   \                     ??FMSTR_Rx_6: (+1)
   \   000000F0   0x....             LDR      R0,??DataTable6_8
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x2800             CMP      R0,#+0
   \   000000F6   0xD010             BEQ      ??FMSTR_Rx_5
   1022                      {
   1023                          /*lint -e{946} pointer arithmetic is okay here (same array) */
   1024                          if(pcm_pRxBuff < (pcm_pCommBuffer + FMSTR_COMM_BUFFER_SIZE))
   \   000000F8   0x....             LDR      R0,??DataTable6_8
   \   000000FA   0x6800             LDR      R0,[R0, #+0]
   \   000000FC   0x....             LDR      R1,??DataTable6_10
   \   000000FE   0x4288             CMP      R0,R1
   \   00000100   0xD208             BCS      ??FMSTR_Rx_10
   1025                          {
   1026                              /* store byte  */
   1027                              *pcm_pRxBuff++ = nRxChar;
   \   00000102   0x....             LDR      R0,??DataTable6_8
   \   00000104   0x6800             LDR      R0,[R0, #+0]
   \   00000106   0x7004             STRB     R4,[R0, #+0]
   \   00000108   0x....             LDR      R0,??DataTable6_8
   \   0000010A   0x6800             LDR      R0,[R0, #+0]
   \   0000010C   0x1C40             ADDS     R0,R0,#+1
   \   0000010E   0x....             LDR      R1,??DataTable6_8
   \   00000110   0x6008             STR      R0,[R1, #+0]
   \   00000112   0xE002             B        ??FMSTR_Rx_5
   1028                          }
   1029                          /* buffer is full! */
   1030                          else
   1031                          {
   1032                              /* NULL rx pointer means buffer overflow - but we still need */
   1033                              /* to receive all message characters (for the single-wire mode) */
   1034                              /* so keep "receiving" - but throw away all characters from now */
   1035                              pcm_pRxBuff = NULL;
   \                     ??FMSTR_Rx_10: (+1)
   \   00000114   0x2000             MOVS     R0,#+0
   \   00000116   0x....             LDR      R1,??DataTable6_8
   \   00000118   0x6008             STR      R0,[R1, #+0]
   1036                          }
   1037                      }
   1038                  }
   1039              }
   1040              return FMSTR_FALSE;
   \                     ??FMSTR_Rx_5: (+1)
   \   0000011A   0x2000             MOVS     R0,#+0
   \                     ??FMSTR_Rx_1: (+1)
   \   0000011C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1041          }
   1042          
   1043          /**************************************************************************//*!
   1044          *
   1045          * @brief    Serial communication initialization
   1046          *
   1047          ******************************************************************************/
   1048          

   \                                 In section .text, align 2, keep-with-next
   1049          FMSTR_BOOL FMSTR_InitSerial(void)
   1050          {
   \                     FMSTR_InitSerial: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1051              /* initialize all state variables */
   1052              pcm_wFlags.all = 0U;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR      R1,??DataTable6_1
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   1053              pcm_nTxTodo = 0U;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x....             LDR      R1,??DataTable6_7
   \   0000000C   0x7008             STRB     R0,[R1, #+0]
   1054          
   1055          /* Initialize SCI and JTAG interface */
   1056          #if (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART) && (FMSTR_SCI_TWOWIRE_ONLY)
   1057              /* to enable TX and RX together in FreeMASTER initialization */
   1058              FMSTR_SCI_TE_RE();
   \   0000000E   0x....             LDR      R0,??DataTable6_4  ;; 0x4006b003
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x210C             MOVS     R1,#+12
   \   00000014   0x4301             ORRS     R1,R1,R0
   \   00000016   0x....             LDR      R0,??DataTable6_4  ;; 0x4006b003
   \   00000018   0x7001             STRB     R1,[R0, #+0]
   1059          #endif
   1060          
   1061          #if (FMSTR_SHORT_INTR) & ((FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART) || (FMSTR_USE_JTAG))
   1062              pcm_pRQueueRP = pcm_pRQueueBuffer;
   1063              pcm_pRQueueWP = pcm_pRQueueBuffer;
   1064          #endif
   1065          
   1066          #if FMSTR_USE_MQX_IO
   1067              if (!FMSTR_InitMQX())
   1068                  return FMSTR_FALSE;
   1069          #endif
   1070          
   1071          #if FMSTR_USE_USB_CDC
   1072              if (!FMSTR_InitUSB())
   1073                  return FMSTR_FALSE;
   1074          #endif
   1075          
   1076              /* start listening for commands */
   1077              FMSTR_Listen();
   \   0000001A   0x.... 0x....      BL       FMSTR_Listen
   1078              return FMSTR_TRUE;
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0xBD02             POP      {R1,PC}          ;; return
   1079          }
   1080          
   1081          
   1082          /*******************************************************************************
   1083          *
   1084          * @brief    API: Main "Polling" call from the application main loop
   1085          *
   1086          * This function either handles all the SCI communication (polling-only mode =
   1087          * FMSTR_POLL_DRIVEN) or decodes messages received on the background by SCI interrupt
   1088          * (short-interrupt mode = FMSTR_SHORT_INTR).
   1089          *
   1090          * In the JTAG interrupt-driven mode (both short and long), this function also checks
   1091          * if setting the JTAG RIE bit failed recently. This may happen because of the
   1092          * RIE is held low by the EONCE hardware until the EONCE is first accessed from host.
   1093          * FMSTR_Init (->FMSTR_Listen) is often called while the PC-side FreeMASTER is still
   1094          * turned off. So really, the JTAG is not enabled by this time and RIE bit is not set.
   1095          * This problem is detected (see how bJtagRIEPending is set above in FSMTR_Listen)
   1096          * and it is tried to be fixed periodically here in FMSTR_Poll.
   1097          *
   1098          *******************************************************************************/
   1099          

   \                                 In section .text, align 2, keep-with-next
   1100          void FMSTR_Poll(void)
   1101          {
   \                     FMSTR_Poll: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1102          #if !FMSTR_POLL_DRIVEN && FMSTR_USE_JTAG
   1103              /* in the interrupt-driven JTAG mode, the JTAG RIE may have failed to be set recently */
   1104              if(pcm_wFlags.flg.bJtagRIEPending)
   1105              {
   1106                  FMSTR_JTAG_ERXI();  /* try to enable JTAG receive interrupt now */
   1107          
   1108                  /* succeeded? */
   1109                  if(FMSTR_JTAG_ERXI_CHECK())
   1110                      pcm_wFlags.flg.bJtagRIEPending = 0; /* yes!, enough until it fails again (never?) */
   1111              }
   1112          #endif
   1113          
   1114          #if FMSTR_USE_MQX_IO
   1115              /* polled MQX IO mode */
   1116              FMSTR_ProcessMQXIO();
   1117          #endif
   1118          
   1119          #if FMSTR_POLL_DRIVEN
   1120          
   1121          #if (FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART)
   1122              /* polled SCI mode */
   1123              FMSTR_ProcessSCI();
   \   00000002   0x.... 0x....      BL       FMSTR_ProcessSCI
   1124          
   1125          #elif FMSTR_USE_JTAG
   1126              /* polled JTAG mode */
   1127              FMSTR_ProcessJTAG();
   1128          #endif
   1129          
   1130          #elif FMSTR_SHORT_INTR
   1131          
   1132          #if FMSTR_USE_USB_CDC
   1133              /*  */
   1134              FMSTR_ProcessUSB();
   1135          #elif ((FMSTR_USE_SCI) || (FMSTR_USE_ESCI) || (FMSTR_USE_LPUART) || FMSTR_USE_JTAG)
   1136          
   1137              /* process queued SCI characters */
   1138              FMSTR_RxDequeue();
   1139          #endif
   1140          
   1141          #endif
   1142          }
   \   00000006   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x4006B004         DC32     0x4006b004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     pcm_wFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x4006B007         DC32     0x4006b007

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     pcm_nRxTodo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x4006B003         DC32     0x4006b003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     pcm_pCommBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     pcm_pTxBuff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     pcm_nTxTodo

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     pcm_pRxBuff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     pcm_nRxCheckSum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x........         DC32     pcm_pCommBuffer+0xC8
   1143          
   1144          #endif /* FMSTR_USE_SERIAL */
   1145          
   1146          #endif /* !(FMSTR_DISABLE) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   FMSTR_InitSerial
         8   -> FMSTR_Listen
       0   FMSTR_Listen
       8   FMSTR_Poll
         8   -> FMSTR_ProcessSCI
      16   FMSTR_ProcessSCI
        16   -> FMSTR_Rx
        16   -> FMSTR_Tx
      16   FMSTR_Rx
        16   -> FMSTR_ProtocolDecoder
        16   -> FMSTR_SendError
       8   FMSTR_SendError
         8   -> FMSTR_SendResponse
      20   FMSTR_SendResponse
       8   FMSTR_Tx
         8   -> FMSTR_Listen


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      34  FMSTR_InitSerial
      56  FMSTR_Listen
       8  FMSTR_Poll
      74  FMSTR_ProcessSCI
     286  FMSTR_Rx
      18  FMSTR_SendError
     134  FMSTR_SendResponse
      94  FMSTR_Tx
       1  pcm_nRxCheckSum
       1  pcm_nRxTodo
       1  pcm_nTxTodo
     204  pcm_pCommBuffer
       4  pcm_pRxBuff
       4  pcm_pTxBuff
       4  pcm_wFlags

 
 219 bytes in section .bss
 748 bytes in section .text
 
 748 bytes of CODE memory
 219 bytes of DATA memory

Errors: none
Warnings: none
