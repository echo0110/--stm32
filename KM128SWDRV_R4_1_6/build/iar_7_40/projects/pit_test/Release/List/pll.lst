###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        21/Mar/2017  14:13:03
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\pll\pll.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\pll\pll.c -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\Release\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\..\..\..\..\src\projects\pit_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\..\..\..\..\src\toolchain\iar\
#        -On
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\Release\List\pll.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pit_test\Release\Obj\pll.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\pll\pll.c
      1          /******************************************************************************
      2           * (c) Copyright 2010-2015, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ***************************************************************************//*!
      5           * @file      pll.c
      6           * @version   1.0.2.0
      7           * @date      May-14-2012
      8           * @brief     Phase-Locked Loop (PLL) driver source code.
      9           ******************************************************************************/
     10          #include "common.h"
     11          #include "pll.h"
     12          
     13          /******************************************************************************
     14           * macro definitions                                                          *
     15           ******************************************************************************/
     16          #define WAIT_FOR_FLAG(reg,name1,name2)                                        \
     17          {                                                                             \
     18            while (((MCG_S&MCG_S_##name2##_MASK)>>MCG_S_##name2##_SHIFT)!=              \
     19              ((reg&reg##_##name1##_MASK)>>reg##_##name1##_SHIFT));                     \
     20          }
     21          
     22          /******************************************************************************
     23           * public function definitions                                                *
     24           ******************************************************************************/
     25          #if defined(__ICCARM__)
     26            #pragma diag_suppress=Pa082
     27            #pragma diag_suppress=Pg004
     28          #endif

   \                                 In section .text, align 4, keep-with-next
     29          void PLL_Init (tPLL pll)
     30          {
   \                     PLL_Init: (+1)
   \   00000000   0xB503             PUSH     {R0,R1,LR}
     31            MCG_SC = pll.SC;  /* Setup FCRDIV and trimming                              */
   \   00000002   0x4668             MOV      R0,SP
   \   00000004   0x7900             LDRB     R0,[R0, #+4]
   \   00000006   0x4943             LDR      R1,??PLL_Init_0  ;; 0x40064008
   \   00000008   0x7008             STRB     R0,[R1, #+0]
     32            MCG_C8 = pll.C8;
   \   0000000A   0x4668             MOV      R0,SP
   \   0000000C   0x7980             LDRB     R0,[R0, #+6]
   \   0000000E   0x4942             LDR      R1,??PLL_Init_0+0x4  ;; 0x4006400d
   \   00000010   0x7008             STRB     R0,[R1, #+0]
     33            MCG_C7 = pll.C7;  /* Select MCG PLL and FLL Reference Clocks                */
   \   00000012   0x4668             MOV      R0,SP
   \   00000014   0x7940             LDRB     R0,[R0, #+5]
   \   00000016   0x4941             LDR      R1,??PLL_Init_0+0x8  ;; 0x4006400c
   \   00000018   0x7008             STRB     R0,[R1, #+0]
     34            MCG_C2 = pll.C2;  /* Low Power and clock select                             */
   \   0000001A   0x4668             MOV      R0,SP
   \   0000001C   0x7840             LDRB     R0,[R0, #+1]
   \   0000001E   0x4940             LDR      R1,??PLL_Init_0+0xC  ;; 0x40064001
   \   00000020   0x7008             STRB     R0,[R1, #+0]
     35            /* Wait for oscillator initialization if External Reference Clock Selected  */
     36            if (MCG_C2 & MCG_C2_EREFS0_MASK) { WAIT_FOR_FLAG (MCG_C2, EREFS0, OSCINIT0); }
   \   00000022   0x483F             LDR      R0,??PLL_Init_0+0xC  ;; 0x40064001
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x0740             LSLS     R0,R0,#+29
   \   00000028   0xD50D             BPL      ??PLL_Init_1
   \                     ??PLL_Init_2: (+1)
   \   0000002A   0x483E             LDR      R0,??PLL_Init_0+0x10  ;; 0x40064006
   \   0000002C   0x7800             LDRB     R0,[R0, #+0]
   \   0000002E   0xB2C0             UXTB     R0,R0
   \   00000030   0x0001             MOVS     R1,R0
   \   00000032   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+31
   \   00000034   0x0FC9             LSRS     R1,R1,#+31
   \   00000036   0x483A             LDR      R0,??PLL_Init_0+0xC  ;; 0x40064001
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x0002             MOVS     R2,R0
   \   0000003E   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+31
   \   00000040   0x0FD2             LSRS     R2,R2,#+31
   \   00000042   0x4291             CMP      R1,R2
   \   00000044   0xD1F1             BNE      ??PLL_Init_2
     37            /* Setup C1 register keeping MCGOUTCLK clocked in either PBI or PBE mode    */
     38            if ((pll.C7 & MCG_C7_PLL32KREFSEL_MASK) == MCG_C7_PLL32KREFSEL(1))
   \                     ??PLL_Init_1: (+1)
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x7940             LDRB     R0,[R0, #+5]
   \   0000004A   0x21C0             MOVS     R1,#+192
   \   0000004C   0x4001             ANDS     R1,R1,R0
   \   0000004E   0x2940             CMP      R1,#+64
   \   00000050   0xD108             BNE      ??PLL_Init_3
     39              MCG_C1 = (pll.C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(1);     /* PBI mode   */
   \   00000052   0x4668             MOV      R0,SP
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
   \   00000056   0x0680             LSLS     R0,R0,#+26       ;; ZeroExtS R0,R0,#+26,#+26
   \   00000058   0x0E80             LSRS     R0,R0,#+26
   \   0000005A   0x2140             MOVS     R1,#+64
   \   0000005C   0x4301             ORRS     R1,R1,R0
   \   0000005E   0x4832             LDR      R0,??PLL_Init_0+0x14  ;; 0x40064000
   \   00000060   0x7001             STRB     R1,[R0, #+0]
   \   00000062   0xE007             B        ??PLL_Init_4
     40            else
     41              MCG_C1 = (pll.C1 & ~MCG_C1_CLKS_MASK) | MCG_C1_CLKS(2);     /* PBE mode   */
   \                     ??PLL_Init_3: (+1)
   \   00000064   0x4668             MOV      R0,SP
   \   00000066   0x7800             LDRB     R0,[R0, #+0]
   \   00000068   0x0680             LSLS     R0,R0,#+26       ;; ZeroExtS R0,R0,#+26,#+26
   \   0000006A   0x0E80             LSRS     R0,R0,#+26
   \   0000006C   0x2180             MOVS     R1,#+128
   \   0000006E   0x4301             ORRS     R1,R1,R0
   \   00000070   0x482D             LDR      R0,??PLL_Init_0+0x14  ;; 0x40064000
   \   00000072   0x7001             STRB     R1,[R0, #+0]
     42            MCG_C5 = pll.C5;  /* Powers PLL and enables PLL in normal stop mode         */
   \                     ??PLL_Init_4: (+1)
   \   00000074   0x4668             MOV      R0,SP
   \   00000076   0x7880             LDRB     R0,[R0, #+2]
   \   00000078   0x492C             LDR      R1,??PLL_Init_0+0x18  ;; 0x40064004
   \   0000007A   0x7008             STRB     R0,[R1, #+0]
     43            /* Wait until PLL locks                                                     */
     44            if (MCG_C5 & MCG_C5_PLLCLKEN0_MASK) { WAIT_FOR_FLAG (MCG_C5, PLLCLKEN0, LOCK0); }
   \   0000007C   0x482B             LDR      R0,??PLL_Init_0+0x18  ;; 0x40064004
   \   0000007E   0x7800             LDRB     R0,[R0, #+0]
   \   00000080   0x0640             LSLS     R0,R0,#+25
   \   00000082   0xD50D             BPL      ??PLL_Init_5
   \                     ??PLL_Init_6: (+1)
   \   00000084   0x4827             LDR      R0,??PLL_Init_0+0x10  ;; 0x40064006
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0xB2C0             UXTB     R0,R0
   \   0000008A   0x0001             MOVS     R1,R0
   \   0000008C   0x0649             LSLS     R1,R1,#+25       ;; ZeroExtS R1,R1,#+25,#+31
   \   0000008E   0x0FC9             LSRS     R1,R1,#+31
   \   00000090   0x4826             LDR      R0,??PLL_Init_0+0x18  ;; 0x40064004
   \   00000092   0x7800             LDRB     R0,[R0, #+0]
   \   00000094   0xB2C0             UXTB     R0,R0
   \   00000096   0x0002             MOVS     R2,R0
   \   00000098   0x0652             LSLS     R2,R2,#+25       ;; ZeroExtS R2,R2,#+25,#+31
   \   0000009A   0x0FD2             LSRS     R2,R2,#+31
   \   0000009C   0x4291             CMP      R1,R2
   \   0000009E   0xD1F1             BNE      ??PLL_Init_6
     45            MCG_C6 = pll.C6;  /* Choose PLL as MCG source                               */
   \                     ??PLL_Init_5: (+1)
   \   000000A0   0x4668             MOV      R0,SP
   \   000000A2   0x78C0             LDRB     R0,[R0, #+3]
   \   000000A4   0x4922             LDR      R1,??PLL_Init_0+0x1C  ;; 0x40064005
   \   000000A6   0x7008             STRB     R0,[R1, #+0]
     46            MCG_C1 = pll.C1;  /* Switch MCGOUTCLK clock source                          */
   \   000000A8   0x4668             MOV      R0,SP
   \   000000AA   0x7800             LDRB     R0,[R0, #+0]
   \   000000AC   0x491E             LDR      R1,??PLL_Init_0+0x14  ;; 0x40064000
   \   000000AE   0x7008             STRB     R0,[R1, #+0]
     47            /* if PLL is selected CLKST=3'b11 but CLKS=0'b00 and PLLS=1                 */
     48            if (!(MCG_C1 & MCG_C1_CLKS_MASK) && (MCG_C6 & MCG_C6_PLLS_MASK))
   \   000000B0   0x481D             LDR      R0,??PLL_Init_0+0x14  ;; 0x40064000
   \   000000B2   0x7800             LDRB     R0,[R0, #+0]
   \   000000B4   0x21C0             MOVS     R1,#+192
   \   000000B6   0x4208             TST      R0,R1
   \   000000B8   0xD10C             BNE      ??PLL_Init_7
   \   000000BA   0x481D             LDR      R0,??PLL_Init_0+0x1C  ;; 0x40064005
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0x0640             LSLS     R0,R0,#+25
   \   000000C0   0xD508             BPL      ??PLL_Init_7
     49              while (((MCG_S&MCG_S_CLKST_MASK)>>MCG_S_CLKST_SHIFT)!= 0x03);
   \                     ??PLL_Init_8: (+1)
   \   000000C2   0x4818             LDR      R0,??PLL_Init_0+0x10  ;; 0x40064006
   \   000000C4   0x7800             LDRB     R0,[R0, #+0]
   \   000000C6   0xB2C0             UXTB     R0,R0
   \   000000C8   0x0880             LSRS     R0,R0,#+2
   \   000000CA   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000000CC   0x0F80             LSRS     R0,R0,#+30
   \   000000CE   0x2803             CMP      R0,#+3
   \   000000D0   0xD1F7             BNE      ??PLL_Init_8
   \   000000D2   0xE00B             B        ??PLL_Init_9
     50            else
     51              WAIT_FOR_FLAG (MCG_C1, CLKS, CLKST);
   \                     ??PLL_Init_7: (+1)
   \   000000D4   0x4813             LDR      R0,??PLL_Init_0+0x10  ;; 0x40064006
   \   000000D6   0x7800             LDRB     R0,[R0, #+0]
   \   000000D8   0xB2C0             UXTB     R0,R0
   \   000000DA   0x0880             LSRS     R0,R0,#+2
   \   000000DC   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000000DE   0x0F80             LSRS     R0,R0,#+30
   \   000000E0   0x4911             LDR      R1,??PLL_Init_0+0x14  ;; 0x40064000
   \   000000E2   0x7809             LDRB     R1,[R1, #+0]
   \   000000E4   0xB2C9             UXTB     R1,R1
   \   000000E6   0x0989             LSRS     R1,R1,#+6
   \   000000E8   0x4288             CMP      R0,R1
   \   000000EA   0xD1F3             BNE      ??PLL_Init_7
     52            if (MCG_C1 & MCG_C1_IRCLKEN_MASK) { WAIT_FOR_FLAG (MCG_C2, IRCS, IRCST); }
   \                     ??PLL_Init_9: (+1)
   \   000000EC   0x480E             LDR      R0,??PLL_Init_0+0x14  ;; 0x40064000
   \   000000EE   0x7800             LDRB     R0,[R0, #+0]
   \   000000F0   0x0780             LSLS     R0,R0,#+30
   \   000000F2   0xD50D             BPL      ??PLL_Init_10
   \                     ??PLL_Init_11: (+1)
   \   000000F4   0x480B             LDR      R0,??PLL_Init_0+0x10  ;; 0x40064006
   \   000000F6   0x7800             LDRB     R0,[R0, #+0]
   \   000000F8   0xB2C0             UXTB     R0,R0
   \   000000FA   0x0001             MOVS     R1,R0
   \   000000FC   0x07C9             LSLS     R1,R1,#+31       ;; ZeroExtS R1,R1,#+31,#+31
   \   000000FE   0x0FC9             LSRS     R1,R1,#+31
   \   00000100   0x4807             LDR      R0,??PLL_Init_0+0xC  ;; 0x40064001
   \   00000102   0x7800             LDRB     R0,[R0, #+0]
   \   00000104   0xB2C0             UXTB     R0,R0
   \   00000106   0x0002             MOVS     R2,R0
   \   00000108   0x07D2             LSLS     R2,R2,#+31       ;; ZeroExtS R2,R2,#+31,#+31
   \   0000010A   0x0FD2             LSRS     R2,R2,#+31
   \   0000010C   0x4291             CMP      R1,R2
   \   0000010E   0xD1F1             BNE      ??PLL_Init_11
     53          }
   \                     ??PLL_Init_10: (+1)
   \   00000110   0xBD03             POP      {R0,R1,PC}       ;; return
   \   00000112   0xBF00             Nop      
   \                     ??PLL_Init_0:
   \   00000114   0x40064008         DC32     0x40064008
   \   00000118   0x4006400D         DC32     0x4006400d
   \   0000011C   0x4006400C         DC32     0x4006400c
   \   00000120   0x40064001         DC32     0x40064001
   \   00000124   0x40064006         DC32     0x40064006
   \   00000128   0x40064000         DC32     0x40064000
   \   0000012C   0x40064004         DC32     0x40064004
   \   00000130   0x40064005         DC32     0x40064005
     54          /******************************************************************************
     55           * End of module                                                              *
     56           ******************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   PLL_Init


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     308  PLL_Init

 
 308 bytes in section .text
 
 308 bytes of CODE memory

Errors: none
Warnings: 1
