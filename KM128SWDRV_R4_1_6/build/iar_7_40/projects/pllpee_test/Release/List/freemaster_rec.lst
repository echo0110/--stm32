###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        20/Mar/2017  19:43:15
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_rec.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_rec.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pllpee_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pllpee_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pllpee_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pllpee_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pllpee_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pllpee_test\..\..\..\..\src\projects\pllpee_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pllpee_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pllpee_test\Release\List\freemaster_rec.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\pllpee_test\Release\Obj\freemaster_rec.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_rec.c
      1          /******************************************************************************
      2          *
      3          * Copyright 2004-2013 Freescale Semiconductor, Inc.
      4          *
      5          * This software is owned or controlled by Freescale Semiconductor.
      6          * Use of this software is governed by the Freescale FreeMASTER License
      7          * distributed with this Material.
      8          * See the license file distributed for more details.
      9          *
     10          ****************************************************************************//*!
     11          *
     12          * @brief  FreeMASTER Recorder implementation.
     13          *
     14          *******************************************************************************/
     15          
     16          #include "freemaster.h"
     17          #include "freemaster_private.h"
     18          #include "freemaster_protocol.h"
     19          
     20          #if (FMSTR_USE_RECORDER) && (!(FMSTR_DISABLE))
     21          
     22          #include "freemaster_rec.h"
     23          
     24          #if FMSTR_USE_FASTREC
     25          #include "freemaster_fastrec.h"
     26          #endif
     27          
     28          /********************************************************
     29          *  global variables (shared with FastRecorder if used)
     30          ********************************************************/
     31          
     32          /* configuration variables */

   \                                 In section .bss, align 4
     33          FMSTR_U16  pcm_wRecTotalSmps;        /* number of samples to measure */
     34          
     35          #if FMSTR_REC_STATIC_POSTTRIG == 0
     36          FMSTR_U16  pcm_wRecPostTrigger;      /* number of post-trigger samples to keep */
     37          #endif
     38          
     39          #if (FMSTR_USE_FASTREC) == 0
     40          FMSTR_U8   pcm_nRecTriggerMode;      /* trigger mode (0 = disabled, 1 = _/, 2 = \_) */
   \                     pcm_nRecTriggerMode:
   \   00000000                      DS8 1
     41          #endif
     42          
     43          #if (FMSTR_REC_STATIC_DIVISOR) == 0
     44          FMSTR_U16  pcm_wRecTimeDiv;          /* divisor of recorder "clock" */
     45          #endif
     46          
     47          FMSTR_U8    pcm_nRecVarCount;        /* number of active recorder variables */
   \                     pcm_nRecVarCount:
   \   00000001                      DS8 1
   \   00000002                      DS8 1
   \   00000003                      DS8 1
     48          FMSTR_ADDR  pcm_pRecVarAddr[FMSTR_MAX_REC_VARS]; /* addresses of recorded variables */
     49          FMSTR_SIZE8 pcm_pRecVarSize[FMSTR_MAX_REC_VARS]; /* sizes of recorded variables */
   \                     pcm_pRecVarSize:
   \   00000004                      DS8 8
     50          
     51          /* runtime variables  */
     52          #if (FMSTR_REC_STATIC_DIVISOR) != 1
     53          FMSTR_U16  pcm_wRecTimeDivCtr;       /* recorder "clock" divisor counter */
     54          #endif
     55          
     56          FMSTR_U16  pcm_wStoprecCountDown;    /* post-trigger countdown counter */
     57          
     58          /* recorder flags */
     59          FMSTR_REC_FLAGS pcm_wRecFlags;
   \                     pcm_wRecFlags:
   \   0000000C                      DS8 4
   \   00000010                      DS8 4
   \                     pcm_wRecTotalSmps:
   \   00000014                      DS8 2
   \                     pcm_wRecPostTrigger:
   \   00000016                      DS8 2
   \                     pcm_wRecTimeDiv:
   \   00000018                      DS8 2
   \                     pcm_wRecTimeDivCtr:
   \   0000001A                      DS8 2
   \                     pcm_wStoprecCountDown:
   \   0000001C                      DS8 2
     60          
     61          /***********************************
     62          *  local variables
     63          ***********************************/
     64          
     65          #if (FMSTR_USE_FASTREC) == 0
     66          FMSTR_U16   pcm_wRecBuffStartIx;     /* first sample index */
   \                     pcm_wRecBuffStartIx:
   \   0000001E                      DS8 2
   \                     pcm_pRecVarAddr:
   \   00000020                      DS8 32
     67          
     68          /* Recorder buffer pointers */
     69          FMSTR_ADDR pcm_dwRecWritePtr;        /* write pointer in recorder buffer */
   \                     pcm_dwRecWritePtr:
   \   00000040                      DS8 4
     70          FMSTR_ADDR pcm_dwRecEndBuffPtr;      /* pointer to end of active recorder buffer */
   \                     pcm_dwRecEndBuffPtr:
   \   00000044                      DS8 4
   \   00000048                      DS8 4
   \   0000004C                      DS8 4
   \   00000050                      DS8 4
   \   00000054                      DS8 1024
     71          
     72          /* configuration variables */
     73          static FMSTR_ADDR pcm_nTrgVarAddr;          /* trigger variable address */
     74          static FMSTR_U8   pcm_nTrgVarSize;          /* trigger variable threshold size */
     75          static FMSTR_U8   pcm_bTrgVarSigned;        /* trigger compare mode (0 = unsigned, 1 = signed) */
     76          
     77          /*lint -e{960} using union */
     78          static union
     79          {
     80          #if FMSTR_CFG_BUS_WIDTH == 1
     81              FMSTR_U8  u8;
     82              FMSTR_S8  s8;
     83          #endif
     84              FMSTR_U16 u16;
     85              FMSTR_S16 s16;
     86              FMSTR_U32 u32;
     87              FMSTR_S32 s32;
     88          #if FMSTR_REC_FLOAT_TRIG
     89              FMSTR_FLOAT fp;
     90          #endif
     91          } pcm_uTrgThreshold;                        /* trigger threshold level (1,2 or 4 bytes) */
     92          #endif /* (FMSTR_USE_FASTREC) == 0 */
     93          
     94          static FMSTR_ADDR  pcm_nRecBuffAddr;        /* recorder buffer address */
     95          #if FMSTR_REC_OWNBUFF
     96          static FMSTR_SIZE_RECBUFF  pcm_wRecBuffSize;        /* recorder buffer size */
     97          #endif
     98          /* compare functions prototype */
     99          typedef FMSTR_BOOL (*FMSTR_PCOMPAREFUNC)(void);
    100          
    101          /*/ pointer to active compare function */
    102          static FMSTR_PCOMPAREFUNC pcm_pCompareFunc;
    103          
    104          #if !FMSTR_REC_OWNBUFF && (FMSTR_USE_FASTREC) == 0
    105          /* put buffer into far memory ? */
    106          #if FMSTR_REC_FARBUFF
    107          #pragma section fardata begin
    108          #endif /* FMSTR_REC_FARBUFF */
    109          /* statically allocated recorder buffer (FMSTR_REC_OWNBUFF is FALSE) */
    110          static FMSTR_U8 pcm_pOwnRecBuffer[FMSTR_REC_BUFF_SIZE];
    111          /* end of far memory section */
    112          #if FMSTR_REC_FARBUFF
    113          #pragma section fardata end
    114          #endif /* FMSTR_REC_FARBUFF */
    115          #endif /* FMSTR_REC_OWNBUFF */
    116          
    117          /***********************************
    118          *  local functions
    119          ***********************************/
    120          
    121          static FMSTR_BOOL FMSTR_Compare8S(void);
    122          static FMSTR_BOOL FMSTR_Compare8U(void);
    123          static FMSTR_BOOL FMSTR_Compare16S(void);
    124          static FMSTR_BOOL FMSTR_Compare16U(void);
    125          static FMSTR_BOOL FMSTR_Compare32S(void);
    126          static FMSTR_BOOL FMSTR_Compare32U(void);
    127          #if FMSTR_REC_FLOAT_TRIG
    128          static FMSTR_BOOL FMSTR_Comparefloat(void);
    129          #endif
    130          static void FMSTR_Recorder2(void);
    131          
    132          /**************************************************************************//*!
    133          *
    134          * @brief    Recorder Initialization
    135          *
    136          ******************************************************************************/
    137          

   \                                 In section .text, align 2, keep-with-next
    138          void FMSTR_InitRec(void)
    139          {
    140              /* initialize Recorder flags*/
    141              pcm_wRecFlags.all = 0U;
   \                     FMSTR_InitRec: (+1)
   \   00000000   0x....             LDR      R0,??DataTable13
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x7301             STRB     R1,[R0, #+12]
    142          
    143              /* setup buffer pointer and size so IsInRecBuffer works even
    144                 before the recorder is first initialized and used */
    145          
    146          #if FMSTR_REC_OWNBUFF
    147              /* user wants to use his own buffer */
    148              pcm_nRecBuffAddr = 0U;
    149              pcm_wRecBuffSize = 0U;
    150          #elif FMSTR_USE_FASTREC
    151              /* Initialize Fast Recorder Buffer  */
    152              FMSTR_InitFastRec();
    153          #else
    154              /* size in native sizeof units (=bytes on most platforms) */
    155              FMSTR_ARR2ADDR(pcm_nRecBuffAddr, pcm_pOwnRecBuffer);
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0x3154             ADDS     R1,R1,#+84
   \   0000000A   0x64C1             STR      R1,[R0, #+76]
    156          
    157              /*lint -esym(528, pcm_pOwnRecBuffer) this symbol is used outside of lint sight */
    158          #endif
    159          
    160          }
   \   0000000C   0x4770             BX       LR               ;; return
    161          
    162          /**************************************************************************//*!
    163          *
    164          * @brief    Abort and de-initialize recorder
    165          *
    166          ******************************************************************************/
    167          
    168          #if defined(FMSTR_PLATFORM_HC08) || defined(FMSTR_PLATFORM_HC12)
    169          #pragma INLINE
    170          #elif defined(__ARMCC_VERSION)
    171          static __inline
    172          #else
    173          static inline
    174          #endif
    175          void FMSTR_AbortRec(void)
    176          {
    177              /* clear flags */
    178              pcm_wRecFlags.all = 0U;
    179          }
    180          
    181          /**************************************************************************//*!
    182          *
    183          * @brief    API: Replacing the recorder buffer with the user's one
    184          *
    185          * @param    pBuffer - user buffer pointer
    186          * @param    wBuffSize - buffer size
    187          *
    188          * @note Use the FMSTR_SetUpBuff32 to pass the forced 32bit address in SDM
    189          *
    190          ******************************************************************************/
    191          

   \                                 In section .text, align 2, keep-with-next
    192          void FMSTR_SetUpRecBuff(FMSTR_ADDR pBuffer, FMSTR_SIZE_RECBUFF nBuffSize)
    193          {
    194          #if FMSTR_REC_OWNBUFF
    195              pcm_nRecBuffAddr = pBuffer;
    196              pcm_wRecBuffSize = nBuffSize;
    197          #else
    198              FMSTR_UNUSED(pBuffer);
    199              FMSTR_UNUSED(nBuffSize);
    200          #endif
    201          }
   \                     FMSTR_SetUpRecBuff: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    202          
    203          /**************************************************************************//*!
    204          *
    205          * @brief    Handling SETUPREC and SETUPREC_EX commands
    206          *
    207          * @param    pMessageIO - original command (in) and response buffer (out)
    208          *
    209          * @return   As all command handlers, the return value should be the buffer
    210          *           pointer where the response output finished (except checksum)
    211          *
    212          ******************************************************************************/
    213          

   \                                 In section .text, align 2, keep-with-next
    214          FMSTR_BPTR FMSTR_SetUpRec(FMSTR_BPTR pMessageIO)
    215          {
   \                     FMSTR_SetUpRec: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0001             MOVS     R1,R0
    216              FMSTR_BPTR pResponse = pMessageIO;
   \   00000006   0x9101             STR      R1,[SP, #+4]
    217              FMSTR_SIZE8 nRecVarsetSize;
    218              FMSTR_SIZE_RECBUFF blen;
    219              FMSTR_U8 i, sz;
    220              FMSTR_U8 nResponseCode;
    221          
    222              /* de-initialize first   */
    223              FMSTR_AbortRec();
   \   00000008   0x2700             MOVS     R7,#+0
   \   0000000A   0x....             LDR      R4,??DataTable13
   \   0000000C   0x7327             STRB     R7,[R4, #+12]
    224          
    225          #if FMSTR_REC_OWNBUFF
    226              /* user wants to use his own buffer, check if it is valid */
    227              if(!pcm_nRecBuffAddr || !pcm_wRecBuffSize)
    228              {
    229                  return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_INVBUFF);
    230              }
    231          #elif (FMSTR_USE_FASTREC) == 0
    232              /* size in native sizeof units (=bytes on most platforms) */
    233              FMSTR_ARR2ADDR(pcm_nRecBuffAddr, pcm_pOwnRecBuffer);
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x3054             ADDS     R0,R0,#+84
   \   00000012   0x64E0             STR      R0,[R4, #+76]
    234          #endif
    235          
    236              /* seek the setup data */
    237          #if (FMSTR_USE_FASTREC) == 0
    238              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    239              pMessageIO = FMSTR_ValueFromBuffer8(&pcm_nRecTriggerMode, pMessageIO);
   \   00000014   0x7888             LDRB     R0,[R1, #+2]
   \   00000016   0x7020             STRB     R0,[R4, #+0]
    240          #else /* (FMSTR_USE_FASTREC) == 0 */
    241              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 3U);
    242          #endif /* (FMSTR_USE_FASTREC) == 0 */
    243          
    244              pMessageIO = FMSTR_ValueFromBuffer16(&pcm_wRecTotalSmps, pMessageIO);
   \   00000018   0x1CC9             ADDS     R1,R1,#+3
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x3014             ADDS     R0,R0,#+20
   \   0000001E   0x.... 0x....      BL       FMSTR_ValueFromBuffer16
    245          
    246          #if (FMSTR_REC_STATIC_POSTTRIG) == 0
    247              pMessageIO = FMSTR_ValueFromBuffer16(&pcm_wRecPostTrigger, pMessageIO);
   \   00000022   0x0001             MOVS     R1,R0
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x3016             ADDS     R0,R0,#+22
   \   00000028   0x.... 0x....      BL       FMSTR_ValueFromBuffer16
    248          #else /* (FMSTR_REC_STATIC_POSTTRIG) == 0 */
    249              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    250          #endif /* (FMSTR_REC_STATIC_POSTTRIG) == 0 */
    251          
    252          #if (FMSTR_REC_STATIC_DIVISOR) == 0
    253              pMessageIO = FMSTR_ValueFromBuffer16(&pcm_wRecTimeDiv, pMessageIO);
   \   0000002C   0x0001             MOVS     R1,R0
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x3018             ADDS     R0,R0,#+24
   \   00000032   0x.... 0x....      BL       FMSTR_ValueFromBuffer16
    254          #else /* (FMSTR_REC_STATIC_DIVISOR) == 0 */
    255              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    256          #endif /* (FMSTR_REC_STATIC_DIVISOR) == 0 */
    257          
    258          #if (FMSTR_USE_FASTREC) == 0
    259              /* address & size of trigger variable */
    260              pMessageIO = FMSTR_AddressFromBuffer(&pcm_nTrgVarAddr, pMessageIO);
   \   00000036   0x0001             MOVS     R1,R0
   \   00000038   0x0020             MOVS     R0,R4
   \   0000003A   0x3048             ADDS     R0,R0,#+72
   \   0000003C   0x.... 0x....      BL       FMSTR_AddressFromBuffer
    261              pMessageIO = FMSTR_ValueFromBuffer8(&pcm_nTrgVarSize, pMessageIO);
   \   00000040   0x7801             LDRB     R1,[R0, #+0]
   \   00000042   0x70A1             STRB     R1,[R4, #+2]
    262          
    263              /* trigger compare mode  */
    264              pMessageIO = FMSTR_ValueFromBuffer8(&pcm_bTrgVarSigned, pMessageIO);
   \   00000044   0x7841             LDRB     R1,[R0, #+1]
   \   00000046   0x70E1             STRB     R1,[R4, #+3]
    265          
    266              /* threshold value  */
    267              pMessageIO = FMSTR_ValueFromBuffer32(&pcm_uTrgThreshold.u32, pMessageIO);
   \   00000048   0x1C81             ADDS     R1,R0,#+2
   \   0000004A   0x0020             MOVS     R0,R4
   \   0000004C   0x3010             ADDS     R0,R0,#+16
   \   0000004E   0x.... 0x....      BL       FMSTR_ValueFromBuffer32
    268          #else /* (FMSTR_USE_FASTREC) == 0 */
    269              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 8U);
    270          #endif /* (FMSTR_USE_FASTREC) == 0 */
    271          
    272              /* recorder variable count */
    273              pMessageIO = FMSTR_ValueFromBuffer8(&pcm_nRecVarCount, pMessageIO);
   \   00000052   0x7801             LDRB     R1,[R0, #+0]
   \   00000054   0x7061             STRB     R1,[R4, #+1]
   \   00000056   0x1C40             ADDS     R0,R0,#+1
    274          
    275              /* rec variable information must fit into our buffers */
    276              if(!pcm_nRecVarCount || pcm_nRecVarCount > (FMSTR_U8)FMSTR_MAX_REC_VARS)
   \   00000058   0x2900             CMP      R1,#+0
   \   0000005A   0xD001             BEQ      ??FMSTR_SetUpRec_0
   \   0000005C   0x2909             CMP      R1,#+9
   \   0000005E   0xDB01             BLT      ??FMSTR_SetUpRec_1
    277              {
    278          #if FMSTR_REC_COMMON_ERR_CODES
    279                  goto FMSTR_SetUpRec_exit_error;
    280          #else
    281                  nResponseCode = FMSTR_STC_INVBUFF;
   \                     ??FMSTR_SetUpRec_0: (+1)
   \   00000060   0x2785             MOVS     R7,#+133
    282                  goto FMSTR_SetUpRec_exit;
   \   00000062   0xE04F             B        ??FMSTR_SetUpRec_2
    283          #endif
    284              }
    285          
    286              /* calculate sum of sizes of all variables */
    287              nRecVarsetSize = 0U;
   \                     ??FMSTR_SetUpRec_1: (+1)
   \   00000064   0x9700             STR      R7,[SP, #+0]
    288          
    289              /* get all addresses and sizes */
    290              for(i=0U; i<pcm_nRecVarCount; i++)
   \   00000066   0x2600             MOVS     R6,#+0
   \   00000068   0xE001             B        ??FMSTR_SetUpRec_3
   \                     ??FMSTR_SetUpRec_4: (+1)
   \   0000006A   0x1C76             ADDS     R6,R6,#+1
   \   0000006C   0xB2F6             UXTB     R6,R6
   \                     ??FMSTR_SetUpRec_3: (+1)
   \   0000006E   0x7861             LDRB     R1,[R4, #+1]
   \   00000070   0x428E             CMP      R6,R1
   \   00000072   0xDA12             BGE      ??FMSTR_SetUpRec_5
    291              {
    292                  /* variable size */
    293                  pMessageIO = FMSTR_ValueFromBuffer8(&sz, pMessageIO);
   \   00000074   0x7805             LDRB     R5,[R0, #+0]
   \   00000076   0x1C40             ADDS     R0,R0,#+1
    294          
    295                  pcm_pRecVarSize[i] = sz;
   \   00000078   0x19A2             ADDS     R2,R4,R6
   \   0000007A   0x7115             STRB     R5,[R2, #+4]
    296                  nRecVarsetSize += sz;
   \   0000007C   0x9900             LDR      R1,[SP, #+0]
   \   0000007E   0x1949             ADDS     R1,R1,R5
   \   00000080   0xB2C9             UXTB     R1,R1
   \   00000082   0x9100             STR      R1,[SP, #+0]
    297          
    298                  /* variable address */
    299                  pMessageIO = FMSTR_AddressFromBuffer(&pcm_pRecVarAddr[i], pMessageIO);
   \   00000084   0x0001             MOVS     R1,R0
   \   00000086   0x00B0             LSLS     R0,R6,#+2
   \   00000088   0x1820             ADDS     R0,R4,R0
   \   0000008A   0x3020             ADDS     R0,R0,#+32
   \   0000008C   0x.... 0x....      BL       FMSTR_AddressFromBuffer
    300          
    301                  /* valid numeric variable sizes only */
    302                  if(sz == 0U || sz > 8U)
   \   00000090   0x2D00             CMP      R5,#+0
   \   00000092   0xD02E             BEQ      ??FMSTR_SetUpRec_6
   \   00000094   0x2D09             CMP      R5,#+9
   \   00000096   0xD3E8             BCC      ??FMSTR_SetUpRec_4
    303                  {
    304          #if FMSTR_REC_COMMON_ERR_CODES
    305                      goto FMSTR_SetUpRec_exit_error;
    306          #else
    307                      nResponseCode = FMSTR_STC_INVSIZE;
   \   00000098   0xE02B             B.N      ??FMSTR_SetUpRec_6
    308                      goto FMSTR_SetUpRec_exit;
    309          #endif
    310                  }
    311          
    312          #if FMSTR_CFG_BUS_WIDTH > 1U
    313                  /* even sizes only */
    314                  if(sz & 0x1)
    315                  {
    316          #if FMSTR_REC_COMMON_ERR_CODES
    317                      goto FMSTR_SetUpRec_exit_error;
    318          #else
    319                      nResponseCode = FMSTR_STC_INVSIZE;
    320                      goto FMSTR_SetUpRec_exit;
    321          #endif
    322                  }
    323          #endif /* FMSTR_CFG_BUS_WIDTH > 1U */
    324          
    325          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    326                  if(!FMSTR_CheckTsaSpace(pcm_pRecVarAddr[i], (FMSTR_SIZE8)sz, 0U))
    327                  {
    328          #if FMSTR_REC_COMMON_ERR_CODES
    329                      goto FMSTR_SetUpRec_exit_error;
    330          #else
    331                      nResponseCode = FMSTR_STC_EACCESS;
    332                      goto FMSTR_SetUpRec_exit;
    333          #endif
    334                  }
    335          #endif /* FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY */
    336              }
    337          
    338              /* fast recorder handles trigger by itself */
    339          #if (FMSTR_USE_FASTREC) == 0
    340              /* any trigger? */
    341              pcm_pCompareFunc = NULL;
   \                     ??FMSTR_SetUpRec_5: (+1)
   \   0000009A   0x6527             STR      R7,[R4, #+80]
    342              if(pcm_nRecTriggerMode)
   \   0000009C   0x7820             LDRB     R0,[R4, #+0]
   \   0000009E   0x2800             CMP      R0,#+0
   \   000000A0   0xD010             BEQ      ??FMSTR_SetUpRec_7
    343              {
    344                  /* access to trigger variable? */
    345          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    346                  if(!FMSTR_CheckTsaSpace(pcm_nTrgVarAddr, (FMSTR_SIZE8)pcm_nTrgVarSize, 0U))
    347                  {
    348          #if FMSTR_REC_COMMON_ERR_CODES
    349                      goto FMSTR_SetUpRec_exit_error;
    350          #else
    351                      nResponseCode = FMSTR_STC_EACCESS;
    352                      goto FMSTR_SetUpRec_exit;
    353          #endif
    354                  }
    355          #endif /* FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY */
    356                  /* get compare function */
    357          
    358          #if FMSTR_REC_FLOAT_TRIG
    359                  if(pcm_bTrgVarSigned&FMSTR_REC_FLOAT_TRIG_MASK)
    360                  {
    361                      pcm_pCompareFunc = FMSTR_Comparefloat;
    362                  }
    363                  else
    364          #else
    365                  if(pcm_bTrgVarSigned&FMSTR_REC_FLOAT_TRIG_MASK)
   \   000000A2   0x78E0             LDRB     R0,[R4, #+3]
   \   000000A4   0x0781             LSLS     R1,R0,#+30
   \   000000A6   0xD501             BPL      ??FMSTR_SetUpRec_8
    366                  {
    367          #if FMSTR_REC_COMMON_ERR_CODES
    368                      goto FMSTR_SetUpRec_exit_error;
    369          #else
    370                      nResponseCode = FMSTR_STC_FLOATDISABLED;
   \   000000A8   0x2790             MOVS     R7,#+144
    371                      goto FMSTR_SetUpRec_exit;
   \   000000AA   0xE02B             B        ??FMSTR_SetUpRec_2
    372          #endif
    373                  }
    374          #endif
    375                  {
    376                  switch(pcm_nTrgVarSize)
   \                     ??FMSTR_SetUpRec_8: (+1)
   \   000000AC   0x78A1             LDRB     R1,[R4, #+2]
   \   000000AE   0x2901             CMP      R1,#+1
   \   000000B0   0xD004             BEQ      ??FMSTR_SetUpRec_9
   \   000000B2   0x2902             CMP      R1,#+2
   \   000000B4   0xD011             BEQ      ??FMSTR_SetUpRec_10
   \   000000B6   0x2904             CMP      R1,#+4
   \   000000B8   0xD015             BEQ      ??FMSTR_SetUpRec_11
   \   000000BA   0xE01A             B        ??FMSTR_SetUpRec_6
    377                  {
    378          #if FMSTR_CFG_BUS_WIDTH == 1U
    379                  case 1: pcm_pCompareFunc = pcm_bTrgVarSigned ? FMSTR_Compare8S : FMSTR_Compare8U; break;
   \                     ??FMSTR_SetUpRec_9: (+1)
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD00A             BEQ      ??FMSTR_SetUpRec_12
   \   000000C0   0x....             LDR      R0,??DataTable13_1
   \                     ??FMSTR_SetUpRec_13: (+1)
   \   000000C2   0x6520             STR      R0,[R4, #+80]
    380          #endif
    381                  case 2: pcm_pCompareFunc = pcm_bTrgVarSigned ? FMSTR_Compare16S : FMSTR_Compare16U; break;
    382                  case 4: pcm_pCompareFunc = pcm_bTrgVarSigned ? FMSTR_Compare32S : FMSTR_Compare32U; break;
    383          
    384                  /* invalid trigger variable size  */
    385                  default:
    386          #if FMSTR_REC_COMMON_ERR_CODES
    387                      goto FMSTR_SetUpRec_exit_error;
    388          #else
    389                      nResponseCode = FMSTR_STC_INVSIZE;
    390                      goto FMSTR_SetUpRec_exit;
    391          #endif
    392                      }
    393                  }
    394              }
    395          #endif /* (FMSTR_USE_FASTREC) == 0 */
    396          
    397              /* total recorder buffer length in native sizeof units (=bytes on most platforms) */
    398              blen = (FMSTR_SIZE_RECBUFF) (pcm_wRecTotalSmps * nRecVarsetSize / FMSTR_CFG_BUS_WIDTH);
   \                     ??FMSTR_SetUpRec_7: (+1)
   \   000000C4   0x8AA1             LDRH     R1,[R4, #+20]
   \   000000C6   0x9800             LDR      R0,[SP, #+0]
   \   000000C8   0xB2C0             UXTB     R0,R0
   \   000000CA   0x4348             MULS     R0,R1,R0
   \   000000CC   0xB280             UXTH     R0,R0
    399          
    400              /* recorder memory available? */
    401              if(blen > FMSTR_GetRecBuffSize())
   \   000000CE   0x....             LDR      R1,??DataTable14  ;; 0x401
   \   000000D0   0x4288             CMP      R0,R1
   \   000000D2   0xDB10             BLT      ??FMSTR_SetUpRec_14
    402              {
    403          #if FMSTR_REC_COMMON_ERR_CODES
    404                  goto FMSTR_SetUpRec_exit_error;
    405          #else
    406                  nResponseCode = FMSTR_STC_INVSIZE;
   \   000000D4   0xE00D             B.N      ??FMSTR_SetUpRec_6
    407                  goto FMSTR_SetUpRec_exit;
    408          #endif
    409              }
   \                     ??FMSTR_SetUpRec_12: (+1)
   \   000000D6   0x....             LDR      R0,??DataTable14_1
   \   000000D8   0xE7F3             B        ??FMSTR_SetUpRec_13
   \                     ??FMSTR_SetUpRec_10: (+1)
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD001             BEQ      ??FMSTR_SetUpRec_15
   \   000000DE   0x....             LDR      R0,??DataTable14_2
   \   000000E0   0xE7EF             B        ??FMSTR_SetUpRec_13
   \                     ??FMSTR_SetUpRec_15: (+1)
   \   000000E2   0x....             LDR      R0,??DataTable14_3
   \   000000E4   0xE7ED             B        ??FMSTR_SetUpRec_13
   \                     ??FMSTR_SetUpRec_11: (+1)
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD001             BEQ      ??FMSTR_SetUpRec_16
   \   000000EA   0x....             LDR      R0,??DataTable14_4
   \   000000EC   0xE7E9             B        ??FMSTR_SetUpRec_13
   \                     ??FMSTR_SetUpRec_16: (+1)
   \   000000EE   0x....             LDR      R0,??DataTable14_5
   \   000000F0   0xE7E7             B        ??FMSTR_SetUpRec_13
   \                     ??FMSTR_SetUpRec_6: (+1)
   \   000000F2   0x2786             MOVS     R7,#+134
   \   000000F4   0xE006             B        ??FMSTR_SetUpRec_2
    410          
    411          #if (FMSTR_USE_FASTREC) == 0
    412              /* remember the effective end of circular buffer */
    413              pcm_dwRecEndBuffPtr = pcm_nRecBuffAddr + blen;
   \                     ??FMSTR_SetUpRec_14: (+1)
   \   000000F6   0x6CE1             LDR      R1,[R4, #+76]
   \   000000F8   0x1808             ADDS     R0,R1,R0
   \   000000FA   0x6460             STR      R0,[R4, #+68]
    414          #endif /* (FMSTR_USE_FASTREC) == 0 */
    415          
    416          #if FMSTR_USE_FASTREC
    417              if(!FMSTR_SetUpFastRec())
    418              {
    419          #if FMSTR_REC_COMMON_ERR_CODES
    420                  goto FMSTR_SetUpRec_exit_error;
    421          #else /* FMSTR_REC_COMMON_ERR_CODES */
    422                  nResponseCode = FMSTR_STC_FASTRECERR;
    423                  goto FMSTR_SetUpRec_exit;
    424          #endif /* FMSTR_REC_COMMON_ERR_CODES */
    425              }
    426          #endif /* FMSTR_USE_FASTREC */
    427          
    428              /* everything is okay    */
    429              pcm_wRecFlags.flg.bIsConfigured = 1U;
   \   000000FC   0x68E0             LDR      R0,[R4, #+12]
   \   000000FE   0x2101             MOVS     R1,#+1
   \   00000100   0x4301             ORRS     R1,R1,R0
   \   00000102   0x60E1             STR      R1,[R4, #+12]
    430              nResponseCode = FMSTR_STS_OK;
    431          #if FMSTR_REC_COMMON_ERR_CODES
    432              goto FMSTR_SetUpRec_exit;
    433          FMSTR_SetUpRec_exit_error:
    434              nResponseCode = FMSTR_STC_INVSIZE;
    435          #endif
    436          FMSTR_SetUpRec_exit:
    437              return FMSTR_ConstToBuffer8(pResponse, nResponseCode);
   \                     ??FMSTR_SetUpRec_2: (+1)
   \   00000104   0x9801             LDR      R0,[SP, #+4]
   \   00000106   0x7007             STRB     R7,[R0, #+0]
   \   00000108   0x9801             LDR      R0,[SP, #+4]
   \   0000010A   0x1C40             ADDS     R0,R0,#+1
   \   0000010C   0xB003             ADD      SP,SP,#+12
   \   0000010E   0xBDF0             POP      {R4-R7,PC}       ;; return
    438          }
    439          
    440          /**************************************************************************//*!
    441          *
    442          * @brief    API: Pull the trigger of the recorder
    443          *
    444          * This function starts the post-trigger stop countdown
    445          *
    446          ******************************************************************************/
    447          

   \                                 In section .text, align 2, keep-with-next
    448          void FMSTR_TriggerRec(void)
    449          {
    450              if(!pcm_wRecFlags.flg.bIsStopping)
   \                     FMSTR_TriggerRec: (+1)
   \   00000000   0x....             LDR      R0,??DataTable13
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0x074A             LSLS     R2,R1,#+29
   \   00000006   0x0FD2             LSRS     R2,R2,#+31
   \   00000008   0xD105             BNE      ??FMSTR_TriggerRec_0
    451              {
    452                  pcm_wRecFlags.flg.bIsStopping = 1U;
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0x2204             MOVS     R2,#+4
   \   0000000E   0x430A             ORRS     R2,R2,R1
   \   00000010   0x60C2             STR      R2,[R0, #+12]
    453          #if (FMSTR_REC_STATIC_POSTTRIG) == 0
    454                  pcm_wStoprecCountDown = pcm_wRecPostTrigger;
   \   00000012   0x8AC1             LDRH     R1,[R0, #+22]
   \   00000014   0x8381             STRH     R1,[R0, #+28]
    455          #else
    456                  pcm_wStoprecCountDown = FMSTR_REC_STATIC_POSTTRIG;
    457          #endif
    458              }
    459          }
   \                     ??FMSTR_TriggerRec_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    460          
    461          /**************************************************************************//*!
    462          *
    463          * @brief    Handling STARTREC command
    464          *
    465          * @param    pMessageIO - original command (in) and response buffer (out)
    466          *
    467          * @return   As all command handlers, the return value should be the length
    468          *           of the response filled into the buffer (including status byte)
    469          *
    470          * This function starts recording (initializes internal recording variables
    471          * and flags)
    472          *
    473          ******************************************************************************/
    474          

   \                                 In section .text, align 2, keep-with-next
    475          FMSTR_BPTR FMSTR_StartRec(FMSTR_BPTR pMessageIO)
    476          {
   \                     FMSTR_StartRec: (+1)
   \   00000000   0xB410             PUSH     {R4}
    477               FMSTR_U8 nResponseCode;
    478              /* must be configured */
    479              if(!pcm_wRecFlags.flg.bIsConfigured)
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x....             LDR      R1,??DataTable13
   \   00000006   0x68CB             LDR      R3,[R1, #+12]
   \   00000008   0x4013             ANDS     R3,R3,R2
   \   0000000A   0xD101             BNE      ??FMSTR_StartRec_0
    480              {
    481          #if FMSTR_REC_COMMON_ERR_CODES
    482                  goto FMSTR_StartRec_exit_error;
    483          #else
    484                  nResponseCode = FMSTR_STC_NOTINIT;
   \   0000000C   0x2288             MOVS     R2,#+136
    485                  goto FMSTR_StartRec_exit;
   \   0000000E   0xE018             B        ??FMSTR_StartRec_1
    486          #endif
    487              }
    488          
    489              /* already running ? */
    490              if(pcm_wRecFlags.flg.bIsRunning)
   \                     ??FMSTR_StartRec_0: (+1)
   \   00000010   0x68CB             LDR      R3,[R1, #+12]
   \   00000012   0x085B             LSRS     R3,R3,#+1
   \   00000014   0x4013             ANDS     R3,R3,R2
   \   00000016   0xD114             BNE      ??FMSTR_StartRec_1
    491              {
    492          #if FMSTR_REC_COMMON_ERR_CODES
    493                  goto FMSTR_StartRec_exit_error;
    494          #else
    495                  nResponseCode = FMSTR_STS_RECRUN;
    496                  goto FMSTR_StartRec_exit;
    497          #endif
    498              }
    499          
    500          #if (FMSTR_USE_FASTREC) == 0
    501              /* initialize write pointer */
    502              pcm_dwRecWritePtr = pcm_nRecBuffAddr;
   \   00000018   0x6CCA             LDR      R2,[R1, #+76]
   \   0000001A   0x640A             STR      R2,[R1, #+64]
    503          
    504              /* current (first) sample index */
    505              pcm_wRecBuffStartIx = 0U;
   \   0000001C   0x2200             MOVS     R2,#+0
   \   0000001E   0x83CA             STRH     R2,[R1, #+30]
    506          #endif /* (FMSTR_USE_FASTREC) == 0 */
    507          
    508              /* initialize time divisor */
    509          #if (FMSTR_REC_STATIC_DIVISOR) != 1
    510              pcm_wRecTimeDivCtr = 0U;
   \   00000020   0x834A             STRH     R2,[R1, #+26]
    511          #endif
    512          
    513              /* initiate virgin cycle */
    514              pcm_wRecFlags.flg.bIsStopping = 0U;          /* no trigger active */
   \   00000022   0x68CB             LDR      R3,[R1, #+12]
   \   00000024   0x2404             MOVS     R4,#+4
   \   00000026   0x43A3             BICS     R3,R3,R4
   \   00000028   0x60CB             STR      R3,[R1, #+12]
    515              pcm_wRecFlags.flg.bTrgCrossActive = 0U;      /* waiting for threshold crossing */
   \   0000002A   0x68CB             LDR      R3,[R1, #+12]
   \   0000002C   0x2410             MOVS     R4,#+16
   \   0000002E   0x43A3             BICS     R3,R3,R4
   \   00000030   0x60CB             STR      R3,[R1, #+12]
    516              pcm_wRecFlags.flg.bInvirginCycle = 1U;       /* initial cycle */
   \   00000032   0x68CB             LDR      R3,[R1, #+12]
   \   00000034   0x2408             MOVS     R4,#+8
   \   00000036   0x431C             ORRS     R4,R4,R3
   \   00000038   0x60CC             STR      R4,[R1, #+12]
    517              /* run now */
    518          
    519              /* start fast recorder */
    520          #if FMSTR_USE_FASTREC
    521              FMSTR_StartFastRec();
    522          #endif /* (MSTR_USE_FASTREC */
    523          
    524              /* run now */
    525              pcm_wRecFlags.flg.bIsRunning = 1U;           /* is running now! */
   \   0000003A   0x68CB             LDR      R3,[R1, #+12]
   \   0000003C   0x2402             MOVS     R4,#+2
   \   0000003E   0x431C             ORRS     R4,R4,R3
   \   00000040   0x60CC             STR      R4,[R1, #+12]
    526          
    527              nResponseCode = FMSTR_STS_OK;
    528          #if FMSTR_REC_COMMON_ERR_CODES
    529              goto FMSTR_StartRec_exit;
    530          FMSTR_StartRec_exit_error:
    531              nResponseCode = FMSTR_STC_NOTINIT;
    532          #endif
    533          
    534          FMSTR_StartRec_exit:
    535              return FMSTR_ConstToBuffer8(pMessageIO, nResponseCode);
   \                     ??FMSTR_StartRec_1: (+1)
   \   00000042   0x7002             STRB     R2,[R0, #+0]
   \   00000044   0x1C40             ADDS     R0,R0,#+1
   \   00000046   0xBC10             POP      {R4}
   \   00000048   0x4770             BX       LR               ;; return
    536          }
    537          
    538          /**************************************************************************//*!
    539          *
    540          * @brief    Handling STOPREC command
    541          *
    542          * @param    pMessageIO - original command (in) and response buffer (out)
    543          *
    544          * @return   As all command handlers, the return value should be the length
    545          *           of the response filled into the buffer (including status byte)
    546          *
    547          * This function stops recording (same as manual trigger)
    548          *
    549          ******************************************************************************/
    550          

   \                                 In section .text, align 2, keep-with-next
    551          FMSTR_BPTR FMSTR_StopRec(FMSTR_BPTR pMessageIO)
    552          {
    553              FMSTR_U8 nResponseCode;
    554              /* must be configured */
    555              if(!pcm_wRecFlags.flg.bIsConfigured)
   \                     FMSTR_StopRec: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0x....             LDR      R1,??DataTable13
   \   00000004   0x68CB             LDR      R3,[R1, #+12]
   \   00000006   0x4013             ANDS     R3,R3,R2
   \   00000008   0xD101             BNE      ??FMSTR_StopRec_0
    556              {
    557                  nResponseCode = FMSTR_STC_NOTINIT;
   \   0000000A   0x2188             MOVS     R1,#+136
    558                  goto FMSTR_StopRec_exit;
   \   0000000C   0xE010             B        ??FMSTR_StopRec_1
    559              }
    560          
    561              /* already stopped ? */
    562              if(!pcm_wRecFlags.flg.bIsRunning)
   \                     ??FMSTR_StopRec_0: (+1)
   \   0000000E   0x68CB             LDR      R3,[R1, #+12]
   \   00000010   0x085B             LSRS     R3,R3,#+1
   \   00000012   0x4013             ANDS     R3,R3,R2
   \   00000014   0xD101             BNE      ??FMSTR_StopRec_2
    563              {
    564                  nResponseCode = FMSTR_STS_RECDONE;
   \   00000016   0x2102             MOVS     R1,#+2
    565                  goto FMSTR_StopRec_exit;
   \   00000018   0xE00A             B        ??FMSTR_StopRec_1
    566              }
    567          
    568              /* simulate trigger */
    569              FMSTR_TriggerRec();
   \                     ??FMSTR_StopRec_2: (+1)
   \   0000001A   0x68CB             LDR      R3,[R1, #+12]
   \   0000001C   0x089B             LSRS     R3,R3,#+2
   \   0000001E   0x401A             ANDS     R2,R2,R3
   \   00000020   0xD105             BNE      ??FMSTR_StopRec_3
   \   00000022   0x68CA             LDR      R2,[R1, #+12]
   \   00000024   0x2304             MOVS     R3,#+4
   \   00000026   0x4313             ORRS     R3,R3,R2
   \   00000028   0x60CB             STR      R3,[R1, #+12]
   \   0000002A   0x8ACA             LDRH     R2,[R1, #+22]
   \   0000002C   0x838A             STRH     R2,[R1, #+28]
    570              nResponseCode = FMSTR_STS_OK;
   \                     ??FMSTR_StopRec_3: (+1)
   \   0000002E   0x2100             MOVS     R1,#+0
    571          
    572          FMSTR_StopRec_exit:
    573              return FMSTR_ConstToBuffer8(pMessageIO, nResponseCode);
   \                     ??FMSTR_StopRec_1: (+1)
   \   00000030   0x7001             STRB     R1,[R0, #+0]
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0x4770             BX       LR               ;; return
    574          }
    575          
    576          /**************************************************************************//*!
    577          *
    578          * @brief    Handling GETRECSTS command
    579          *
    580          * @param    pMessageIO - original command (in) and response buffer (out)
    581          *
    582          * @return   As all command handlers, the return value should be the buffer
    583          *           pointer where the response output finished (except checksum)
    584          *
    585          * This function returns current recorder status
    586          *
    587          ******************************************************************************/
    588          

   \                                 In section .text, align 2, keep-with-next
    589          FMSTR_BPTR FMSTR_GetRecStatus(FMSTR_BPTR pMessageIO)
    590          {
    591              FMSTR_U16 nResponseCode = (FMSTR_U16) (pcm_wRecFlags.flg.bIsRunning ?
    592                  FMSTR_STS_RECRUN : FMSTR_STS_RECDONE);
   \                     FMSTR_GetRecStatus: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0x....             LDR      R2,??DataTable13
   \   00000004   0x68D3             LDR      R3,[R2, #+12]
   \   00000006   0x085B             LSRS     R3,R3,#+1
   \   00000008   0x400B             ANDS     R3,R3,R1
   \   0000000A   0xD100             BNE      ??FMSTR_GetRecStatus_0
   \   0000000C   0x2302             MOVS     R3,#+2
    593          
    594              /* must be configured */
    595              if(!pcm_wRecFlags.flg.bIsConfigured)
   \                     ??FMSTR_GetRecStatus_0: (+1)
   \   0000000E   0x68D2             LDR      R2,[R2, #+12]
   \   00000010   0x4011             ANDS     R1,R1,R2
   \   00000012   0xD100             BNE      ??FMSTR_GetRecStatus_1
    596              {
    597                  nResponseCode = FMSTR_STC_NOTINIT;
   \   00000014   0x2388             MOVS     R3,#+136
    598              }
    599          
    600              /* get run/stop status */
    601              return FMSTR_ConstToBuffer8(pMessageIO, (FMSTR_U8) nResponseCode);
   \                     ??FMSTR_GetRecStatus_1: (+1)
   \   00000016   0x7003             STRB     R3,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x4770             BX       LR               ;; return
    602          }
    603          
    604          /* now follows the recorder only routines, skip that if FastRecorder is used */
    605          #if (FMSTR_USE_FASTREC) == 0
    606          
    607          /**************************************************************************//*!
    608          *
    609          * @brief    Get recorder memory size
    610          *
    611          * @return   Recorder memory size in native sizeof units (=bytes on most platforms)
    612          *
    613          ******************************************************************************/
    614          

   \                                 In section .text, align 2, keep-with-next
    615          FMSTR_SIZE_RECBUFF FMSTR_GetRecBuffSize()
    616          {
    617          #if FMSTR_REC_OWNBUFF
    618              return pcm_wRecBuffSize;
    619          #else
    620              return (FMSTR_SIZE_RECBUFF) FMSTR_REC_BUFF_SIZE;
   \                     FMSTR_GetRecBuffSize: (+1)
   \   00000000   0x2080             MOVS     R0,#+128
   \   00000002   0x00C0             LSLS     R0,R0,#+3        ;; #+1024
   \   00000004   0x4770             BX       LR               ;; return
    621          #endif
    622          }
    623          
    624          /**************************************************************************//*!
    625          *
    626          * @brief    Check wether given memory region is inside the recorder buffer
    627          *
    628          * @param    dwAddr - address of the memory to be checked
    629          * @param    wSize  - size of the memory to be checked
    630          *
    631          * @return   This function returns non-zero if user space is in recorder buffer
    632          *
    633          * This function is called as a part of TSA-checking process when the PC host
    634          * is requesting memory contents
    635          *
    636          ******************************************************************************/
    637          

   \                                 In section .text, align 2, keep-with-next
    638          FMSTR_BOOL FMSTR_IsInRecBuffer(FMSTR_ADDR dwAddr, FMSTR_SIZE8 nSize)
    639          {
   \                     FMSTR_IsInRecBuffer: (+1)
   \   00000000   0x0002             MOVS     R2,R0
    640              FMSTR_BOOL bRet = 0U;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR      R3,??DataTable13
   \   00000006   0x6CDB             LDR      R3,[R3, #+76]
   \   00000008   0x429A             CMP      R2,R3
   \   0000000A   0xD200             BCS      ??FMSTR_IsInRecBuffer_0
   \   0000000C   0x4770             BX       LR
    641          
    642              if(dwAddr >= pcm_nRecBuffAddr)
    643              {
    644                  bRet = (FMSTR_BOOL)((dwAddr + nSize) <= (pcm_nRecBuffAddr + FMSTR_GetRecBuffSize()) ? FMSTR_TRUE : FMSTR_FALSE);
   \                     ??FMSTR_IsInRecBuffer_0: (+1)
   \   0000000E   0xB410             PUSH     {R4}
   \   00000010   0x2480             MOVS     R4,#+128
   \   00000012   0x00E4             LSLS     R4,R4,#+3        ;; #+1024
   \   00000014   0x191B             ADDS     R3,R3,R4
   \   00000016   0x1851             ADDS     R1,R2,R1
   \   00000018   0x428B             CMP      R3,R1
   \   0000001A   0xD300             BCC      ??FMSTR_IsInRecBuffer_1
   \   0000001C   0x2001             MOVS     R0,#+1
    645              }
    646          
    647              return bRet;
   \                     ??FMSTR_IsInRecBuffer_1: (+1)
   \   0000001E   0xBC10             POP      {R4}
   \   00000020   0x4770             BX       LR               ;; return
    648          }
    649          
    650          
    651          /**************************************************************************//*!
    652          *
    653          * @brief    Handling GETRECBUFF and GETRECBUFF_EX command
    654          *
    655          * @param    pMessageIO - original command (in) and response buffer (out)
    656          *
    657          * @return   As all command handlers, the return value should be the buffer
    658          *           pointer where the response output finished (except checksum)
    659          *
    660          * This function returns recorder buffer information
    661          *
    662          ******************************************************************************/
    663          

   \                                 In section .text, align 2, keep-with-next
    664          FMSTR_BPTR FMSTR_GetRecBuff(FMSTR_BPTR pMessageIO)
    665          {
   \                     FMSTR_GetRecBuff: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    666              volatile FMSTR_BPTR pResponse;
    667              /* must be configured */
    668              if(!pcm_wRecFlags.flg.bIsConfigured)
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x....             LDR      R4,??DataTable13
   \   00000008   0x68E2             LDR      R2,[R4, #+12]
   \   0000000A   0x400A             ANDS     R2,R2,R1
   \   0000000C   0xD101             BNE      ??FMSTR_GetRecBuff_0
    669              {
    670                  return FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STC_NOTINIT);
   \   0000000E   0x2188             MOVS     R1,#+136
   \   00000010   0xE004             B.N      ??FMSTR_GetRecBuff_1
    671              }
    672          
    673              /* must be stopped */
    674              if(pcm_wRecFlags.flg.bIsRunning)
   \                     ??FMSTR_GetRecBuff_0: (+1)
   \   00000012   0x68E2             LDR      R2,[R4, #+12]
   \   00000014   0x0852             LSRS     R2,R2,#+1
   \   00000016   0x4011             ANDS     R1,R1,R2
   \   00000018   0xD003             BEQ      ??FMSTR_GetRecBuff_2
    675              {
    676                  return FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STC_SERVBUSY);
   \   0000001A   0x2187             MOVS     R1,#+135
   \                     ??FMSTR_GetRecBuff_1: (+1)
   \   0000001C   0x7001             STRB     R1,[R0, #+0]
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0xE00B             B        ??FMSTR_GetRecBuff_3
    677              }
    678          
    679              /* fill the return info */
    680              pResponse = FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STS_OK);
   \                     ??FMSTR_GetRecBuff_2: (+1)
   \   00000022   0x7001             STRB     R1,[R0, #+0]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x9000             STR      R0,[SP, #+0]
    681              pResponse = FMSTR_AddressToBuffer(pResponse, pcm_nRecBuffAddr);
   \   00000028   0x6CE1             LDR      R1,[R4, #+76]
   \   0000002A   0x9800             LDR      R0,[SP, #+0]
   \   0000002C   0x.... 0x....      BL       FMSTR_AddressToBuffer
   \   00000030   0x9000             STR      R0,[SP, #+0]
    682              return FMSTR_ValueToBuffer16(pResponse, pcm_wRecBuffStartIx);
   \   00000032   0x8BE1             LDRH     R1,[R4, #+30]
   \   00000034   0x9800             LDR      R0,[SP, #+0]
   \   00000036   0x.... 0x....      BL       FMSTR_ValueToBuffer16
   \                     ??FMSTR_GetRecBuff_3: (+1)
   \   0000003A   0xB002             ADD      SP,SP,#+8
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
    683          }
    684          
    685          /**************************************************************************//*!
    686          *
    687          * @brief    Compare macro used in trigger detection
    688          *
    689          * @param    v - original command
    690          * @param    t - response buffer
    691          *
    692          * @return   zero when value is lower than threshold.
    693          * @return   non-zero when value is greater than or equal as threshold
    694          *
    695          ******************************************************************************/
    696          
    697          #define CMP(v,t) ((FMSTR_BOOL)(((v) < (t)) ? 0 : 1))
    698          
    699          #if FMSTR_CFG_BUS_WIDTH == 1U
    700          

   \                                 In section .text, align 2, keep-with-next
    701          static FMSTR_BOOL FMSTR_Compare8S()
    702          {
    703              return CMP(FMSTR_GetS8(pcm_nTrgVarAddr), pcm_uTrgThreshold.s8);
   \                     FMSTR_Compare8S: (+1)
   \   00000000   0x....             LDR      R0,??DataTable13
   \   00000002   0x6C81             LDR      R1,[R0, #+72]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x5689             LDRSB    R1,[R1, R2]
   \   00000008   0x2210             MOVS     R2,#+16
   \   0000000A   0x5680             LDRSB    R0,[R0, R2]
   \   0000000C   0x4281             CMP      R1,R0
   \   0000000E   0xDA01             BGE      ??FMSTR_Compare8S_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR
   \                     ??FMSTR_Compare8S_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR               ;; return
    704          }
    705          

   \                                 In section .text, align 2, keep-with-next
    706          static FMSTR_BOOL FMSTR_Compare8U()
    707          {
    708              return CMP(FMSTR_GetU8(pcm_nTrgVarAddr), pcm_uTrgThreshold.u8);
   \                     FMSTR_Compare8U: (+1)
   \   00000000   0x....             LDR      R0,??DataTable13
   \   00000002   0x6C81             LDR      R1,[R0, #+72]
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0x7C02             LDRB     R2,[R0, #+16]
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0x4180             SBCS     R0,R0,R0
   \   0000000C   0x43C0             MVNS     R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
   \   00000010   0x4770             BX       LR               ;; return
    709          }
    710          
    711          #endif
    712          

   \                                 In section .text, align 2, keep-with-next
    713          static FMSTR_BOOL FMSTR_Compare16S()
    714          {
    715              return CMP(FMSTR_GetS16(pcm_nTrgVarAddr), pcm_uTrgThreshold.s16);
   \                     FMSTR_Compare16S: (+1)
   \   00000000   0x....             LDR      R0,??DataTable13
   \   00000002   0x6C81             LDR      R1,[R0, #+72]
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x5E89             LDRSH    R1,[R1, R2]
   \   00000008   0x2210             MOVS     R2,#+16
   \   0000000A   0x5E80             LDRSH    R0,[R0, R2]
   \   0000000C   0x4281             CMP      R1,R0
   \   0000000E   0xDA01             BGE      ??FMSTR_Compare16S_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR
   \                     ??FMSTR_Compare16S_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x4770             BX       LR               ;; return
    716          }
    717          

   \                                 In section .text, align 2, keep-with-next
    718          static FMSTR_BOOL FMSTR_Compare16U()
    719          {
    720              return CMP(FMSTR_GetU16(pcm_nTrgVarAddr), pcm_uTrgThreshold.u16);
   \                     FMSTR_Compare16U: (+1)
   \   00000000   0x....             LDR      R0,??DataTable13
   \   00000002   0x6C81             LDR      R1,[R0, #+72]
   \   00000004   0x8809             LDRH     R1,[R1, #+0]
   \   00000006   0x8A02             LDRH     R2,[R0, #+16]
   \   00000008   0x4291             CMP      R1,R2
   \   0000000A   0x4180             SBCS     R0,R0,R0
   \   0000000C   0x43C0             MVNS     R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
   \   00000010   0x4770             BX       LR               ;; return
    721          }
    722          

   \                                 In section .text, align 2, keep-with-next
    723          static FMSTR_BOOL FMSTR_Compare32S()
    724          {
    725              return CMP(FMSTR_GetS32(pcm_nTrgVarAddr), pcm_uTrgThreshold.s32);
   \                     FMSTR_Compare32S: (+1)
   \   00000000   0x....             LDR      R0,??DataTable13
   \   00000002   0x6C81             LDR      R1,[R0, #+72]
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0xDA01             BGE      ??FMSTR_Compare32S_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR
   \                     ??FMSTR_Compare32S_0: (+1)
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR               ;; return
    726          }
    727          

   \                                 In section .text, align 2, keep-with-next
    728          static FMSTR_BOOL FMSTR_Compare32U()
    729          {
    730              return CMP(FMSTR_GetU32(pcm_nTrgVarAddr), pcm_uTrgThreshold.u32);
   \                     FMSTR_Compare32U: (+1)
   \   00000000   0x....             LDR      R0,??DataTable13
   \   00000002   0x6C81             LDR      R1,[R0, #+72]
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x6900             LDR      R0,[R0, #+16]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0x4180             SBCS     R0,R0,R0
   \   0000000C   0x43C0             MVNS     R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
   \   00000010   0x4770             BX       LR               ;; return
    731          }
    732          
    733          #if FMSTR_REC_FLOAT_TRIG
    734          static FMSTR_BOOL FMSTR_Comparefloat()
    735          {
    736              return CMP(FMSTR_GetFloat(pcm_nTrgVarAddr), pcm_uTrgThreshold.fp);
    737          }
    738          #endif
    739          
    740          /**************************************************************************//*!
    741          *
    742          * @brief    API: Recorder worker routine - can be called from application's timer ISR
    743          *
    744          *
    745          * This returns quickly if recorder is not running, otherwise it calls quite lengthy
    746          * recorder routine which does all the recorder work (sampling, triggering)
    747          *
    748          ******************************************************************************/
    749          
    750          #if defined(FMSTR_PLATFORM_56F8xxx) || defined(FMSTR_PLATFORM_56F8xx)
    751          #pragma interrupt called
    752          #endif
    753          

   \                                 In section .text, align 2, keep-with-next
    754          void FMSTR_Recorder(void)
    755          {
   \                     FMSTR_Recorder: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    756              /* recorder not active */
    757              if(!pcm_wRecFlags.flg.bIsRunning)
   \   00000004   0x2601             MOVS     R6,#+1
   \   00000006   0x....             LDR      R4,??DataTable14_6
   \   00000008   0x68E0             LDR      R0,[R4, #+12]
   \   0000000A   0x0840             LSRS     R0,R0,#+1
   \   0000000C   0x4030             ANDS     R0,R0,R6
   \   0000000E   0xD05E             BEQ      ??FMSTR_Recorder_0
    758              {
    759                  return ;
    760              }
    761          
    762              /* do the hard work      */
    763              FMSTR_Recorder2();
   \   00000010   0x8B60             LDRH     R0,[R4, #+26]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ      ??FMSTR_Recorder_1
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x8360             STRH     R0,[R4, #+26]
   \   0000001A   0xE058             B        ??FMSTR_Recorder_0
   \                     ??FMSTR_Recorder_1: (+1)
   \   0000001C   0x8B20             LDRH     R0,[R4, #+24]
   \   0000001E   0x8360             STRH     R0,[R4, #+26]
   \   00000020   0x2500             MOVS     R5,#+0
   \   00000022   0x7860             LDRB     R0,[R4, #+1]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD010             BEQ      ??FMSTR_Recorder_2
   \                     ??FMSTR_Recorder_3: (+1)
   \   00000028   0x1960             ADDS     R0,R4,R5
   \   0000002A   0x7907             LDRB     R7,[R0, #+4]
   \   0000002C   0x003A             MOVS     R2,R7
   \   0000002E   0x00A8             LSLS     R0,R5,#+2
   \   00000030   0x1820             ADDS     R0,R4,R0
   \   00000032   0x6A01             LDR      R1,[R0, #+32]
   \   00000034   0x6C20             LDR      R0,[R4, #+64]
   \   00000036   0x.... 0x....      BL       FMSTR_CopyMemory
   \   0000003A   0x6C20             LDR      R0,[R4, #+64]
   \   0000003C   0x19C0             ADDS     R0,R0,R7
   \   0000003E   0x6420             STR      R0,[R4, #+64]
   \   00000040   0x1C6D             ADDS     R5,R5,#+1
   \   00000042   0xB2ED             UXTB     R5,R5
   \   00000044   0x7860             LDRB     R0,[R4, #+1]
   \   00000046   0x4285             CMP      R5,R0
   \   00000048   0xDBEE             BLT      ??FMSTR_Recorder_3
   \                     ??FMSTR_Recorder_2: (+1)
   \   0000004A   0x8BE0             LDRH     R0,[R4, #+30]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x6C21             LDR      R1,[R4, #+64]
   \   00000050   0x6C62             LDR      R2,[R4, #+68]
   \   00000052   0x4291             CMP      R1,R2
   \   00000054   0xD306             BCC      ??FMSTR_Recorder_4
   \   00000056   0x6CE0             LDR      R0,[R4, #+76]
   \   00000058   0x6420             STR      R0,[R4, #+64]
   \   0000005A   0x68E0             LDR      R0,[R4, #+12]
   \   0000005C   0x2108             MOVS     R1,#+8
   \   0000005E   0x4388             BICS     R0,R0,R1
   \   00000060   0x60E0             STR      R0,[R4, #+12]
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??FMSTR_Recorder_4: (+1)
   \   00000064   0x83E0             STRH     R0,[R4, #+30]
   \   00000066   0x68E0             LDR      R0,[R4, #+12]
   \   00000068   0x08C0             LSRS     R0,R0,#+3
   \   0000006A   0x4030             ANDS     R0,R0,R6
   \   0000006C   0xD12F             BNE      ??FMSTR_Recorder_0
   \   0000006E   0x68E0             LDR      R0,[R4, #+12]
   \   00000070   0x0880             LSRS     R0,R0,#+2
   \   00000072   0x4030             ANDS     R0,R0,R6
   \   00000074   0xD10C             BNE      ??FMSTR_Recorder_5
   \   00000076   0x6D20             LDR      R0,[R4, #+80]
   \   00000078   0x0001             MOVS     R1,R0
   \   0000007A   0xD009             BEQ      ??FMSTR_Recorder_5
   \   0000007C   0x4780             BLX      R0
   \   0000007E   0x7821             LDRB     R1,[R4, #+0]
   \   00000080   0x2902             CMP      R1,#+2
   \   00000082   0xD111             BNE      ??FMSTR_Recorder_6
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD011             BEQ      ??FMSTR_Recorder_7
   \                     ??FMSTR_Recorder_8: (+1)
   \   00000088   0x68E0             LDR      R0,[R4, #+12]
   \   0000008A   0x2110             MOVS     R1,#+16
   \   0000008C   0x4301             ORRS     R1,R1,R0
   \   0000008E   0x60E1             STR      R1,[R4, #+12]
   \                     ??FMSTR_Recorder_5: (+1)
   \   00000090   0x68E0             LDR      R0,[R4, #+12]
   \   00000092   0x0880             LSRS     R0,R0,#+2
   \   00000094   0x4006             ANDS     R6,R6,R0
   \   00000096   0xD01A             BEQ      ??FMSTR_Recorder_0
   \   00000098   0x8BA0             LDRH     R0,[R4, #+28]
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD115             BNE      ??FMSTR_Recorder_9
   \   0000009E   0x68E0             LDR      R0,[R4, #+12]
   \   000000A0   0x2102             MOVS     R1,#+2
   \   000000A2   0x4388             BICS     R0,R0,R1
   \   000000A4   0x60E0             STR      R0,[R4, #+12]
   \   000000A6   0xE012             B        ??FMSTR_Recorder_0
   \                     ??FMSTR_Recorder_6: (+1)
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD0ED             BEQ      ??FMSTR_Recorder_8
   \                     ??FMSTR_Recorder_7: (+1)
   \   000000AC   0x68E0             LDR      R0,[R4, #+12]
   \   000000AE   0x0900             LSRS     R0,R0,#+4
   \   000000B0   0x4030             ANDS     R0,R0,R6
   \   000000B2   0xD0ED             BEQ      ??FMSTR_Recorder_5
   \   000000B4   0x68E0             LDR      R0,[R4, #+12]
   \   000000B6   0x0880             LSRS     R0,R0,#+2
   \   000000B8   0x4030             ANDS     R0,R0,R6
   \   000000BA   0xD1E9             BNE      ??FMSTR_Recorder_5
   \   000000BC   0x68E0             LDR      R0,[R4, #+12]
   \   000000BE   0x2104             MOVS     R1,#+4
   \   000000C0   0x4301             ORRS     R1,R1,R0
   \   000000C2   0x60E1             STR      R1,[R4, #+12]
   \   000000C4   0x8AE0             LDRH     R0,[R4, #+22]
   \   000000C6   0x83A0             STRH     R0,[R4, #+28]
   \   000000C8   0xE7E2             B        ??FMSTR_Recorder_5
   \                     ??FMSTR_Recorder_9: (+1)
   \   000000CA   0x1E40             SUBS     R0,R0,#+1
   \   000000CC   0x83A0             STRH     R0,[R4, #+28]
    764          }
   \                     ??FMSTR_Recorder_0: (+1)
   \   000000CE   0xB001             ADD      SP,SP,#+4
   \   000000D0   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x........         DC32     pcm_nRecTriggerMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x........         DC32     FMSTR_Compare8S

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x00000401         DC32     0x401

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     FMSTR_Compare8U

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     FMSTR_Compare16S

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \   00000000   0x........         DC32     FMSTR_Compare16U

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \   00000000   0x........         DC32     FMSTR_Compare32S

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \   00000000   0x........         DC32     FMSTR_Compare32U

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \   00000000   0x........         DC32     pcm_nRecTriggerMode
    765          
    766          /**************************************************************************//*!
    767          *
    768          * @brief    Recorder function called when recorder is active
    769          *
    770          ******************************************************************************/
    771          
    772          #if defined(FMSTR_PLATFORM_56F8xxx) || defined(FMSTR_PLATFORM_56F8xx)
    773          #pragma interrupt called
    774          #endif
    775          
    776          static void FMSTR_Recorder2(void)
    777          {
    778              FMSTR_SIZE8 sz;
    779              FMSTR_BOOL cmp;
    780              FMSTR_U8 i;
    781          
    782          #if (FMSTR_REC_STATIC_DIVISOR) != 1
    783              /* skip this call ? */
    784              if(pcm_wRecTimeDivCtr)
    785              {
    786                  /* maybe next time... */
    787                  pcm_wRecTimeDivCtr--;
    788                  return;
    789              }
    790          
    791              /* re-initialize divider */
    792          #if (FMSTR_REC_STATIC_DIVISOR) == 0
    793              pcm_wRecTimeDivCtr = pcm_wRecTimeDiv;
    794          #else
    795              pcm_wRecTimeDivCtr = FMSTR_REC_STATIC_DIVISOR;
    796          #endif /* (FMSTR_REC_STATIC_DIVISOR) == 0 */
    797          #endif /* (FMSTR_REC_STATIC_DIVISOR) != 1 */
    798          
    799              /* take snapshot of variable values */
    800              for (i=0U; i<pcm_nRecVarCount; i++)
    801              {
    802                  sz = pcm_pRecVarSize[i];
    803                  FMSTR_CopyMemory(pcm_dwRecWritePtr, pcm_pRecVarAddr[i], sz);
    804                  sz /= FMSTR_CFG_BUS_WIDTH;
    805                  pcm_dwRecWritePtr += sz;
    806              }
    807          
    808              /* another sample taken (startIx "points" after sample just taken) */
    809              /* i.e. it points to the oldest sample */
    810              pcm_wRecBuffStartIx++;
    811          
    812              /* wrap around (circular buffer) ? */
    813              if(pcm_dwRecWritePtr >= pcm_dwRecEndBuffPtr)
    814              {
    815                  pcm_dwRecWritePtr = pcm_nRecBuffAddr;
    816                  pcm_wRecFlags.flg.bInvirginCycle = 0U;
    817                  pcm_wRecBuffStartIx = 0U;
    818              }
    819          
    820              /* no trigger testing in virgin cycle */
    821              if(pcm_wRecFlags.flg.bInvirginCycle)
    822              {
    823                  return;
    824              }
    825          
    826              /* test trigger condition if still running */
    827              if(!pcm_wRecFlags.flg.bIsStopping && pcm_pCompareFunc != NULL)
    828              {
    829                  /* compare trigger threshold */
    830                  cmp = pcm_pCompareFunc();
    831          
    832                  /* negated logic (falling-edge) ? */
    833                  if(pcm_nRecTriggerMode == 2U)
    834                  {
    835                      cmp = (FMSTR_BOOL) !cmp;
    836                  }
    837          
    838                  /* above threshold ? */
    839                  if(cmp)
    840                  {
    841                      /* were we at least once below threshold ? */
    842                      if(pcm_wRecFlags.flg.bTrgCrossActive)
    843                      {
    844                          /* EDGE TRIGGER ! */
    845                          FMSTR_TriggerRec();
    846                      }
    847                  }
    848                  else
    849                  {
    850                      /* we got bellow threshold, now wait for being above threshold */
    851                      pcm_wRecFlags.flg.bTrgCrossActive = 1U;
    852                  }
    853              }
    854          
    855              /* in stopping mode ? (note that this bit might have been set just above!) */
    856              if(pcm_wRecFlags.flg.bIsStopping)
    857              {
    858                  /* count down post-trigger samples expired ? */
    859                  if(!pcm_wStoprecCountDown)
    860                  {
    861                      /* STOP RECORDER */
    862                      pcm_wRecFlags.flg.bIsRunning = 0U;
    863                      return;
    864                  }
    865          
    866                  /* perhaps next time */
    867                  pcm_wStoprecCountDown--;
    868              }
    869          }
    870          
    871          #endif /* (FMSTR_USE_FASTREC) == 0 */
    872          
    873          #else /* FMSTR_USE_RECORDER && (!FMSTR_DISABLE) */
    874          
    875          /* use void recorder API functions */
    876          void FMSTR_Recorder(void)
    877          {
    878          }
    879          
    880          void FMSTR_TriggerRec(void)
    881          {
    882          }
    883          
    884          void FMSTR_SetUpRecBuff(FMSTR_ADDR pBuffer, FMSTR_SIZE wBuffSize)
    885          {
    886              FMSTR_UNUSED(pBuffer);
    887              FMSTR_UNUSED(wBuffSize);
    888          }
    889          
    890          /*lint -efile(766, freemaster_protocol.h) include file is not used in this case */
    891          
    892          #endif /* FMSTR_USE_RECORDER && (!FMSTR_DISABLE) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FMSTR_Compare16S
       0   FMSTR_Compare16U
       0   FMSTR_Compare32S
       0   FMSTR_Compare32U
       0   FMSTR_Compare8S
       0   FMSTR_Compare8U
      16   FMSTR_GetRecBuff
        16   -> FMSTR_AddressToBuffer
        16   -> FMSTR_ValueToBuffer16
       0   FMSTR_GetRecBuffSize
       0   FMSTR_GetRecStatus
       0   FMSTR_InitRec
       4   FMSTR_IsInRecBuffer
      24   FMSTR_Recorder
        24   -- Indirect call
        24   -> FMSTR_CopyMemory
      32   FMSTR_SetUpRec
        32   -> FMSTR_AddressFromBuffer
        32   -> FMSTR_ValueFromBuffer16
        32   -> FMSTR_ValueFromBuffer32
       0   FMSTR_SetUpRecBuff
       4   FMSTR_StartRec
       0   FMSTR_StopRec
       0   FMSTR_TriggerRec


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
      24  FMSTR_Compare16S
      18  FMSTR_Compare16U
      20  FMSTR_Compare32S
      18  FMSTR_Compare32U
      24  FMSTR_Compare8S
      18  FMSTR_Compare8U
      62  FMSTR_GetRecBuff
       6  FMSTR_GetRecBuffSize
      28  FMSTR_GetRecStatus
      14  FMSTR_InitRec
      34  FMSTR_IsInRecBuffer
     210  FMSTR_Recorder
     272  FMSTR_SetUpRec
       2  FMSTR_SetUpRecBuff
      74  FMSTR_StartRec
      54  FMSTR_StopRec
      24  FMSTR_TriggerRec
    1108  pcm_nRecTriggerMode
          pcm_nRecVarCount
          pcm_nTrgVarSize
          pcm_bTrgVarSigned
          pcm_pRecVarSize
          pcm_wRecFlags
          pcm_uTrgThreshold
          pcm_wRecTotalSmps
          pcm_wRecPostTrigger
          pcm_wRecTimeDiv
          pcm_wRecTimeDivCtr
          pcm_wStoprecCountDown
          pcm_wRecBuffStartIx
          pcm_pRecVarAddr
          pcm_dwRecWritePtr
          pcm_dwRecEndBuffPtr
          pcm_nTrgVarAddr
          pcm_nRecBuffAddr
          pcm_pCompareFunc
          pcm_pOwnRecBuffer

 
 1 108 bytes in section .bss
   938 bytes in section .text
 
   938 bytes of CODE memory
 1 108 bytes of DATA memory

Errors: none
Warnings: none
