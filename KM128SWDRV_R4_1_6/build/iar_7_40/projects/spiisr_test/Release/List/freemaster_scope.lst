###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        13/Feb/2017  15:49:14
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_scope.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_scope.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\..\..\..\..\src\projects\spiisr_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\Release\List\freemaster_scope.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\Release\Obj\freemaster_scope.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_scope.c
      1          /*******************************************************************************
      2          *
      3          * Copyright 2004-2013 Freescale Semiconductor, Inc.
      4          *
      5          * This software is owned or controlled by Freescale Semiconductor.
      6          * Use of this software is governed by the Freescale FreeMASTER License
      7          * distributed with this Material.
      8          * See the license file distributed for more details.
      9          *
     10          ****************************************************************************//*!
     11          *
     12          * @brief  FreeMASTER Oscilloscope implementation
     13          *
     14          *******************************************************************************/
     15          
     16          #include "freemaster.h"
     17          #include "freemaster_private.h"
     18          #include "freemaster_protocol.h"
     19          
     20          #if (FMSTR_USE_SCOPE) && (!(FMSTR_DISABLE))
     21          
     22          /***********************************
     23          *  local variables
     24          ***********************************/
     25          

   \                                 In section .bss, align 4
     26          static FMSTR_U8  pcm_nScopeVarCount;        /* number of active scope variables */
   \                     pcm_nScopeVarCount:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \   00000004                      DS8 8
   \   0000000C                      DS8 32
     27          static FMSTR_ADDR  pcm_pScopeVarAddr[FMSTR_MAX_SCOPE_VARS]; /* addresses of scope variables */
     28          static FMSTR_SIZE8 pcm_pScopeVarSize[FMSTR_MAX_SCOPE_VARS]; /* sizes of scope variables */
     29          
     30          /**************************************************************************//*!
     31          *
     32          * @brief    Scope Initialization
     33          *
     34          ******************************************************************************/
     35          

   \                                 In section .text, align 2, keep-with-next
     36          void FMSTR_InitScope(void)
     37          {
     38          }
   \                     FMSTR_InitScope: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     39          
     40          /**************************************************************************//*!
     41          *
     42          * @brief    Handling SETUPSCOPE and SETUPSCOPE_EX command
     43          *
     44          * @param    pMessageIO - original command (in) and response buffer (out)
     45          *
     46          * @return   As all command handlers, the return value should be the buffer
     47          *           pointer where the response output finished (except checksum)
     48          *
     49          ******************************************************************************/
     50          

   \                                 In section .text, align 2, keep-with-next
     51          FMSTR_BPTR FMSTR_SetUpScope(FMSTR_BPTR pMessageIO)
     52          {
   \                     FMSTR_SetUpScope: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
     53              FMSTR_BPTR pResponse = pMessageIO;
   \   00000004   0x9000             STR      R0,[SP, #+0]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x....             LDR      R2,??DataTable1
   \   0000000A   0x7011             STRB     R1,[R2, #+0]
     54              FMSTR_U8 i, sz, nVarCnt;
     55          
     56              /* uninitialize scope */
     57              pcm_nScopeVarCount = 0U;
     58          
     59              /* seek the setup data */
     60              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
     61          
     62              /* scope variable count  */
     63              pMessageIO = FMSTR_ValueFromBuffer8(&nVarCnt, pMessageIO);
   \   0000000C   0x7881             LDRB     R1,[R0, #+2]
   \   0000000E   0x9101             STR      R1,[SP, #+4]
   \   00000010   0x1CC0             ADDS     R0,R0,#+3
     64          
     65              /* scope variable information must fit into our buffers */
     66              if(!nVarCnt || nVarCnt > (FMSTR_U8)FMSTR_MAX_SCOPE_VARS)
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD001             BEQ      ??FMSTR_SetUpScope_0
   \   00000016   0x2909             CMP      R1,#+9
   \   00000018   0xDB01             BLT      ??FMSTR_SetUpScope_1
     67              {
     68                  return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_INVBUFF);
   \                     ??FMSTR_SetUpScope_0: (+1)
   \   0000001A   0x2085             MOVS     R0,#+133
   \   0000001C   0xE01A             B        ??FMSTR_SetUpScope_2
     69              }
     70          
     71              /* get all addresses and sizes */
     72              for(i=0U; i<nVarCnt; i++)
   \                     ??FMSTR_SetUpScope_1: (+1)
   \   0000001E   0x2700             MOVS     R7,#+0
   \   00000020   0x....             LDR      R6,??DataTable1_1
   \   00000022   0x....             LDR      R4,??DataTable1_2
   \   00000024   0xE003             B        ??FMSTR_SetUpScope_3
   \                     ??FMSTR_SetUpScope_4: (+1)
   \   00000026   0x1C7F             ADDS     R7,R7,#+1
   \   00000028   0xB2FF             UXTB     R7,R7
   \   0000002A   0x1D24             ADDS     R4,R4,#+4
   \   0000002C   0x1C76             ADDS     R6,R6,#+1
   \                     ??FMSTR_SetUpScope_3: (+1)
   \   0000002E   0x9901             LDR      R1,[SP, #+4]
   \   00000030   0x428F             CMP      R7,R1
   \   00000032   0xDA0B             BGE      ??FMSTR_SetUpScope_5
     73              {
     74                  /* variable size */
     75                  pMessageIO = FMSTR_ValueFromBuffer8(&sz, pMessageIO);
   \   00000034   0x7805             LDRB     R5,[R0, #+0]
   \   00000036   0x1C41             ADDS     R1,R0,#+1
     76                  pcm_pScopeVarSize[i] = sz;
   \   00000038   0x7035             STRB     R5,[R6, #+0]
     77          
     78                  /* variable address */
     79                  pMessageIO = FMSTR_AddressFromBuffer(&pcm_pScopeVarAddr[i], pMessageIO);
   \   0000003A   0x0020             MOVS     R0,R4
   \   0000003C   0x.... 0x....      BL       FMSTR_AddressFromBuffer
     80          
     81                  /* valid numeric variable sizes only */
     82                  if(sz == 0U || sz > 8U)
   \   00000040   0x2D00             CMP      R5,#+0
   \   00000042   0xD001             BEQ      ??FMSTR_SetUpScope_6
   \   00000044   0x2D09             CMP      R5,#+9
   \   00000046   0xD3EE             BCC      ??FMSTR_SetUpScope_4
     83                  {
     84                      return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_INVSIZE);
   \                     ??FMSTR_SetUpScope_6: (+1)
   \   00000048   0x2086             MOVS     R0,#+134
   \   0000004A   0xE003             B        ??FMSTR_SetUpScope_2
     85                  }
     86          
     87          #if FMSTR_CFG_BUS_WIDTH > 1U
     88                  /* even sizes only */
     89                  if(sz & 0x1)
     90                  {
     91                      return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_INVSIZE);
     92                  }
     93          #endif
     94          
     95          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
     96                  if(!FMSTR_CheckTsaSpace(pcm_pScopeVarAddr[i], (FMSTR_SIZE8) sz, 0U))
     97                  {
     98                      return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_EACCESS);
     99                  }
    100          #endif
    101          
    102              }
    103          
    104              /* activate scope */
    105              pcm_nScopeVarCount = nVarCnt;
   \                     ??FMSTR_SetUpScope_5: (+1)
   \   0000004C   0x4608             MOV      R0,R1
   \   0000004E   0x....             LDR      R1,??DataTable1
   \   00000050   0x7008             STRB     R0,[R1, #+0]
    106          
    107              /* return just a status */
    108              return FMSTR_ConstToBuffer8(pResponse, FMSTR_STS_OK);
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??FMSTR_SetUpScope_2: (+1)
   \   00000054   0x9900             LDR      R1,[SP, #+0]
   \   00000056   0x7008             STRB     R0,[R1, #+0]
   \   00000058   0x9800             LDR      R0,[SP, #+0]
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0xB003             ADD      SP,SP,#+12
   \   0000005E   0xBDF0             POP      {R4-R7,PC}       ;; return
    109          }
    110          
    111          /**************************************************************************//*!
    112          *
    113          * @brief    Handling READSCOPE command
    114          *
    115          * @param    pMessageIO - original command (in) and response buffer (out)
    116          *
    117          * @return   As all command handlers, the return value should be the buffer
    118          *           pointer where the response output finished (except checksum)
    119          *
    120          ******************************************************************************/
    121          

   \                                 In section .text, align 2, keep-with-next
    122          FMSTR_BPTR FMSTR_ReadScope(FMSTR_BPTR pMessageIO)
    123          {
   \                     FMSTR_ReadScope: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
    124              FMSTR_U8 i;
    125          
    126              if(!pcm_nScopeVarCount)
   \   00000004   0x....             LDR      R5,??DataTable1
   \   00000006   0x7829             LDRB     R1,[R5, #+0]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD103             BNE      ??FMSTR_ReadScope_0
    127              {
    128                  return FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STC_NOTINIT);
   \   0000000C   0x2188             MOVS     R1,#+136
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0xE010             B        ??FMSTR_ReadScope_1
    129              }
    130          
    131              /* success */
    132              pMessageIO = FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STS_OK);
   \                     ??FMSTR_ReadScope_0: (+1)
   \   00000014   0x2400             MOVS     R4,#+0
   \   00000016   0x7004             STRB     R4,[R0, #+0]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
    133          
    134              for (i=0U; i<pcm_nScopeVarCount; i++)
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD00B             BEQ      ??FMSTR_ReadScope_1
    135              {
    136                  pMessageIO = FMSTR_CopyToBuffer(pMessageIO, pcm_pScopeVarAddr[i], pcm_pScopeVarSize[i]);
   \                     ??FMSTR_ReadScope_2: (+1)
   \   0000001E   0x1929             ADDS     R1,R5,R4
   \   00000020   0x790A             LDRB     R2,[R1, #+4]
   \   00000022   0x00A1             LSLS     R1,R4,#+2
   \   00000024   0x1869             ADDS     R1,R5,R1
   \   00000026   0x68C9             LDR      R1,[R1, #+12]
   \   00000028   0x.... 0x....      BL       FMSTR_CopyToBuffer
    137              }
   \   0000002C   0x1C64             ADDS     R4,R4,#+1
   \   0000002E   0xB2E4             UXTB     R4,R4
   \   00000030   0x7829             LDRB     R1,[R5, #+0]
   \   00000032   0x428C             CMP      R4,R1
   \   00000034   0xDBF3             BLT      ??FMSTR_ReadScope_2
    138          
    139              /* return end position */
    140              return pMessageIO;
   \                     ??FMSTR_ReadScope_1: (+1)
   \   00000036   0xB001             ADD      SP,SP,#+4
   \   00000038   0xBD30             POP      {R4,R5,PC}       ;; return
    141          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x........         DC32     pcm_nScopeVarCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     pcm_nScopeVarCount+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     pcm_nScopeVarCount+0xC
    142          
    143          #else  /* (FMSTR_USE_SCOPE) && !(FMSTR_DISABLE) */
    144          
    145          /*lint -efile(766, freemaster_protocol.h) include file is not used in this case */
    146          
    147          #endif /* (FMSTR_USE_SCOPE) && !(FMSTR_DISABLE) */
    148          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FMSTR_InitScope
      16   FMSTR_ReadScope
        16   -> FMSTR_CopyToBuffer
      32   FMSTR_SetUpScope
        32   -> FMSTR_AddressFromBuffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       2  FMSTR_InitScope
      58  FMSTR_ReadScope
      96  FMSTR_SetUpScope
      44  pcm_nScopeVarCount
          pcm_pScopeVarSize
          pcm_pScopeVarAddr

 
  44 bytes in section .bss
 168 bytes in section .text
 
 168 bytes of CODE memory
  44 bytes of DATA memory

Errors: none
Warnings: none
