###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        28/Feb/2017  14:29:19
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\projects\spiisr_test\spiisr_test.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\projects\spiisr_test\spiisr_test.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\..\..\..\..\src\projects\spiisr_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\Release\List\spiisr_test.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\spiisr_test\Release\Obj\spiisr_test.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\projects\spiisr_test\spiisr_test.c
      1          /******************************************************************************
      2           * (c) Copyright 2010-2015, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ******************************************************************************
      5           * spiisr_test.c
      6           ******************************************************************************/
      7          #include "drivers.h"
      8          
      9          /* SPI signal defines                                                         */
     10          #define SPI0_SS         PIN2            /* PTD1 */
     11          #define SPI0_SCK        PIN3            /* PTD2 */
     12          #define SPI0_MOSI       PIN4            /* PTD3 */
     13          #define SPI0_MISO       PIN5            /* PTD4 */
     14          
     15          /* callback function                                                          */
     16          static void spi0_callback (SPI_CALLBACK_SRC module, SPI_CALLBACK_TYPE type);
     17          
     18          /* global variables                                                           */

   \                                 In section .bss, align 4
     19          uint16 spiBuff[16];                               /* Tx/Rx buffer             */
     20          uint16 spi_tx_cnt, spi_rx_cnt, spi_cnt, spi_cnt2; /* SPI counters             */
   \                     spi_tx_cnt:
   \   00000000                      DS8 2
   \                     spi_rx_cnt:
   \   00000002                      DS8 2
   \                     spi_cnt:
   \   00000004                      DS8 2
   \   00000006                      DS8 2
   \                     spiBuff:
   \   00000008                      DS8 32

   \                                 In section .bss, align 2
   \                     spi_cnt2:
   \   00000000                      DS8 2
     21          

   \                                 In section .text, align 4, keep-with-next
     22          void main (void)
     23          {
   \                     main: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
     24            /* SIM initialization                                                       */
     25            SIM_Init (SIM_MODULE_ALL_PERIPH_ON_CONFIG);     /* full configuration       */
   \   00000004   0x....             LDR      R1,??DataTable4  ;; 0x4003e000
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0x6048             STR      R0,[R1, #+4]
   \   0000000C   0x....             LDR      R1,??DataTable4_1  ;; 0x4003f004
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x600A             STR      R2,[R1, #+0]
   \   00000012   0x....             LDR      R2,??DataTable4_2  ;; 0x786cbdf2
   \   00000014   0x630A             STR      R2,[R1, #+48]
   \   00000016   0x....             LDR      R2,??DataTable4_3  ;; 0x7ab7fc8
   \   00000018   0x634A             STR      R2,[R1, #+52]
   \   0000001A   0x....             LDR      R2,??DataTable4_4  ;; 0xd0116a1f
   \   0000001C   0x638A             STR      R2,[R1, #+56]
   \   0000001E   0x2203             MOVS     R2,#+3
   \   00000020   0x63CA             STR      R2,[R1, #+60]
   \   00000022   0x2280             MOVS     R2,#+128
   \   00000024   0x0512             LSLS     R2,R2,#+20       ;; #+134217728
   \   00000026   0x640A             STR      R2,[R1, #+64]
   \   00000028   0x6488             STR      R0,[R1, #+72]
   \   0000002A   0x6688             STR      R0,[R1, #+104]
     26          
     27            /* SPI0 initialization                                                      */
     28            PORT_Init (PORTG, PORT_MODULE_ALT2_MODE, SPI0_MOSI | SPI0_MISO | SPI0_SCK);
   \   0000002C   0x2238             MOVS     R2,#+56
   \   0000002E   0xBF00             Nop      
   \   00000030   0x....             ADR.N    R0,?_0
   \   00000032   0xC803             LDM      R0,{R0,R1}
   \   00000034   0x.... 0x....      BL       PORTG_Init
     29            SPI_Init  (SPI0, SPI_MODULE_DIV2_8B_IRQ_CONFIG,NULL, PRI_LVL1, spi0_callback);
   \   00000038   0x....             LDR      R0,??DataTable4_5
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0x2301             MOVS     R3,#+1
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x....             ADR.N    R0,?_1
   \   00000042   0xC803             LDM      R0,{R0,R1}
   \   00000044   0x.... 0x....      BL       SPI0_Init
     30          
     31            /* SS pin configuration as a basic GPIO pin                                 */
     32            PORT_Init (PORTG, PORT_MODULE_LED_MODE, SPI0_SS);
   \   00000048   0x2204             MOVS     R2,#+4
   \   0000004A   0xBF00             Nop      
   \   0000004C   0x....             ADR.N    R0,?_2
   \   0000004E   0xC803             LDM      R0,{R0,R1}
   \   00000050   0x.... 0x....      BL       PORTG_Init
     33            GPIO_Init (GPIOG, GPIO_OUT_LOGIC0_MODE, SPI0_SS);
   \   00000054   0x....             LDR      R0,??DataTable4_6  ;; 0x400ff042
   \   00000056   0x7801             LDRB     R1,[R0, #+0]
   \   00000058   0x22FB             MOVS     R2,#+251
   \   0000005A   0x400A             ANDS     R2,R2,R1
   \   0000005C   0x7002             STRB     R2,[R0, #+0]
   \   0000005E   0x2104             MOVS     R1,#+4
   \   00000060   0x7D02             LDRB     R2,[R0, #+20]
   \   00000062   0x430A             ORRS     R2,R2,R1
   \   00000064   0x7502             STRB     R2,[R0, #+20]
     34            GPIO_Set  (GPIOG, SPI0_SS);
   \   00000066   0x7802             LDRB     R2,[R0, #+0]
   \   00000068   0x4311             ORRS     R1,R1,R2
   \   0000006A   0x7001             STRB     R1,[R0, #+0]
     35          
     36            EnableInterrupts();     /* enable all interrupts                            */
   \   0000006C   0xB662             CPSIE i
     37          
     38            spi_tx_cnt = 1; spi_rx_cnt = 0; spiBuff[0]=0x06; spi_cnt=0;
     39            SPI_TxIsrEnable(SPI0);  /* start the 1st packet with 1 Tx byte, no Rx byte  */
   \   0000006E   0x....             LDR      R0,??DataTable4_7  ;; 0x48075003
   \   00000070   0x2120             MOVS     R1,#+32
   \   00000072   0x7001             STRB     R1,[R0, #+0]
     40          
     41            spi_tx_cnt = 1; spi_rx_cnt = 1; spiBuff[0]=0x05; spi_cnt=0;
     42            SPI_TxIsrEnable(SPI0);  /* start the 2nd packet with 1 Tx byte, 1 Rx byte   */
   \   00000074   0x7001             STRB     R1,[R0, #+0]
     43          
     44            spi_tx_cnt = 2; spi_rx_cnt = 8; spiBuff[0]=0x03; spiBuff[1]=0; spi_cnt=0;
     45            SPI_TxIsrEnable(SPI0);  /* start the 3rd packet with 2 Tx bytes, 8 Rx bytes */
   \   00000076   0x7001             STRB     R1,[R0, #+0]
     46          
     47            while(1);
   \                     ??main_0: (+1)
   \   00000078   0xE7FE             B        ??main_0
     48          }
     49          
     50          /* SPI interrupt callback implementation                                      */
     51          #if defined(__ICCARM__)
     52            #pragma diag_suppress=Pa082
     53          #endif

   \                                 In section .text, align 2, keep-with-next
     54          static void spi0_callback  (SPI_CALLBACK_SRC module, SPI_CALLBACK_TYPE type)
     55          {
     56            if (module == SPI0_CALLBACK)
   \                     spi0_callback: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD000             BEQ      ??spi0_callback_0
   \   00000004   0x4770             BX       LR
     57            {
     58              if (type == SPI_TX_CALLBACK)        /* TX IRQ                             */
   \                     ??spi0_callback_0: (+1)
   \   00000006   0xB410             PUSH     {R4}
   \   00000008   0x2901             CMP      R1,#+1
   \   0000000A   0xD122             BNE      ??spi0_callback_1
     59              {
     60                if (spi_tx_cnt) {                 /* Tx state?                          */
   \   0000000C   0x....             LDR      R0,??DataTable4_8
   \   0000000E   0x8801             LDRH     R1,[R0, #+0]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD015             BEQ      ??spi0_callback_2
     61                  GPIO_Clr  (GPIOD,SPI0_SS );     /* managing the slave select          */
   \   00000014   0x....             LDR      R1,??DataTable4_9  ;; 0x400ff003
   \   00000016   0x780A             LDRB     R2,[R1, #+0]
   \   00000018   0x23FB             MOVS     R3,#+251
   \   0000001A   0x4013             ANDS     R3,R3,R2
   \   0000001C   0x700B             STRB     R3,[R1, #+0]
     62                  SPI_PutByte(SPI0,spiBuff[spi_cnt]);   /* sending the data             */
   \   0000001E   0x8881             LDRH     R1,[R0, #+4]
   \   00000020   0x0049             LSLS     R1,R1,#+1
   \   00000022   0x1841             ADDS     R1,R0,R1
   \   00000024   0x8909             LDRH     R1,[R1, #+8]
   \   00000026   0x....             LDR      R2,??DataTable4_10  ;; 0x40075006
   \   00000028   0x7011             STRB     R1,[R2, #+0]
     63                  spi_cnt++;
   \   0000002A   0x8881             LDRH     R1,[R0, #+4]
   \   0000002C   0x1C49             ADDS     R1,R1,#+1
   \   0000002E   0x8081             STRH     R1,[R0, #+4]
     64                  if (!--spi_tx_cnt)              /* to recognize last Tx byte          */
   \   00000030   0x....             LDR      R1,??DataTable4_11  ;; 0xffff
   \   00000032   0x8802             LDRH     R2,[R0, #+0]
   \   00000034   0x1852             ADDS     R2,R2,R1
   \   00000036   0x8002             STRH     R2,[R0, #+0]
   \   00000038   0x0412             LSLS     R2,R2,#+16
   \   0000003A   0xD126             BNE      ??spi0_callback_3
   \   0000003C   0x8081             STRH     R1,[R0, #+4]
   \   0000003E   0xE024             B        ??spi0_callback_3
     65                    spi_cnt = (uint16)-1;
     66                }
     67                else {
     68                  if (spi_rx_cnt) {               /* Rx state?                          */
   \                     ??spi0_callback_2: (+1)
   \   00000040   0x8841             LDRH     R1,[R0, #+2]
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD021             BEQ      ??spi0_callback_3
     69                    spi_rx_cnt--;                 /* Rx counter is decremented here!    */
   \   00000046   0x1E49             SUBS     R1,R1,#+1
   \   00000048   0x8041             STRH     R1,[R0, #+2]
     70                    SPI_PutByte(SPI0,0xFF);       /* dummy Tx data in case of reading   */
   \   0000004A   0x20FF             MOVS     R0,#+255
   \   0000004C   0x....             LDR      R1,??DataTable4_10  ;; 0x40075006
   \   0000004E   0x7008             STRB     R0,[R1, #+0]
   \   00000050   0xE01B             B        ??spi0_callback_3
     71                  }
     72                }
     73              }
     74              if (type == SPI_RX_CALLBACK)        /* RX IRQ                             */
   \                     ??spi0_callback_1: (+1)
   \   00000052   0x2902             CMP      R1,#+2
   \   00000054   0xD119             BNE      ??spi0_callback_3
     75              {
     76                register uint8 temp;
     77                temp = SPI_GetByte(SPI0);         /* save received byte to temp         */
   \   00000056   0x....             LDR      R0,??DataTable4_10  ;; 0x40075006
   \   00000058   0x7801             LDRB     R1,[R0, #+0]
     78                if (!spi_tx_cnt) {                /* transmit or receive state now?     */
   \   0000005A   0x....             LDR      R0,??DataTable4_8
   \   0000005C   0x8802             LDRH     R2,[R0, #+0]
   \   0000005E   0x2A00             CMP      R2,#+0
   \   00000060   0xD108             BNE      ??spi0_callback_4
     79                  if (spi_cnt == (uint16)-1)      /* 1-st Rx byte after transmitting    */
   \   00000062   0x8882             LDRH     R2,[R0, #+4]
   \   00000064   0x1C53             ADDS     R3,R2,#+1
   \   00000066   0x....             LDR      R4,??DataTable4_11  ;; 0xffff
   \   00000068   0x42A2             CMP      R2,R4
   \   0000006A   0xD002             BEQ      ??spi0_callback_5
     80                    spi_cnt++;
     81                  else spiBuff[spi_cnt++] = temp; /* save Rx byte to buffer             */
   \   0000006C   0x0052             LSLS     R2,R2,#+1
   \   0000006E   0x1882             ADDS     R2,R0,R2
   \   00000070   0x8111             STRH     R1,[R2, #+8]
   \                     ??spi0_callback_5: (+1)
   \   00000072   0x8083             STRH     R3,[R0, #+4]
     82                }
     83                if (!spi_rx_cnt) {                /* end of receiving?                  */
   \                     ??spi0_callback_4: (+1)
   \   00000074   0x8840             LDRH     R0,[R0, #+2]
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD107             BNE      ??spi0_callback_3
     84                  SPI_TxIsrDisable(SPI0);         /* disable Tx IRQ                     */
   \   0000007A   0x20DF             MOVS     R0,#+223
   \   0000007C   0x....             LDR      R1,??DataTable4_12  ;; 0x44075003
   \   0000007E   0x7008             STRB     R0,[R1, #+0]
     85                  GPIO_Set(GPIOD,SPI0_SS );     /* managing the slave select          */
   \   00000080   0x....             LDR      R1,??DataTable4_9  ;; 0x400ff003
   \   00000082   0x7808             LDRB     R0,[R1, #+0]
   \   00000084   0x2204             MOVS     R2,#+4
   \   00000086   0x4302             ORRS     R2,R2,R0
   \   00000088   0x700A             STRB     R2,[R1, #+0]
     86                }
     87              }
     88              if (type == SPI_MATCH_CALLBACK)     /* MATCH IRQ                          */
     89              {
     90                /* Place your code here                                                 */
     91              }
     92              if (type == SPI_FAULT_CALLBACK)     /* FAULT (error) IRQ                  */
     93              {
     94                /* Place your code here                                                 */
     95              }
     96            }
     97          }
   \                     ??spi0_callback_3: (+1)
   \   0000008A   0xBC10             POP      {R4}
   \   0000008C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x4003E000         DC32     0x4003e000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x4003F004         DC32     0x4003f004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x786CBDF2         DC32     0x786cbdf2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x07AB7FC8         DC32     0x7ab7fc8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0xD0116A1F         DC32     0xd0116a1f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     spi0_callback

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x400FF042         DC32     0x400ff042

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x48075003         DC32     0x48075003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     spi_tx_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x400FF003         DC32     0x400ff003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x40075006         DC32     0x40075006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x0000FFFF         DC32     0xffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   0x44075003         DC32     0x44075003

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x00000200         DC32 512, 0
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0xD0 0x00          DC8 208, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \   00000000   0x00000104         DC32 260, 0
   \              0x00000000   

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   main
         8   -> PORTG_Init
         8   -> SPI0_Init
       4   spi0_callback


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       8  ?_0
       8  ?_1
       8  ?_2
     122  main
     142  spi0_callback
       2  spi_cnt2
      40  spi_tx_cnt
          spi_rx_cnt
          spi_cnt
          spiBuff

 
  42 bytes in section .bss
 340 bytes in section .text
 
 340 bytes of CODE memory
  42 bytes of DATA memory

Errors: none
Warnings: none
