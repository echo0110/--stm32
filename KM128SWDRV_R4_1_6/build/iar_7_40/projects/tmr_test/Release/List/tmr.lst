###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        21/Apr/2017  17:01:07
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\tmr\tmr.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\tmr\tmr.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\tmr_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\tmr_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\tmr_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\tmr_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\tmr_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\tmr_test\..\..\..\..\src\projects\tmr_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\tmr_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\tmr_test\Release\List\tmr.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\tmr_test\Release\Obj\tmr.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\drivers\tmr\tmr.c
      1          /******************************************************************************
      2           * (c) Copyright 2010-2014, Freescale Semiconductor Inc.
      3           * ALL RIGHTS RESERVED.
      4           ***************************************************************************//*!
      5           * @file      tmr.c
      6           * @version   1.0.4.1
      7           * @date      Nov-08-2016
      8           * @brief     Quad Timer (TMR) driver source code.
      9           ******************************************************************************/
     10          #include "common.h"
     11          #include "tmr.h"
     12          
     13          /******************************************************************************
     14           * data type definitions                                                      *
     15           ******************************************************************************/

   \                                 In section .bss, align 4
     16          static TMR_CH_CALLBACK pCallbackTMR0;
   \                     pCallbackTMR0:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     17          static TMR_CH_CALLBACK pCallbackTMR1;
   \                     pCallbackTMR1:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     18          static TMR_CH_CALLBACK pCallbackTMR2;
   \                     pCallbackTMR2:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     19          static TMR_CH_CALLBACK pCallbackTMR3;
   \                     pCallbackTMR3:
   \   00000000                      DS8 4
     20          
     21          /******************************************************************************
     22           * public function definitions                                                *
     23           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     24          void TMR_CH0_Init (tTMR_CH ch, uint16 comp1, uint16 comp2, uint16 load,
     25                             uint16 cmpld1, uint16 cmpld2, uint8 ip, TMR_CH_CALLBACK pCallback)
     26          {
   \                     TMR_CH0_Init: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0xB403             PUSH     {R0,R1}
   \   00000006   0x980A             LDR      R0,[SP, #+40]
     27            if (pCallback) { pCallbackTMR0 = pCallback; NVIC_SetIsr(INT_TMR0,ip); }
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xD010             BEQ      ??TMR_CH0_Init_0
   \   0000000C   0x....             LDR      R1,??DataTable4
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0x2080             MOVS     R0,#+128
   \   00000012   0x....             LDR      R1,??DataTable4_1  ;; 0xe000e280
   \   00000014   0x680C             LDR      R4,[R1, #+0]
   \   00000016   0x4304             ORRS     R4,R4,R0
   \   00000018   0x600C             STR      R4,[R1, #+0]
   \   0000001A   0x....             LDR      R1,??DataTable4_2  ;; 0xe000e100
   \   0000001C   0x680C             LDR      R4,[R1, #+0]
   \   0000001E   0x4320             ORRS     R0,R0,R4
   \   00000020   0x6008             STR      R0,[R1, #+0]
   \   00000022   0x....             LDR      R0,??DataTable4_3  ;; 0xe000e404
   \   00000024   0x6801             LDR      R1,[R0, #+0]
   \   00000026   0x9C09             LDR      R4,[SP, #+36]
   \   00000028   0x07A4             LSLS     R4,R4,#+30
   \   0000002A   0x430C             ORRS     R4,R4,R1
   \   0000002C   0x6004             STR      R4,[R0, #+0]
     28            TMR0_ENBL   &= ~TMR_ENBL_ENBL(1);
   \                     ??TMR_CH0_Init_0: (+1)
   \   0000002E   0x....             LDR      R0,??DataTable5  ;; 0x40057000
   \   00000030   0x8BC1             LDRH     R1,[R0, #+30]
   \   00000032   0x....             LDR      R4,??DataTable6  ;; 0xfffe
   \   00000034   0x400C             ANDS     R4,R4,R1
   \   00000036   0x83C4             STRH     R4,[R0, #+30]
   \   00000038   0x9906             LDR      R1,[SP, #+24]
     29            TMR0_CNTR    = load;
   \   0000003A   0x8141             STRH     R1,[R0, #+10]
     30            TMR0_ENBL   |= (TMR_ENBL_ENBL(1) & ch.ENBL);
   \   0000003C   0x8BC4             LDRH     R4,[R0, #+30]
   \   0000003E   0x466D             MOV      R5,SP
   \   00000040   0x79AD             LDRB     R5,[R5, #+6]
   \   00000042   0x07EE             LSLS     R6,R5,#+31
   \   00000044   0x0FF6             LSRS     R6,R6,#+31
   \   00000046   0x4326             ORRS     R6,R6,R4
   \   00000048   0x83C6             STRH     R6,[R0, #+30]
     31          
     32            TMR0_COMP1   = comp1;
   \   0000004A   0x8002             STRH     R2,[R0, #+0]
     33            TMR0_COMP2   = comp2;
   \   0000004C   0x8043             STRH     R3,[R0, #+2]
     34            TMR0_LOAD    = load;
   \   0000004E   0x80C1             STRH     R1,[R0, #+6]
     35            TMR0_CMPLD1  = cmpld1;
   \   00000050   0x9907             LDR      R1,[SP, #+28]
   \   00000052   0x8201             STRH     R1,[R0, #+16]
     36            TMR0_CMPLD2  = cmpld2;
   \   00000054   0x9908             LDR      R1,[SP, #+32]
   \   00000056   0x8241             STRH     R1,[R0, #+18]
     37          
     38            TMR0_SCTRL   = ch.SCTRL;
   \   00000058   0x4669             MOV      R1,SP
   \   0000005A   0x8849             LDRH     R1,[R1, #+2]
   \   0000005C   0x81C1             STRH     R1,[R0, #+14]
     39            TMR0_CSCTRL  = ch.CSCTRL;
   \   0000005E   0x4669             MOV      R1,SP
   \   00000060   0x8889             LDRH     R1,[R1, #+4]
   \   00000062   0x8281             STRH     R1,[R0, #+20]
     40            TMR0_CTRL    = ch.CTRL;
   \   00000064   0x4669             MOV      R1,SP
   \   00000066   0x8809             LDRH     R1,[R1, #+0]
   \   00000068   0x8181             STRH     R1,[R0, #+12]
     41          }
   \   0000006A   0xB003             ADD      SP,SP,#+12
   \   0000006C   0xBC70             POP      {R4-R6}
   \   0000006E   0x4770             BX       LR               ;; return
     42          

   \                                 In section .text, align 2, keep-with-next
     43          void TMR_CH1_Init (tTMR_CH ch, uint16 comp1, uint16 comp2, uint16 load,
     44                             uint16 cmpld1, uint16 cmpld2, uint8 ip, TMR_CH_CALLBACK pCallback)
     45          {
   \                     TMR_CH1_Init: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0xB403             PUSH     {R0,R1}
   \   00000006   0x980B             LDR      R0,[SP, #+44]
     46            if (pCallback) { pCallbackTMR1 = pCallback; NVIC_SetIsr(INT_TMR1,ip); }
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xD011             BEQ      ??TMR_CH1_Init_0
   \   0000000C   0x....             LDR      R1,??DataTable5_1
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0x2080             MOVS     R0,#+128
   \   00000012   0x0040             LSLS     R0,R0,#+1        ;; #+256
   \   00000014   0x....             LDR      R1,??DataTable4_1  ;; 0xe000e280
   \   00000016   0x680C             LDR      R4,[R1, #+0]
   \   00000018   0x4304             ORRS     R4,R4,R0
   \   0000001A   0x600C             STR      R4,[R1, #+0]
   \   0000001C   0x....             LDR      R1,??DataTable4_2  ;; 0xe000e100
   \   0000001E   0x680C             LDR      R4,[R1, #+0]
   \   00000020   0x4320             ORRS     R0,R0,R4
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0x....             LDR      R0,??DataTable5_2  ;; 0xe000e408
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x9C0A             LDR      R4,[SP, #+40]
   \   0000002A   0x01A4             LSLS     R4,R4,#+6
   \   0000002C   0x430C             ORRS     R4,R4,R1
   \   0000002E   0x6004             STR      R4,[R0, #+0]
     47            TMR0_ENBL   &= ~TMR_ENBL_ENBL(2);
   \                     ??TMR_CH1_Init_0: (+1)
   \   00000030   0x....             LDR      R0,??DataTable6_1  ;; 0x4005701e
   \   00000032   0x8801             LDRH     R1,[R0, #+0]
   \   00000034   0x....             LDR      R4,??DataTable6_2  ;; 0xfffd
   \   00000036   0x400C             ANDS     R4,R4,R1
   \   00000038   0x8004             STRH     R4,[R0, #+0]
     48            TMR1_CNTR    = load;
   \   0000003A   0x....             LDR      R1,??DataTable7  ;; 0x40058000
   \   0000003C   0x9C07             LDR      R4,[SP, #+28]
   \   0000003E   0x814C             STRH     R4,[R1, #+10]
     49            TMR0_ENBL   |= (TMR_ENBL_ENBL(2) & ch.ENBL);
   \   00000040   0x8805             LDRH     R5,[R0, #+0]
   \   00000042   0x466E             MOV      R6,SP
   \   00000044   0x79B6             LDRB     R6,[R6, #+6]
   \   00000046   0x2702             MOVS     R7,#+2
   \   00000048   0x403E             ANDS     R6,R6,R7
   \   0000004A   0x432E             ORRS     R6,R6,R5
   \   0000004C   0x8006             STRH     R6,[R0, #+0]
     50          
     51            TMR1_COMP1   = comp1;
   \   0000004E   0x800A             STRH     R2,[R1, #+0]
     52            TMR1_COMP2   = comp2;
   \   00000050   0x804B             STRH     R3,[R1, #+2]
     53            TMR1_LOAD    = load;
   \   00000052   0x80CC             STRH     R4,[R1, #+6]
     54            TMR1_CMPLD1  = cmpld1;
   \   00000054   0x9808             LDR      R0,[SP, #+32]
   \   00000056   0x8208             STRH     R0,[R1, #+16]
     55            TMR1_CMPLD2  = cmpld2;
   \   00000058   0x9809             LDR      R0,[SP, #+36]
   \   0000005A   0x8248             STRH     R0,[R1, #+18]
     56          
     57            TMR1_SCTRL   = ch.SCTRL;
   \   0000005C   0x4668             MOV      R0,SP
   \   0000005E   0x8840             LDRH     R0,[R0, #+2]
   \   00000060   0x81C8             STRH     R0,[R1, #+14]
     58            TMR1_CSCTRL  = ch.CSCTRL;
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x8880             LDRH     R0,[R0, #+4]
   \   00000066   0x8288             STRH     R0,[R1, #+20]
     59            TMR1_CTRL    = ch.CTRL;
   \   00000068   0x4668             MOV      R0,SP
   \   0000006A   0x8800             LDRH     R0,[R0, #+0]
   \   0000006C   0x8188             STRH     R0,[R1, #+12]
     60          }
   \   0000006E   0xB003             ADD      SP,SP,#+12
   \   00000070   0xBCF0             POP      {R4-R7}
   \   00000072   0x4770             BX       LR               ;; return
     61          

   \                                 In section .text, align 2, keep-with-next
     62          void TMR_CH2_Init (tTMR_CH ch, uint16 comp1, uint16 comp2, uint16 load,
     63                             uint16 cmpld1, uint16 cmpld2, uint8 ip, TMR_CH_CALLBACK pCallback)
     64          {
   \                     TMR_CH2_Init: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0xB403             PUSH     {R0,R1}
   \   00000006   0x980B             LDR      R0,[SP, #+44]
     65            if (pCallback) { pCallbackTMR2 = pCallback; NVIC_SetIsr(INT_TMR2,ip); }
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xD011             BEQ      ??TMR_CH2_Init_0
   \   0000000C   0x....             LDR      R1,??DataTable6_3
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0x2080             MOVS     R0,#+128
   \   00000012   0x0080             LSLS     R0,R0,#+2        ;; #+512
   \   00000014   0x....             LDR      R1,??DataTable4_1  ;; 0xe000e280
   \   00000016   0x680C             LDR      R4,[R1, #+0]
   \   00000018   0x4304             ORRS     R4,R4,R0
   \   0000001A   0x600C             STR      R4,[R1, #+0]
   \   0000001C   0x....             LDR      R1,??DataTable4_2  ;; 0xe000e100
   \   0000001E   0x680C             LDR      R4,[R1, #+0]
   \   00000020   0x4320             ORRS     R0,R0,R4
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0x....             LDR      R0,??DataTable5_2  ;; 0xe000e408
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x9C0A             LDR      R4,[SP, #+40]
   \   0000002A   0x03A4             LSLS     R4,R4,#+14
   \   0000002C   0x430C             ORRS     R4,R4,R1
   \   0000002E   0x6004             STR      R4,[R0, #+0]
     66            TMR0_ENBL   &= ~TMR_ENBL_ENBL(4);
   \                     ??TMR_CH2_Init_0: (+1)
   \   00000030   0x....             LDR      R0,??DataTable6_1  ;; 0x4005701e
   \   00000032   0x8801             LDRH     R1,[R0, #+0]
   \   00000034   0x....             LDR      R4,??DataTable7_1  ;; 0xfffb
   \   00000036   0x400C             ANDS     R4,R4,R1
   \   00000038   0x8004             STRH     R4,[R0, #+0]
     67            TMR2_CNTR    = load;
   \   0000003A   0x....             LDR      R1,??DataTable7_2  ;; 0x40059000
   \   0000003C   0x9C07             LDR      R4,[SP, #+28]
   \   0000003E   0x814C             STRH     R4,[R1, #+10]
     68            TMR0_ENBL   |= (TMR_ENBL_ENBL(4) & ch.ENBL);
   \   00000040   0x8805             LDRH     R5,[R0, #+0]
   \   00000042   0x466E             MOV      R6,SP
   \   00000044   0x79B6             LDRB     R6,[R6, #+6]
   \   00000046   0x2704             MOVS     R7,#+4
   \   00000048   0x403E             ANDS     R6,R6,R7
   \   0000004A   0x432E             ORRS     R6,R6,R5
   \   0000004C   0x8006             STRH     R6,[R0, #+0]
     69          
     70            TMR2_COMP1   = comp1;
   \   0000004E   0x800A             STRH     R2,[R1, #+0]
     71            TMR2_COMP2   = comp2;
   \   00000050   0x804B             STRH     R3,[R1, #+2]
     72            TMR2_LOAD    = load;
   \   00000052   0x80CC             STRH     R4,[R1, #+6]
     73            TMR2_CMPLD1  = cmpld1;
   \   00000054   0x9808             LDR      R0,[SP, #+32]
   \   00000056   0x8208             STRH     R0,[R1, #+16]
     74            TMR2_CMPLD2  = cmpld2;
   \   00000058   0x9809             LDR      R0,[SP, #+36]
   \   0000005A   0x8248             STRH     R0,[R1, #+18]
     75          
     76            TMR2_SCTRL   = ch.SCTRL;
   \   0000005C   0x4668             MOV      R0,SP
   \   0000005E   0x8840             LDRH     R0,[R0, #+2]
   \   00000060   0x81C8             STRH     R0,[R1, #+14]
     77            TMR2_CSCTRL  = ch.CSCTRL;
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x8880             LDRH     R0,[R0, #+4]
   \   00000066   0x8288             STRH     R0,[R1, #+20]
     78            TMR2_CTRL    = ch.CTRL;
   \   00000068   0x4668             MOV      R0,SP
   \   0000006A   0x8800             LDRH     R0,[R0, #+0]
   \   0000006C   0x8188             STRH     R0,[R1, #+12]
     79          }
   \   0000006E   0xB003             ADD      SP,SP,#+12
   \   00000070   0xBCF0             POP      {R4-R7}
   \   00000072   0x4770             BX       LR               ;; return
     80          

   \                                 In section .text, align 2, keep-with-next
     81          void TMR_CH3_Init (tTMR_CH ch, uint16 comp1, uint16 comp2, uint16 load,
     82                             uint16 cmpld1, uint16 cmpld2, uint8 ip, TMR_CH_CALLBACK pCallback)
     83          {
   \                     TMR_CH3_Init: (+1)
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0xB403             PUSH     {R0,R1}
   \   00000006   0x980B             LDR      R0,[SP, #+44]
     84            if (pCallback) { pCallbackTMR3 = pCallback; NVIC_SetIsr(INT_TMR3,ip); }
   \   00000008   0x0001             MOVS     R1,R0
   \   0000000A   0xD011             BEQ      ??TMR_CH3_Init_0
   \   0000000C   0x....             LDR      R1,??DataTable7_3
   \   0000000E   0x6008             STR      R0,[R1, #+0]
   \   00000010   0x2080             MOVS     R0,#+128
   \   00000012   0x00C0             LSLS     R0,R0,#+3        ;; #+1024
   \   00000014   0x....             LDR      R1,??DataTable4_1  ;; 0xe000e280
   \   00000016   0x680C             LDR      R4,[R1, #+0]
   \   00000018   0x4304             ORRS     R4,R4,R0
   \   0000001A   0x600C             STR      R4,[R1, #+0]
   \   0000001C   0x....             LDR      R1,??DataTable4_2  ;; 0xe000e100
   \   0000001E   0x680C             LDR      R4,[R1, #+0]
   \   00000020   0x4320             ORRS     R0,R0,R4
   \   00000022   0x6008             STR      R0,[R1, #+0]
   \   00000024   0x....             LDR      R0,??DataTable5_2  ;; 0xe000e408
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x9C0A             LDR      R4,[SP, #+40]
   \   0000002A   0x05A4             LSLS     R4,R4,#+22
   \   0000002C   0x430C             ORRS     R4,R4,R1
   \   0000002E   0x6004             STR      R4,[R0, #+0]
     85            TMR0_ENBL   &= ~TMR_ENBL_ENBL(8);
   \                     ??TMR_CH3_Init_0: (+1)
   \   00000030   0x....             LDR      R0,??DataTable6_1  ;; 0x4005701e
   \   00000032   0x8801             LDRH     R1,[R0, #+0]
   \   00000034   0x....             LDR      R4,??DataTable7_4  ;; 0xfff7
   \   00000036   0x400C             ANDS     R4,R4,R1
   \   00000038   0x8004             STRH     R4,[R0, #+0]
     86            TMR3_CNTR    = load;
   \   0000003A   0x....             LDR      R1,??DataTable7_5  ;; 0x4005a000
   \   0000003C   0x9C07             LDR      R4,[SP, #+28]
   \   0000003E   0x814C             STRH     R4,[R1, #+10]
     87            TMR0_ENBL   |= (TMR_ENBL_ENBL(8) & ch.ENBL);
   \   00000040   0x8805             LDRH     R5,[R0, #+0]
   \   00000042   0x466E             MOV      R6,SP
   \   00000044   0x79B6             LDRB     R6,[R6, #+6]
   \   00000046   0x2708             MOVS     R7,#+8
   \   00000048   0x403E             ANDS     R6,R6,R7
   \   0000004A   0x432E             ORRS     R6,R6,R5
   \   0000004C   0x8006             STRH     R6,[R0, #+0]
     88          
     89            TMR3_COMP1   = comp1;
   \   0000004E   0x800A             STRH     R2,[R1, #+0]
     90            TMR3_COMP2   = comp2;
   \   00000050   0x804B             STRH     R3,[R1, #+2]
     91            TMR3_LOAD    = load;
   \   00000052   0x80CC             STRH     R4,[R1, #+6]
     92            TMR3_CMPLD1  = cmpld1;
   \   00000054   0x9808             LDR      R0,[SP, #+32]
   \   00000056   0x8208             STRH     R0,[R1, #+16]
     93            TMR3_CMPLD2  = cmpld2;
   \   00000058   0x9809             LDR      R0,[SP, #+36]
   \   0000005A   0x8248             STRH     R0,[R1, #+18]
     94          
     95            TMR3_SCTRL   = ch.SCTRL;
   \   0000005C   0x4668             MOV      R0,SP
   \   0000005E   0x8840             LDRH     R0,[R0, #+2]
   \   00000060   0x81C8             STRH     R0,[R1, #+14]
     96            TMR3_CSCTRL  = ch.CSCTRL;
   \   00000062   0x4668             MOV      R0,SP
   \   00000064   0x8880             LDRH     R0,[R0, #+4]
   \   00000066   0x8288             STRH     R0,[R1, #+20]
     97            TMR3_CTRL    = ch.CTRL;
   \   00000068   0x4668             MOV      R0,SP
   \   0000006A   0x8800             LDRH     R0,[R0, #+0]
   \   0000006C   0x8188             STRH     R0,[R1, #+12]
     98          }
   \   0000006E   0xB003             ADD      SP,SP,#+12
   \   00000070   0xBCF0             POP      {R4-R7}
   \   00000072   0x4770             BX       LR               ;; return
     99          
    100          /******************************************************************************
    101           * interrupt function definitions                                             *
    102           ******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    103          weak void tmr0_isr (void)
    104          {
   \                     tmr0_isr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    105            /* process TMR channel 0 interrupt                                          */
    106            /* Check for Compare flag only it its interrupt is enabled                  */
    107            if (((TMR0_SCTRL&TMR_SCTRL_TCFIE_MASK) == TMR_SCTRL_TCFIE_MASK))
   \   00000002   0x....             LDR      R4,??DataTable7_6  ;; 0x4005700e
   \   00000004   0x8820             LDRH     R0,[R4, #+0]
   \   00000006   0x0440             LSLS     R0,R0,#+17
   \   00000008   0xD509             BPL      ??tmr0_isr_0
    108            {
    109              if (((TMR0_SCTRL&TMR_SCTRL_TCF_MASK) == TMR_SCTRL_TCF_MASK))
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0x0400             LSLS     R0,R0,#+16
   \   0000000E   0xD506             BPL      ??tmr0_isr_0
    110              {
    111                ioclrh (TMR0_SCTRL,TMR_SCTRL_TCF_MASK);   /* clear interrupt flag       */
   \   00000010   0x....             LDR      R0,??DataTable7_7  ;; 0x7fff
   \   00000012   0x....             LDR      R1,??DataTable7_8  ;; 0x4405700e
   \   00000014   0x8008             STRH     R0,[R1, #+0]
    112                pCallbackTMR0 (COMPARE_CALLBACK);
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x....             LDR      R1,??DataTable4
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x4788             BLX      R1
    113              }
    114            }
    115            /* Check for Input capture flag only it its interrupt is enabled            */
    116            if (((TMR0_SCTRL&TMR_SCTRL_IEFIE_MASK) == TMR_SCTRL_IEFIE_MASK))
   \                     ??tmr0_isr_0: (+1)
   \   0000001E   0x8820             LDRH     R0,[R4, #+0]
   \   00000020   0x0540             LSLS     R0,R0,#+21
   \   00000022   0xD509             BPL      ??tmr0_isr_1
    117            {
    118              if (((TMR0_SCTRL&TMR_SCTRL_IEF_MASK) == TMR_SCTRL_IEF_MASK))
   \   00000024   0x8820             LDRH     R0,[R4, #+0]
   \   00000026   0x0500             LSLS     R0,R0,#+20
   \   00000028   0xD506             BPL      ??tmr0_isr_1
    119              {
    120                ioclrh (TMR0_SCTRL,TMR_SCTRL_IEF_MASK);   /* clear interrupt flag       */
   \   0000002A   0x....             LDR      R0,??DataTable7_9  ;; 0xf7ff
   \   0000002C   0x....             LDR      R1,??DataTable7_8  ;; 0x4405700e
   \   0000002E   0x8008             STRH     R0,[R1, #+0]
    121                pCallbackTMR0 (CAPTURE_CALLBACK);
   \   00000030   0x2004             MOVS     R0,#+4
   \   00000032   0x....             LDR      R1,??DataTable4
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x4788             BLX      R1
    122              }
    123            }
    124            /* Check for Overflow flag only it its interrupt is enabled                 */
    125            if (((TMR0_SCTRL&TMR_SCTRL_TOFIE_MASK) == TMR_SCTRL_TOFIE_MASK))
   \                     ??tmr0_isr_1: (+1)
   \   00000038   0x8820             LDRH     R0,[R4, #+0]
   \   0000003A   0x04C0             LSLS     R0,R0,#+19
   \   0000003C   0xD509             BPL      ??tmr0_isr_2
    126            {
    127              if (((TMR0_SCTRL&TMR_SCTRL_TOF_MASK) == TMR_SCTRL_TOF_MASK))
   \   0000003E   0x8820             LDRH     R0,[R4, #+0]
   \   00000040   0x0480             LSLS     R0,R0,#+18
   \   00000042   0xD506             BPL      ??tmr0_isr_2
    128              {
    129                ioclrh (TMR0_SCTRL,TMR_SCTRL_TOF_MASK);   /* clear interrupt flag       */
   \   00000044   0x....             LDR      R0,??DataTable7_10  ;; 0xdfff
   \   00000046   0x....             LDR      R1,??DataTable7_8  ;; 0x4405700e
   \   00000048   0x8008             STRH     R0,[R1, #+0]
    130                pCallbackTMR0 (ROLLOVER_CALLBACK);
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x....             LDR      R1,??DataTable4
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0x4788             BLX      R1
    131              }
    132            }
    133          }
   \                     ??tmr0_isr_2: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    134          

   \                                 In section .text, align 2, keep-with-next
    135          weak void tmr1_isr (void)
    136          {
   \                     tmr1_isr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    137            /* process TMR channel 1 interrupt                                          */
    138            /* Check for Compare flag only it its interrupt is enabled                  */
    139            if (((TMR1_SCTRL&TMR_SCTRL_TCFIE_MASK) == TMR_SCTRL_TCFIE_MASK))
   \   00000002   0x....             LDR      R4,??DataTable7_11  ;; 0x4005800e
   \   00000004   0x8820             LDRH     R0,[R4, #+0]
   \   00000006   0x0440             LSLS     R0,R0,#+17
   \   00000008   0xD509             BPL      ??tmr1_isr_0
    140            {
    141              if (((TMR1_SCTRL&TMR_SCTRL_TCF_MASK) == TMR_SCTRL_TCF_MASK))
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0x0400             LSLS     R0,R0,#+16
   \   0000000E   0xD506             BPL      ??tmr1_isr_0
    142              {
    143                ioclrh (TMR1_SCTRL,TMR_SCTRL_TCF_MASK);   /* clear interrupt flag       */
   \   00000010   0x....             LDR      R0,??DataTable7_7  ;; 0x7fff
   \   00000012   0x....             LDR      R1,??DataTable7_12  ;; 0x4405800e
   \   00000014   0x8008             STRH     R0,[R1, #+0]
    144                pCallbackTMR1 (COMPARE_CALLBACK);
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x....             LDR      R1,??DataTable5_1
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x4788             BLX      R1
    145              }
    146            }
    147            /* Check for Input capture flag only it its interrupt is enabled            */
    148            if (((TMR1_SCTRL&TMR_SCTRL_IEFIE_MASK) == TMR_SCTRL_IEFIE_MASK))
   \                     ??tmr1_isr_0: (+1)
   \   0000001E   0x8820             LDRH     R0,[R4, #+0]
   \   00000020   0x0540             LSLS     R0,R0,#+21
   \   00000022   0xD509             BPL      ??tmr1_isr_1
    149            {
    150              if (((TMR1_SCTRL&TMR_SCTRL_IEF_MASK) == TMR_SCTRL_IEF_MASK))
   \   00000024   0x8820             LDRH     R0,[R4, #+0]
   \   00000026   0x0500             LSLS     R0,R0,#+20
   \   00000028   0xD506             BPL      ??tmr1_isr_1
    151              {
    152                ioclrh (TMR1_SCTRL,TMR_SCTRL_IEF_MASK);   /* clear interrupt flag       */
   \   0000002A   0x....             LDR      R0,??DataTable7_9  ;; 0xf7ff
   \   0000002C   0x....             LDR      R1,??DataTable7_12  ;; 0x4405800e
   \   0000002E   0x8008             STRH     R0,[R1, #+0]
    153                pCallbackTMR1 (CAPTURE_CALLBACK);
   \   00000030   0x2004             MOVS     R0,#+4
   \   00000032   0x....             LDR      R1,??DataTable5_1
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x4788             BLX      R1
    154              }
    155            }
    156            /* Check for Overflow flag only it its interrupt is enabled                 */
    157            if (((TMR1_SCTRL&TMR_SCTRL_TOFIE_MASK) == TMR_SCTRL_TOFIE_MASK))
   \                     ??tmr1_isr_1: (+1)
   \   00000038   0x8820             LDRH     R0,[R4, #+0]
   \   0000003A   0x04C0             LSLS     R0,R0,#+19
   \   0000003C   0xD509             BPL      ??tmr1_isr_2
    158            {
    159              if (((TMR1_SCTRL&TMR_SCTRL_TOF_MASK) == TMR_SCTRL_TOF_MASK))
   \   0000003E   0x8820             LDRH     R0,[R4, #+0]
   \   00000040   0x0480             LSLS     R0,R0,#+18
   \   00000042   0xD506             BPL      ??tmr1_isr_2
    160              {
    161                ioclrh (TMR1_SCTRL,TMR_SCTRL_TOF_MASK);   /* clear interrupt flag       */
   \   00000044   0x....             LDR      R0,??DataTable7_10  ;; 0xdfff
   \   00000046   0x....             LDR      R1,??DataTable7_12  ;; 0x4405800e
   \   00000048   0x8008             STRH     R0,[R1, #+0]
    162                pCallbackTMR1 (ROLLOVER_CALLBACK);
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x....             LDR      R1,??DataTable5_1
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0x4788             BLX      R1
    163              }
    164            }
    165          }
   \                     ??tmr1_isr_2: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    166          

   \                                 In section .text, align 2, keep-with-next
    167          weak void tmr2_isr (void)
    168          {
   \                     tmr2_isr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    169            /* process TMR channel 2 interrupt                                          */
    170            /* Check for Compare flag only it its interrupt is enabled                  */
    171            if (((TMR2_SCTRL&TMR_SCTRL_TCFIE_MASK) == TMR_SCTRL_TCFIE_MASK))
   \   00000002   0x....             LDR      R4,??DataTable7_13  ;; 0x4005900e
   \   00000004   0x8820             LDRH     R0,[R4, #+0]
   \   00000006   0x0440             LSLS     R0,R0,#+17
   \   00000008   0xD509             BPL      ??tmr2_isr_0
    172            {
    173              if (((TMR2_SCTRL&TMR_SCTRL_TCF_MASK) == TMR_SCTRL_TCF_MASK))
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0x0400             LSLS     R0,R0,#+16
   \   0000000E   0xD506             BPL      ??tmr2_isr_0
    174              {
    175                ioclrh (TMR2_SCTRL,TMR_SCTRL_TCF_MASK);   /* clear interrupt flag       */
   \   00000010   0x....             LDR      R0,??DataTable7_7  ;; 0x7fff
   \   00000012   0x....             LDR      R1,??DataTable7_14  ;; 0x4405900e
   \   00000014   0x8008             STRH     R0,[R1, #+0]
    176                pCallbackTMR2 (COMPARE_CALLBACK);
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x....             LDR      R1,??DataTable6_3
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x4788             BLX      R1
    177              }
    178            }
    179            /* Check for Input capture flag only it its interrupt is enabled            */
    180            if (((TMR2_SCTRL&TMR_SCTRL_IEFIE_MASK) == TMR_SCTRL_IEFIE_MASK))
   \                     ??tmr2_isr_0: (+1)
   \   0000001E   0x8820             LDRH     R0,[R4, #+0]
   \   00000020   0x0540             LSLS     R0,R0,#+21
   \   00000022   0xD509             BPL      ??tmr2_isr_1
    181            {
    182              if (((TMR2_SCTRL&TMR_SCTRL_IEF_MASK) == TMR_SCTRL_IEF_MASK))
   \   00000024   0x8820             LDRH     R0,[R4, #+0]
   \   00000026   0x0500             LSLS     R0,R0,#+20
   \   00000028   0xD506             BPL      ??tmr2_isr_1
    183              {
    184                ioclrh (TMR2_SCTRL,TMR_SCTRL_IEF_MASK);   /* clear interrupt flag       */
   \   0000002A   0x....             LDR      R0,??DataTable7_9  ;; 0xf7ff
   \   0000002C   0x....             LDR      R1,??DataTable7_14  ;; 0x4405900e
   \   0000002E   0x8008             STRH     R0,[R1, #+0]
    185                pCallbackTMR2 (CAPTURE_CALLBACK);
   \   00000030   0x2004             MOVS     R0,#+4
   \   00000032   0x....             LDR      R1,??DataTable6_3
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x4788             BLX      R1
    186              }
    187            }
    188            /* Check for Overflow flag only it its interrupt is enabled                 */
    189            if (((TMR2_SCTRL&TMR_SCTRL_TOFIE_MASK) == TMR_SCTRL_TOFIE_MASK))
   \                     ??tmr2_isr_1: (+1)
   \   00000038   0x8820             LDRH     R0,[R4, #+0]
   \   0000003A   0x04C0             LSLS     R0,R0,#+19
   \   0000003C   0xD509             BPL      ??tmr2_isr_2
    190            {
    191              if (((TMR2_SCTRL&TMR_SCTRL_TOF_MASK) == TMR_SCTRL_TOF_MASK))
   \   0000003E   0x8820             LDRH     R0,[R4, #+0]
   \   00000040   0x0480             LSLS     R0,R0,#+18
   \   00000042   0xD506             BPL      ??tmr2_isr_2
    192              {
    193                ioclrh (TMR2_SCTRL,TMR_SCTRL_TOF_MASK);   /* clear interrupt flag       */
   \   00000044   0x....             LDR      R0,??DataTable7_10  ;; 0xdfff
   \   00000046   0x....             LDR      R1,??DataTable7_14  ;; 0x4405900e
   \   00000048   0x8008             STRH     R0,[R1, #+0]
    194                pCallbackTMR2 (ROLLOVER_CALLBACK);
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x....             LDR      R1,??DataTable6_3
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0x4788             BLX      R1
    195              }
    196            }
    197          }
   \                     ??tmr2_isr_2: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    198          

   \                                 In section .text, align 2, keep-with-next
    199          weak void tmr3_isr (void)
    200          {
   \                     tmr3_isr: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    201            /* process TMR channel 3 interrupt                                          */
    202            /* Check for Compare flag only it its interrupt is enabled                  */
    203            if (((TMR3_SCTRL&TMR_SCTRL_TCFIE_MASK) == TMR_SCTRL_TCFIE_MASK))
   \   00000002   0x....             LDR      R4,??DataTable7_15  ;; 0x4005a00e
   \   00000004   0x8820             LDRH     R0,[R4, #+0]
   \   00000006   0x0440             LSLS     R0,R0,#+17
   \   00000008   0xD509             BPL      ??tmr3_isr_0
    204            {
    205              if (((TMR3_SCTRL&TMR_SCTRL_TCF_MASK) == TMR_SCTRL_TCF_MASK))
   \   0000000A   0x8820             LDRH     R0,[R4, #+0]
   \   0000000C   0x0400             LSLS     R0,R0,#+16
   \   0000000E   0xD506             BPL      ??tmr3_isr_0
    206              {
    207                ioclrh (TMR3_SCTRL,TMR_SCTRL_TCF_MASK);   /* clear interrupt flag       */
   \   00000010   0x....             LDR      R0,??DataTable7_7  ;; 0x7fff
   \   00000012   0x....             LDR      R1,??DataTable7_16  ;; 0x4405a00e
   \   00000014   0x8008             STRH     R0,[R1, #+0]
    208                pCallbackTMR3 (COMPARE_CALLBACK);
   \   00000016   0x2002             MOVS     R0,#+2
   \   00000018   0x....             LDR      R1,??DataTable7_3
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x4788             BLX      R1
    209              }
    210            }
    211            /* Check for Input capture flag only it its interrupt is enabled            */
    212            if (((TMR3_SCTRL&TMR_SCTRL_IEFIE_MASK) == TMR_SCTRL_IEFIE_MASK))
   \                     ??tmr3_isr_0: (+1)
   \   0000001E   0x8820             LDRH     R0,[R4, #+0]
   \   00000020   0x0540             LSLS     R0,R0,#+21
   \   00000022   0xD509             BPL      ??tmr3_isr_1
    213            {
    214              if (((TMR3_SCTRL&TMR_SCTRL_IEF_MASK) == TMR_SCTRL_IEF_MASK))
   \   00000024   0x8820             LDRH     R0,[R4, #+0]
   \   00000026   0x0500             LSLS     R0,R0,#+20
   \   00000028   0xD506             BPL      ??tmr3_isr_1
    215              {
    216                ioclrh (TMR3_SCTRL,TMR_SCTRL_IEF_MASK);   /* clear interrupt flag       */
   \   0000002A   0x....             LDR      R0,??DataTable7_9  ;; 0xf7ff
   \   0000002C   0x....             LDR      R1,??DataTable7_16  ;; 0x4405a00e
   \   0000002E   0x8008             STRH     R0,[R1, #+0]
    217                pCallbackTMR3 (CAPTURE_CALLBACK);
   \   00000030   0x2004             MOVS     R0,#+4
   \   00000032   0x....             LDR      R1,??DataTable7_3
   \   00000034   0x6809             LDR      R1,[R1, #+0]
   \   00000036   0x4788             BLX      R1
    218              }
    219            }
    220            /* Check for Overflow flag only it its interrupt is enabled                 */
    221            if (((TMR3_SCTRL&TMR_SCTRL_TOFIE_MASK) == TMR_SCTRL_TOFIE_MASK))
   \                     ??tmr3_isr_1: (+1)
   \   00000038   0x8820             LDRH     R0,[R4, #+0]
   \   0000003A   0x04C0             LSLS     R0,R0,#+19
   \   0000003C   0xD509             BPL      ??tmr3_isr_2
    222            {
    223              if (((TMR3_SCTRL&TMR_SCTRL_TOF_MASK) == TMR_SCTRL_TOF_MASK))
   \   0000003E   0x8820             LDRH     R0,[R4, #+0]
   \   00000040   0x0480             LSLS     R0,R0,#+18
   \   00000042   0xD506             BPL      ??tmr3_isr_2
    224              {
    225                ioclrh (TMR3_SCTRL,TMR_SCTRL_TOF_MASK);   /* clear interrupt flag       */
   \   00000044   0x....             LDR      R0,??DataTable7_10  ;; 0xdfff
   \   00000046   0x....             LDR      R1,??DataTable7_16  ;; 0x4405a00e
   \   00000048   0x8008             STRH     R0,[R1, #+0]
    226                pCallbackTMR3 (ROLLOVER_CALLBACK);
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x....             LDR      R1,??DataTable7_3
   \   0000004E   0x6809             LDR      R1,[R1, #+0]
   \   00000050   0x4788             BLX      R1
    227              }
    228            }
    229          }
   \                     ??tmr3_isr_2: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     pCallbackTMR0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0xE000E404         DC32     0xe000e404

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x40057000         DC32     0x40057000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     pCallbackTMR1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0xE000E408         DC32     0xe000e408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x0000FFFE         DC32     0xfffe

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x4005701E         DC32     0x4005701e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x0000FFFD         DC32     0xfffd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     pCallbackTMR2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x40058000         DC32     0x40058000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x0000FFFB         DC32     0xfffb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x40059000         DC32     0x40059000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_3:
   \   00000000   0x........         DC32     pCallbackTMR3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_4:
   \   00000000   0x0000FFF7         DC32     0xfff7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_5:
   \   00000000   0x4005A000         DC32     0x4005a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_6:
   \   00000000   0x4005700E         DC32     0x4005700e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_7:
   \   00000000   0x00007FFF         DC32     0x7fff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_8:
   \   00000000   0x4405700E         DC32     0x4405700e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_9:
   \   00000000   0x0000F7FF         DC32     0xf7ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_10:
   \   00000000   0x0000DFFF         DC32     0xdfff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_11:
   \   00000000   0x4005800E         DC32     0x4005800e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_12:
   \   00000000   0x4405800E         DC32     0x4405800e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_13:
   \   00000000   0x4005900E         DC32     0x4005900e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_14:
   \   00000000   0x4405900E         DC32     0x4405900e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_15:
   \   00000000   0x4005A00E         DC32     0x4005a00e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_16:
   \   00000000   0x4405A00E         DC32     0x4405a00e
    230          /******************************************************************************
    231           * End of module                                                              *
    232           ******************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   TMR_CH0_Init
      28   TMR_CH1_Init
      28   TMR_CH2_Init
      28   TMR_CH3_Init
       8   tmr0_isr
         8   -- Indirect call
       8   tmr1_isr
         8   -- Indirect call
       8   tmr2_isr
         8   -- Indirect call
       8   tmr3_isr
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_10
       4  ??DataTable7_11
       4  ??DataTable7_12
       4  ??DataTable7_13
       4  ??DataTable7_14
       4  ??DataTable7_15
       4  ??DataTable7_16
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable7_7
       4  ??DataTable7_8
       4  ??DataTable7_9
     112  TMR_CH0_Init
     116  TMR_CH1_Init
     116  TMR_CH2_Init
     116  TMR_CH3_Init
       4  pCallbackTMR0
       4  pCallbackTMR1
       4  pCallbackTMR2
       4  pCallbackTMR3
      84  tmr0_isr
      84  tmr1_isr
      84  tmr2_isr
      84  tmr3_isr

 
  16 bytes in section .bss
 908 bytes in section .text
 
 908 bytes of CODE memory
  16 bytes of DATA memory

Errors: none
Warnings: none
