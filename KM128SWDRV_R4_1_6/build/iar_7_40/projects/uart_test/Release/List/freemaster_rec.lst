###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        08/Feb/2017  13:31:58
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_rec.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_rec.c -D
#        NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\uart_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\uart_test\Release\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M0+ --no_mem_idioms -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\uart_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\uart_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\uart_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\uart_test\..\..\..\..\src\projects\uart_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\uart_test\..\..\..\..\src\toolchain\iar\
#        -On --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\uart_test\Release\List\freemaster_rec.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40\projects\uart_test\Release\Obj\freemaster_rec.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\freemaster\freemaster_rec.c
      1          /******************************************************************************
      2          *
      3          * Copyright 2004-2013 Freescale Semiconductor, Inc.
      4          *
      5          * This software is owned or controlled by Freescale Semiconductor.
      6          * Use of this software is governed by the Freescale FreeMASTER License
      7          * distributed with this Material.
      8          * See the license file distributed for more details.
      9          *
     10          ****************************************************************************//*!
     11          *
     12          * @brief  FreeMASTER Recorder implementation.
     13          *
     14          *******************************************************************************/
     15          
     16          #include "freemaster.h"
     17          #include "freemaster_private.h"
     18          #include "freemaster_protocol.h"
     19          
     20          #if (FMSTR_USE_RECORDER) && (!(FMSTR_DISABLE))
     21          
     22          #include "freemaster_rec.h"
     23          
     24          #if FMSTR_USE_FASTREC
     25          #include "freemaster_fastrec.h"
     26          #endif
     27          
     28          /********************************************************
     29          *  global variables (shared with FastRecorder if used)
     30          ********************************************************/
     31          
     32          /* configuration variables */

   \                                 In section .bss, align 2
     33          FMSTR_U16  pcm_wRecTotalSmps;        /* number of samples to measure */
   \                     pcm_wRecTotalSmps:
   \   00000000                      DS8 2
     34          
     35          #if FMSTR_REC_STATIC_POSTTRIG == 0

   \                                 In section .bss, align 2
     36          FMSTR_U16  pcm_wRecPostTrigger;      /* number of post-trigger samples to keep */
   \                     pcm_wRecPostTrigger:
   \   00000000                      DS8 2
     37          #endif
     38          
     39          #if (FMSTR_USE_FASTREC) == 0

   \                                 In section .bss, align 1
     40          FMSTR_U8   pcm_nRecTriggerMode;      /* trigger mode (0 = disabled, 1 = _/, 2 = \_) */
   \                     pcm_nRecTriggerMode:
   \   00000000                      DS8 1
     41          #endif
     42          
     43          #if (FMSTR_REC_STATIC_DIVISOR) == 0

   \                                 In section .bss, align 2
     44          FMSTR_U16  pcm_wRecTimeDiv;          /* divisor of recorder "clock" */
   \                     pcm_wRecTimeDiv:
   \   00000000                      DS8 2
     45          #endif
     46          

   \                                 In section .bss, align 1
     47          FMSTR_U8    pcm_nRecVarCount;        /* number of active recorder variables */
   \                     pcm_nRecVarCount:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     48          FMSTR_ADDR  pcm_pRecVarAddr[FMSTR_MAX_REC_VARS]; /* addresses of recorded variables */
   \                     pcm_pRecVarAddr:
   \   00000000                      DS8 32

   \                                 In section .bss, align 4
     49          FMSTR_SIZE8 pcm_pRecVarSize[FMSTR_MAX_REC_VARS]; /* sizes of recorded variables */
   \                     pcm_pRecVarSize:
   \   00000000                      DS8 8
     50          
     51          /* runtime variables  */
     52          #if (FMSTR_REC_STATIC_DIVISOR) != 1

   \                                 In section .bss, align 2
     53          FMSTR_U16  pcm_wRecTimeDivCtr;       /* recorder "clock" divisor counter */
   \                     pcm_wRecTimeDivCtr:
   \   00000000                      DS8 2
     54          #endif
     55          

   \                                 In section .bss, align 2
     56          FMSTR_U16  pcm_wStoprecCountDown;    /* post-trigger countdown counter */
   \                     pcm_wStoprecCountDown:
   \   00000000                      DS8 2
     57          
     58          /* recorder flags */

   \                                 In section .bss, align 4
     59          FMSTR_REC_FLAGS pcm_wRecFlags;
   \                     pcm_wRecFlags:
   \   00000000                      DS8 4
     60          
     61          /***********************************
     62          *  local variables
     63          ***********************************/
     64          
     65          #if (FMSTR_USE_FASTREC) == 0

   \                                 In section .bss, align 2
     66          FMSTR_U16   pcm_wRecBuffStartIx;     /* first sample index */
   \                     pcm_wRecBuffStartIx:
   \   00000000                      DS8 2
     67          
     68          /* Recorder buffer pointers */

   \                                 In section .bss, align 4
     69          FMSTR_ADDR pcm_dwRecWritePtr;        /* write pointer in recorder buffer */
   \                     pcm_dwRecWritePtr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     70          FMSTR_ADDR pcm_dwRecEndBuffPtr;      /* pointer to end of active recorder buffer */
   \                     pcm_dwRecEndBuffPtr:
   \   00000000                      DS8 4
     71          
     72          /* configuration variables */

   \                                 In section .bss, align 4
     73          static FMSTR_ADDR pcm_nTrgVarAddr;          /* trigger variable address */
   \                     pcm_nTrgVarAddr:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     74          static FMSTR_U8   pcm_nTrgVarSize;          /* trigger variable threshold size */
   \                     pcm_nTrgVarSize:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     75          static FMSTR_U8   pcm_bTrgVarSigned;        /* trigger compare mode (0 = unsigned, 1 = signed) */
   \                     pcm_bTrgVarSigned:
   \   00000000                      DS8 1
     76          
     77          /*lint -e{960} using union */
     78          static union
     79          {
     80          #if FMSTR_CFG_BUS_WIDTH == 1
     81              FMSTR_U8  u8;
     82              FMSTR_S8  s8;
     83          #endif
     84              FMSTR_U16 u16;
     85              FMSTR_S16 s16;
     86              FMSTR_U32 u32;
     87              FMSTR_S32 s32;
     88          #if FMSTR_REC_FLOAT_TRIG
     89              FMSTR_FLOAT fp;
     90          #endif

   \                                 In section .bss, align 4
     91          } pcm_uTrgThreshold;                        /* trigger threshold level (1,2 or 4 bytes) */
   \                     pcm_uTrgThreshold:
   \   00000000                      DS8 4
     92          #endif /* (FMSTR_USE_FASTREC) == 0 */
     93          

   \                                 In section .bss, align 4
     94          static FMSTR_ADDR  pcm_nRecBuffAddr;        /* recorder buffer address */
   \                     pcm_nRecBuffAddr:
   \   00000000                      DS8 4
     95          #if FMSTR_REC_OWNBUFF
     96          static FMSTR_SIZE_RECBUFF  pcm_wRecBuffSize;        /* recorder buffer size */
     97          #endif
     98          /* compare functions prototype */
     99          typedef FMSTR_BOOL (*FMSTR_PCOMPAREFUNC)(void);
    100          
    101          /*/ pointer to active compare function */

   \                                 In section .bss, align 4
    102          static FMSTR_PCOMPAREFUNC pcm_pCompareFunc;
   \                     pcm_pCompareFunc:
   \   00000000                      DS8 4
    103          
    104          #if !FMSTR_REC_OWNBUFF && (FMSTR_USE_FASTREC) == 0
    105          /* put buffer into far memory ? */
    106          #if FMSTR_REC_FARBUFF
    107          #pragma section fardata begin
    108          #endif /* FMSTR_REC_FARBUFF */
    109          /* statically allocated recorder buffer (FMSTR_REC_OWNBUFF is FALSE) */

   \                                 In section .bss, align 4
    110          static FMSTR_U8 pcm_pOwnRecBuffer[FMSTR_REC_BUFF_SIZE];
   \                     pcm_pOwnRecBuffer:
   \   00000000                      DS8 1024
    111          /* end of far memory section */
    112          #if FMSTR_REC_FARBUFF
    113          #pragma section fardata end
    114          #endif /* FMSTR_REC_FARBUFF */
    115          #endif /* FMSTR_REC_OWNBUFF */
    116          
    117          /***********************************
    118          *  local functions
    119          ***********************************/
    120          
    121          static FMSTR_BOOL FMSTR_Compare8S(void);
    122          static FMSTR_BOOL FMSTR_Compare8U(void);
    123          static FMSTR_BOOL FMSTR_Compare16S(void);
    124          static FMSTR_BOOL FMSTR_Compare16U(void);
    125          static FMSTR_BOOL FMSTR_Compare32S(void);
    126          static FMSTR_BOOL FMSTR_Compare32U(void);
    127          #if FMSTR_REC_FLOAT_TRIG
    128          static FMSTR_BOOL FMSTR_Comparefloat(void);
    129          #endif
    130          static void FMSTR_Recorder2(void);
    131          
    132          /**************************************************************************//*!
    133          *
    134          * @brief    Recorder Initialization
    135          *
    136          ******************************************************************************/
    137          

   \                                 In section .text, align 2, keep-with-next
    138          void FMSTR_InitRec(void)
    139          {
    140              /* initialize Recorder flags*/
    141              pcm_wRecFlags.all = 0U;
   \                     FMSTR_InitRec: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR      R1,??DataTable3
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    142          
    143              /* setup buffer pointer and size so IsInRecBuffer works even
    144                 before the recorder is first initialized and used */
    145          
    146          #if FMSTR_REC_OWNBUFF
    147              /* user wants to use his own buffer */
    148              pcm_nRecBuffAddr = 0U;
    149              pcm_wRecBuffSize = 0U;
    150          #elif FMSTR_USE_FASTREC
    151              /* Initialize Fast Recorder Buffer  */
    152              FMSTR_InitFastRec();
    153          #else
    154              /* size in native sizeof units (=bytes on most platforms) */
    155              FMSTR_ARR2ADDR(pcm_nRecBuffAddr, pcm_pOwnRecBuffer);
   \   00000006   0x....             LDR      R0,??DataTable4
   \   00000008   0x....             LDR      R1,??DataTable6
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    156          
    157              /*lint -esym(528, pcm_pOwnRecBuffer) this symbol is used outside of lint sight */
    158          #endif
    159          
    160          }
   \   0000000C   0x4770             BX       LR               ;; return
    161          
    162          /**************************************************************************//*!
    163          *
    164          * @brief    Abort and de-initialize recorder
    165          *
    166          ******************************************************************************/
    167          
    168          #if defined(FMSTR_PLATFORM_HC08) || defined(FMSTR_PLATFORM_HC12)
    169          #pragma INLINE
    170          #elif defined(__ARMCC_VERSION)
    171          static __inline
    172          #else

   \                                 In section .text, align 2, keep-with-next
    173          static inline
    174          #endif
    175          void FMSTR_AbortRec(void)
    176          {
    177              /* clear flags */
    178              pcm_wRecFlags.all = 0U;
   \                     FMSTR_AbortRec: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR      R1,??DataTable3
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    179          }
   \   00000006   0x4770             BX       LR               ;; return
    180          
    181          /**************************************************************************//*!
    182          *
    183          * @brief    API: Replacing the recorder buffer with the user's one
    184          *
    185          * @param    pBuffer - user buffer pointer
    186          * @param    wBuffSize - buffer size
    187          *
    188          * @note Use the FMSTR_SetUpBuff32 to pass the forced 32bit address in SDM
    189          *
    190          ******************************************************************************/
    191          

   \                                 In section .text, align 2, keep-with-next
    192          void FMSTR_SetUpRecBuff(FMSTR_ADDR pBuffer, FMSTR_SIZE_RECBUFF nBuffSize)
    193          {
    194          #if FMSTR_REC_OWNBUFF
    195              pcm_nRecBuffAddr = pBuffer;
    196              pcm_wRecBuffSize = nBuffSize;
    197          #else
    198              FMSTR_UNUSED(pBuffer);
    199              FMSTR_UNUSED(nBuffSize);
    200          #endif
    201          }
   \                     FMSTR_SetUpRecBuff: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    202          
    203          /**************************************************************************//*!
    204          *
    205          * @brief    Handling SETUPREC and SETUPREC_EX commands
    206          *
    207          * @param    pMessageIO - original command (in) and response buffer (out)
    208          *
    209          * @return   As all command handlers, the return value should be the buffer
    210          *           pointer where the response output finished (except checksum)
    211          *
    212          ******************************************************************************/
    213          

   \                                 In section .text, align 2, keep-with-next
    214          FMSTR_BPTR FMSTR_SetUpRec(FMSTR_BPTR pMessageIO)
    215          {
   \                     FMSTR_SetUpRec: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x0004             MOVS     R4,R0
    216              FMSTR_BPTR pResponse = pMessageIO;
   \   00000006   0x9401             STR      R4,[SP, #+4]
    217              FMSTR_SIZE8 nRecVarsetSize;
    218              FMSTR_SIZE_RECBUFF blen;
    219              FMSTR_U8 i, sz;
    220              FMSTR_U8 nResponseCode;
    221          
    222              /* de-initialize first   */
    223              FMSTR_AbortRec();
   \   00000008   0x.... 0x....      BL       FMSTR_AbortRec
    224          
    225          #if FMSTR_REC_OWNBUFF
    226              /* user wants to use his own buffer, check if it is valid */
    227              if(!pcm_nRecBuffAddr || !pcm_wRecBuffSize)
    228              {
    229                  return FMSTR_ConstToBuffer8(pResponse, FMSTR_STC_INVBUFF);
    230              }
    231          #elif (FMSTR_USE_FASTREC) == 0
    232              /* size in native sizeof units (=bytes on most platforms) */
    233              FMSTR_ARR2ADDR(pcm_nRecBuffAddr, pcm_pOwnRecBuffer);
   \   0000000C   0x....             LDR      R0,??DataTable4
   \   0000000E   0x....             LDR      R1,??DataTable6
   \   00000010   0x6008             STR      R0,[R1, #+0]
    234          #endif
    235          
    236              /* seek the setup data */
    237          #if (FMSTR_USE_FASTREC) == 0
    238              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
   \   00000012   0x1CA4             ADDS     R4,R4,#+2
    239              pMessageIO = FMSTR_ValueFromBuffer8(&pcm_nRecTriggerMode, pMessageIO);
   \   00000014   0x7820             LDRB     R0,[R4, #+0]
   \   00000016   0x....             LDR      R1,??DataTable5
   \   00000018   0x7008             STRB     R0,[R1, #+0]
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
    240          #else /* (FMSTR_USE_FASTREC) == 0 */
    241              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 3U);
    242          #endif /* (FMSTR_USE_FASTREC) == 0 */
    243          
    244              pMessageIO = FMSTR_ValueFromBuffer16(&pcm_wRecTotalSmps, pMessageIO);
   \   0000001C   0x0021             MOVS     R1,R4
   \   0000001E   0x....             LDR      R0,??DataTable7
   \   00000020   0x.... 0x....      BL       FMSTR_ValueFromBuffer16
   \   00000024   0x0004             MOVS     R4,R0
    245          
    246          #if (FMSTR_REC_STATIC_POSTTRIG) == 0
    247              pMessageIO = FMSTR_ValueFromBuffer16(&pcm_wRecPostTrigger, pMessageIO);
   \   00000026   0x0021             MOVS     R1,R4
   \   00000028   0x....             LDR      R0,??DataTable5_1
   \   0000002A   0x.... 0x....      BL       FMSTR_ValueFromBuffer16
   \   0000002E   0x0004             MOVS     R4,R0
    248          #else /* (FMSTR_REC_STATIC_POSTTRIG) == 0 */
    249              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    250          #endif /* (FMSTR_REC_STATIC_POSTTRIG) == 0 */
    251          
    252          #if (FMSTR_REC_STATIC_DIVISOR) == 0
    253              pMessageIO = FMSTR_ValueFromBuffer16(&pcm_wRecTimeDiv, pMessageIO);
   \   00000030   0x0021             MOVS     R1,R4
   \   00000032   0x....             LDR      R0,??DataTable5_2
   \   00000034   0x.... 0x....      BL       FMSTR_ValueFromBuffer16
   \   00000038   0x0004             MOVS     R4,R0
    254          #else /* (FMSTR_REC_STATIC_DIVISOR) == 0 */
    255              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 2U);
    256          #endif /* (FMSTR_REC_STATIC_DIVISOR) == 0 */
    257          
    258          #if (FMSTR_USE_FASTREC) == 0
    259              /* address & size of trigger variable */
    260              pMessageIO = FMSTR_AddressFromBuffer(&pcm_nTrgVarAddr, pMessageIO);
   \   0000003A   0x0021             MOVS     R1,R4
   \   0000003C   0x....             LDR      R0,??DataTable5_3
   \   0000003E   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   00000042   0x0004             MOVS     R4,R0
    261              pMessageIO = FMSTR_ValueFromBuffer8(&pcm_nTrgVarSize, pMessageIO);
   \   00000044   0x7820             LDRB     R0,[R4, #+0]
   \   00000046   0x....             LDR      R1,??DataTable6_1
   \   00000048   0x7008             STRB     R0,[R1, #+0]
   \   0000004A   0x1C64             ADDS     R4,R4,#+1
    262          
    263              /* trigger compare mode  */
    264              pMessageIO = FMSTR_ValueFromBuffer8(&pcm_bTrgVarSigned, pMessageIO);
   \   0000004C   0x7820             LDRB     R0,[R4, #+0]
   \   0000004E   0x....             LDR      R1,??DataTable6_2
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   \   00000052   0x1C64             ADDS     R4,R4,#+1
    265          
    266              /* threshold value  */
    267              pMessageIO = FMSTR_ValueFromBuffer32(&pcm_uTrgThreshold.u32, pMessageIO);
   \   00000054   0x0021             MOVS     R1,R4
   \   00000056   0x....             LDR      R0,??DataTable6_3
   \   00000058   0x.... 0x....      BL       FMSTR_ValueFromBuffer32
   \   0000005C   0x0004             MOVS     R4,R0
    268          #else /* (FMSTR_USE_FASTREC) == 0 */
    269              pMessageIO = FMSTR_SkipInBuffer(pMessageIO, 8U);
    270          #endif /* (FMSTR_USE_FASTREC) == 0 */
    271          
    272              /* recorder variable count */
    273              pMessageIO = FMSTR_ValueFromBuffer8(&pcm_nRecVarCount, pMessageIO);
   \   0000005E   0x7820             LDRB     R0,[R4, #+0]
   \   00000060   0x....             LDR      R1,??DataTable6_4
   \   00000062   0x7008             STRB     R0,[R1, #+0]
   \   00000064   0x1C64             ADDS     R4,R4,#+1
    274          
    275              /* rec variable information must fit into our buffers */
    276              if(!pcm_nRecVarCount || pcm_nRecVarCount > (FMSTR_U8)FMSTR_MAX_REC_VARS)
   \   00000066   0x....             LDR      R0,??DataTable6_4
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD003             BEQ      ??FMSTR_SetUpRec_0
   \   0000006E   0x....             LDR      R0,??DataTable6_4
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x2809             CMP      R0,#+9
   \   00000074   0xDB02             BLT      ??FMSTR_SetUpRec_1
    277              {
    278          #if FMSTR_REC_COMMON_ERR_CODES
    279                  goto FMSTR_SetUpRec_exit_error;
    280          #else
    281                  nResponseCode = FMSTR_STC_INVBUFF;
   \                     ??FMSTR_SetUpRec_0: (+1)
   \   00000076   0x2085             MOVS     R0,#+133
   \   00000078   0x0007             MOVS     R7,R0
    282                  goto FMSTR_SetUpRec_exit;
   \   0000007A   0xE089             B        ??FMSTR_SetUpRec_2
    283          #endif
    284              }
    285          
    286              /* calculate sum of sizes of all variables */
    287              nRecVarsetSize = 0U;
   \                     ??FMSTR_SetUpRec_1: (+1)
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x0006             MOVS     R6,R0
    288          
    289              /* get all addresses and sizes */
    290              for(i=0U; i<pcm_nRecVarCount; i++)
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x0005             MOVS     R5,R0
   \                     ??FMSTR_SetUpRec_3: (+1)
   \   00000084   0x....             LDR      R0,??DataTable6_4
   \   00000086   0x7800             LDRB     R0,[R0, #+0]
   \   00000088   0xB2ED             UXTB     R5,R5
   \   0000008A   0x4285             CMP      R5,R0
   \   0000008C   0xD221             BCS      ??FMSTR_SetUpRec_4
    291              {
    292                  /* variable size */
    293                  pMessageIO = FMSTR_ValueFromBuffer8(&sz, pMessageIO);
   \   0000008E   0x7820             LDRB     R0,[R4, #+0]
   \   00000090   0x4669             MOV      R1,SP
   \   00000092   0x7008             STRB     R0,[R1, #+0]
   \   00000094   0x1C64             ADDS     R4,R4,#+1
    294          
    295                  pcm_pRecVarSize[i] = sz;
   \   00000096   0x4668             MOV      R0,SP
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x....             LDR      R1,??DataTable7_1
   \   0000009C   0xB2ED             UXTB     R5,R5
   \   0000009E   0x5548             STRB     R0,[R1, R5]
    296                  nRecVarsetSize += sz;
   \   000000A0   0x4668             MOV      R0,SP
   \   000000A2   0x7800             LDRB     R0,[R0, #+0]
   \   000000A4   0x1836             ADDS     R6,R6,R0
    297          
    298                  /* variable address */
    299                  pMessageIO = FMSTR_AddressFromBuffer(&pcm_pRecVarAddr[i], pMessageIO);
   \   000000A6   0x0021             MOVS     R1,R4
   \   000000A8   0x....             LDR      R0,??DataTable7_2
   \   000000AA   0xB2ED             UXTB     R5,R5
   \   000000AC   0x2204             MOVS     R2,#+4
   \   000000AE   0x436A             MULS     R2,R5,R2
   \   000000B0   0x1880             ADDS     R0,R0,R2
   \   000000B2   0x.... 0x....      BL       FMSTR_AddressFromBuffer
   \   000000B6   0x0004             MOVS     R4,R0
    300          
    301                  /* valid numeric variable sizes only */
    302                  if(sz == 0U || sz > 8U)
   \   000000B8   0x4668             MOV      R0,SP
   \   000000BA   0x7800             LDRB     R0,[R0, #+0]
   \   000000BC   0x2800             CMP      R0,#+0
   \   000000BE   0xD003             BEQ      ??FMSTR_SetUpRec_5
   \   000000C0   0x4668             MOV      R0,SP
   \   000000C2   0x7800             LDRB     R0,[R0, #+0]
   \   000000C4   0x2809             CMP      R0,#+9
   \   000000C6   0xD302             BCC      ??FMSTR_SetUpRec_6
    303                  {
    304          #if FMSTR_REC_COMMON_ERR_CODES
    305                      goto FMSTR_SetUpRec_exit_error;
    306          #else
    307                      nResponseCode = FMSTR_STC_INVSIZE;
   \                     ??FMSTR_SetUpRec_5: (+1)
   \   000000C8   0x2086             MOVS     R0,#+134
   \   000000CA   0x0007             MOVS     R7,R0
    308                      goto FMSTR_SetUpRec_exit;
   \   000000CC   0xE060             B        ??FMSTR_SetUpRec_2
    309          #endif
    310                  }
    311          
    312          #if FMSTR_CFG_BUS_WIDTH > 1U
    313                  /* even sizes only */
    314                  if(sz & 0x1)
    315                  {
    316          #if FMSTR_REC_COMMON_ERR_CODES
    317                      goto FMSTR_SetUpRec_exit_error;
    318          #else
    319                      nResponseCode = FMSTR_STC_INVSIZE;
    320                      goto FMSTR_SetUpRec_exit;
    321          #endif
    322                  }
    323          #endif /* FMSTR_CFG_BUS_WIDTH > 1U */
    324          
    325          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    326                  if(!FMSTR_CheckTsaSpace(pcm_pRecVarAddr[i], (FMSTR_SIZE8)sz, 0U))
    327                  {
    328          #if FMSTR_REC_COMMON_ERR_CODES
    329                      goto FMSTR_SetUpRec_exit_error;
    330          #else
    331                      nResponseCode = FMSTR_STC_EACCESS;
    332                      goto FMSTR_SetUpRec_exit;
    333          #endif
    334                  }
    335          #endif /* FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY */
    336              }
   \                     ??FMSTR_SetUpRec_6: (+1)
   \   000000CE   0x1C6D             ADDS     R5,R5,#+1
   \   000000D0   0xE7D8             B        ??FMSTR_SetUpRec_3
    337          
    338              /* fast recorder handles trigger by itself */
    339          #if (FMSTR_USE_FASTREC) == 0
    340              /* any trigger? */
    341              pcm_pCompareFunc = NULL;
   \                     ??FMSTR_SetUpRec_4: (+1)
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x....             LDR      R1,??DataTable9
   \   000000D6   0x6008             STR      R0,[R1, #+0]
    342              if(pcm_nRecTriggerMode)
   \   000000D8   0x....             LDR      R0,??DataTable5
   \   000000DA   0x7800             LDRB     R0,[R0, #+0]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD036             BEQ      ??FMSTR_SetUpRec_7
    343              {
    344                  /* access to trigger variable? */
    345          #if FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY
    346                  if(!FMSTR_CheckTsaSpace(pcm_nTrgVarAddr, (FMSTR_SIZE8)pcm_nTrgVarSize, 0U))
    347                  {
    348          #if FMSTR_REC_COMMON_ERR_CODES
    349                      goto FMSTR_SetUpRec_exit_error;
    350          #else
    351                      nResponseCode = FMSTR_STC_EACCESS;
    352                      goto FMSTR_SetUpRec_exit;
    353          #endif
    354                  }
    355          #endif /* FMSTR_USE_TSA && FMSTR_USE_TSA_SAFETY */
    356                  /* get compare function */
    357          
    358          #if FMSTR_REC_FLOAT_TRIG
    359                  if(pcm_bTrgVarSigned&FMSTR_REC_FLOAT_TRIG_MASK)
    360                  {
    361                      pcm_pCompareFunc = FMSTR_Comparefloat;
    362                  }
    363                  else
    364          #else
    365                  if(pcm_bTrgVarSigned&FMSTR_REC_FLOAT_TRIG_MASK)
   \   000000E0   0x....             LDR      R0,??DataTable6_2
   \   000000E2   0x7800             LDRB     R0,[R0, #+0]
   \   000000E4   0x0780             LSLS     R0,R0,#+30
   \   000000E6   0xD502             BPL      ??FMSTR_SetUpRec_8
    366                  {
    367          #if FMSTR_REC_COMMON_ERR_CODES
    368                      goto FMSTR_SetUpRec_exit_error;
    369          #else
    370                      nResponseCode = FMSTR_STC_FLOATDISABLED;
   \   000000E8   0x2090             MOVS     R0,#+144
   \   000000EA   0x0007             MOVS     R7,R0
    371                      goto FMSTR_SetUpRec_exit;
   \   000000EC   0xE050             B        ??FMSTR_SetUpRec_2
    372          #endif
    373                  }
    374          #endif
    375                  {
    376                  switch(pcm_nTrgVarSize)
   \                     ??FMSTR_SetUpRec_8: (+1)
   \   000000EE   0x....             LDR      R0,??DataTable6_1
   \   000000F0   0x7800             LDRB     R0,[R0, #+0]
   \   000000F2   0x2801             CMP      R0,#+1
   \   000000F4   0xD004             BEQ      ??FMSTR_SetUpRec_9
   \   000000F6   0x2802             CMP      R0,#+2
   \   000000F8   0xD00E             BEQ      ??FMSTR_SetUpRec_10
   \   000000FA   0x2804             CMP      R0,#+4
   \   000000FC   0xD018             BEQ      ??FMSTR_SetUpRec_11
   \   000000FE   0xE023             B        ??FMSTR_SetUpRec_12
    377                  {
    378          #if FMSTR_CFG_BUS_WIDTH == 1U
    379                  case 1: pcm_pCompareFunc = pcm_bTrgVarSigned ? FMSTR_Compare8S : FMSTR_Compare8U; break;
   \                     ??FMSTR_SetUpRec_9: (+1)
   \   00000100   0x....             LDR      R0,??DataTable6_2
   \   00000102   0x7800             LDRB     R0,[R0, #+0]
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD003             BEQ      ??FMSTR_SetUpRec_13
   \   00000108   0x....             LDR      R0,??DataTable10
   \   0000010A   0x....             LDR      R1,??DataTable9
   \   0000010C   0x6008             STR      R0,[R1, #+0]
   \   0000010E   0xE002             B        ??FMSTR_SetUpRec_14
   \                     ??FMSTR_SetUpRec_13: (+1)
   \   00000110   0x....             LDR      R0,??DataTable10_1
   \   00000112   0x....             LDR      R1,??DataTable9
   \   00000114   0x6008             STR      R0,[R1, #+0]
   \                     ??FMSTR_SetUpRec_14: (+1)
   \   00000116   0xE01A             B        ??FMSTR_SetUpRec_7
    380          #endif
    381                  case 2: pcm_pCompareFunc = pcm_bTrgVarSigned ? FMSTR_Compare16S : FMSTR_Compare16U; break;
   \                     ??FMSTR_SetUpRec_10: (+1)
   \   00000118   0x....             LDR      R0,??DataTable6_2
   \   0000011A   0x7800             LDRB     R0,[R0, #+0]
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD003             BEQ      ??FMSTR_SetUpRec_15
   \   00000120   0x....             LDR      R0,??DataTable11
   \   00000122   0x....             LDR      R1,??DataTable9
   \   00000124   0x6008             STR      R0,[R1, #+0]
   \   00000126   0xE002             B        ??FMSTR_SetUpRec_16
   \                     ??FMSTR_SetUpRec_15: (+1)
   \   00000128   0x....             LDR      R0,??DataTable11_1
   \   0000012A   0x....             LDR      R1,??DataTable9
   \   0000012C   0x6008             STR      R0,[R1, #+0]
   \                     ??FMSTR_SetUpRec_16: (+1)
   \   0000012E   0xE00E             B        ??FMSTR_SetUpRec_7
    382                  case 4: pcm_pCompareFunc = pcm_bTrgVarSigned ? FMSTR_Compare32S : FMSTR_Compare32U; break;
   \                     ??FMSTR_SetUpRec_11: (+1)
   \   00000130   0x....             LDR      R0,??DataTable6_2
   \   00000132   0x7800             LDRB     R0,[R0, #+0]
   \   00000134   0x2800             CMP      R0,#+0
   \   00000136   0xD003             BEQ      ??FMSTR_SetUpRec_17
   \   00000138   0x....             LDR      R0,??DataTable12
   \   0000013A   0x....             LDR      R1,??DataTable9
   \   0000013C   0x6008             STR      R0,[R1, #+0]
   \   0000013E   0xE002             B        ??FMSTR_SetUpRec_18
   \                     ??FMSTR_SetUpRec_17: (+1)
   \   00000140   0x....             LDR      R0,??DataTable12_1
   \   00000142   0x....             LDR      R1,??DataTable9
   \   00000144   0x6008             STR      R0,[R1, #+0]
   \                     ??FMSTR_SetUpRec_18: (+1)
   \   00000146   0xE002             B        ??FMSTR_SetUpRec_7
    383          
    384                  /* invalid trigger variable size  */
    385                  default:
    386          #if FMSTR_REC_COMMON_ERR_CODES
    387                      goto FMSTR_SetUpRec_exit_error;
    388          #else
    389                      nResponseCode = FMSTR_STC_INVSIZE;
   \                     ??FMSTR_SetUpRec_12: (+1)
   \   00000148   0x2086             MOVS     R0,#+134
   \   0000014A   0x0007             MOVS     R7,R0
    390                      goto FMSTR_SetUpRec_exit;
   \   0000014C   0xE020             B        ??FMSTR_SetUpRec_2
    391          #endif
    392                      }
    393                  }
    394              }
    395          #endif /* (FMSTR_USE_FASTREC) == 0 */
    396          
    397              /* total recorder buffer length in native sizeof units (=bytes on most platforms) */
    398              blen = (FMSTR_SIZE_RECBUFF) (pcm_wRecTotalSmps * nRecVarsetSize / FMSTR_CFG_BUS_WIDTH);
   \                     ??FMSTR_SetUpRec_7: (+1)
   \   0000014E   0x....             LDR      R0,??DataTable7
   \   00000150   0x8800             LDRH     R0,[R0, #+0]
   \   00000152   0xB2F6             UXTB     R6,R6
   \   00000154   0x4370             MULS     R0,R6,R0
   \   00000156   0x2101             MOVS     R1,#+1
   \   00000158   0x.... 0x....      BL       __aeabi_idiv
   \   0000015C   0x4669             MOV      R1,SP
   \   0000015E   0x8048             STRH     R0,[R1, #+2]
    399          
    400              /* recorder memory available? */
    401              if(blen > FMSTR_GetRecBuffSize())
   \   00000160   0x.... 0x....      BL       FMSTR_GetRecBuffSize
   \   00000164   0x4669             MOV      R1,SP
   \   00000166   0x8849             LDRH     R1,[R1, #+2]
   \   00000168   0x4288             CMP      R0,R1
   \   0000016A   0xD202             BCS      ??FMSTR_SetUpRec_19
    402              {
    403          #if FMSTR_REC_COMMON_ERR_CODES
    404                  goto FMSTR_SetUpRec_exit_error;
    405          #else
    406                  nResponseCode = FMSTR_STC_INVSIZE;
   \   0000016C   0x2086             MOVS     R0,#+134
   \   0000016E   0x0007             MOVS     R7,R0
    407                  goto FMSTR_SetUpRec_exit;
   \   00000170   0xE00E             B        ??FMSTR_SetUpRec_2
    408          #endif
    409              }
    410          
    411          #if (FMSTR_USE_FASTREC) == 0
    412              /* remember the effective end of circular buffer */
    413              pcm_dwRecEndBuffPtr = pcm_nRecBuffAddr + blen;
   \                     ??FMSTR_SetUpRec_19: (+1)
   \   00000172   0x....             LDR      R0,??DataTable6
   \   00000174   0x6800             LDR      R0,[R0, #+0]
   \   00000176   0x4669             MOV      R1,SP
   \   00000178   0x8849             LDRH     R1,[R1, #+2]
   \   0000017A   0x1840             ADDS     R0,R0,R1
   \   0000017C   0x....             LDR      R1,??DataTable14
   \   0000017E   0x6008             STR      R0,[R1, #+0]
    414          #endif /* (FMSTR_USE_FASTREC) == 0 */
    415          
    416          #if FMSTR_USE_FASTREC
    417              if(!FMSTR_SetUpFastRec())
    418              {
    419          #if FMSTR_REC_COMMON_ERR_CODES
    420                  goto FMSTR_SetUpRec_exit_error;
    421          #else /* FMSTR_REC_COMMON_ERR_CODES */
    422                  nResponseCode = FMSTR_STC_FASTRECERR;
    423                  goto FMSTR_SetUpRec_exit;
    424          #endif /* FMSTR_REC_COMMON_ERR_CODES */
    425              }
    426          #endif /* FMSTR_USE_FASTREC */
    427          
    428              /* everything is okay    */
    429              pcm_wRecFlags.flg.bIsConfigured = 1U;
   \   00000180   0x....             LDR      R0,??DataTable3
   \   00000182   0x6800             LDR      R0,[R0, #+0]
   \   00000184   0x2101             MOVS     R1,#+1
   \   00000186   0x4301             ORRS     R1,R1,R0
   \   00000188   0x....             LDR      R0,??DataTable3
   \   0000018A   0x6001             STR      R1,[R0, #+0]
    430              nResponseCode = FMSTR_STS_OK;
   \   0000018C   0x2000             MOVS     R0,#+0
   \   0000018E   0x0007             MOVS     R7,R0
    431          #if FMSTR_REC_COMMON_ERR_CODES
    432              goto FMSTR_SetUpRec_exit;
    433          FMSTR_SetUpRec_exit_error:
    434              nResponseCode = FMSTR_STC_INVSIZE;
    435          #endif
    436          FMSTR_SetUpRec_exit:
    437              return FMSTR_ConstToBuffer8(pResponse, nResponseCode);
   \                     ??FMSTR_SetUpRec_2: (+1)
   \   00000190   0x9801             LDR      R0,[SP, #+4]
   \   00000192   0x7007             STRB     R7,[R0, #+0]
   \   00000194   0x9801             LDR      R0,[SP, #+4]
   \   00000196   0x1C40             ADDS     R0,R0,#+1
   \   00000198   0xBDFE             POP      {R1-R7,PC}       ;; return
    438          }
    439          
    440          /**************************************************************************//*!
    441          *
    442          * @brief    API: Pull the trigger of the recorder
    443          *
    444          * This function starts the post-trigger stop countdown
    445          *
    446          ******************************************************************************/
    447          

   \                                 In section .text, align 2, keep-with-next
    448          void FMSTR_TriggerRec(void)
    449          {
   \                     FMSTR_TriggerRec: (+1)
   \   00000000   0xB500             PUSH     {LR}
    450              if(!pcm_wRecFlags.flg.bIsStopping)
   \   00000002   0x....             LDR      R0,??DataTable3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0x0749             LSLS     R1,R1,#+29       ;; ZeroExtS R1,R1,#+29,#+31
   \   0000000A   0x0FC9             LSRS     R1,R1,#+31
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD109             BNE      ??FMSTR_TriggerRec_0
    451              {
    452                  pcm_wRecFlags.flg.bIsStopping = 1U;
   \   00000010   0x....             LDR      R0,??DataTable3
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x2104             MOVS     R1,#+4
   \   00000016   0x4301             ORRS     R1,R1,R0
   \   00000018   0x....             LDR      R0,??DataTable3
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    453          #if (FMSTR_REC_STATIC_POSTTRIG) == 0
    454                  pcm_wStoprecCountDown = pcm_wRecPostTrigger;
   \   0000001C   0x....             LDR      R0,??DataTable5_1
   \   0000001E   0x8800             LDRH     R0,[R0, #+0]
   \   00000020   0x....             LDR      R1,??DataTable15
   \   00000022   0x8008             STRH     R0,[R1, #+0]
    455          #else
    456                  pcm_wStoprecCountDown = FMSTR_REC_STATIC_POSTTRIG;
    457          #endif
    458              }
    459          }
   \                     ??FMSTR_TriggerRec_0: (+1)
   \   00000024   0xBD00             POP      {PC}             ;; return
    460          
    461          /**************************************************************************//*!
    462          *
    463          * @brief    Handling STARTREC command
    464          *
    465          * @param    pMessageIO - original command (in) and response buffer (out)
    466          *
    467          * @return   As all command handlers, the return value should be the length
    468          *           of the response filled into the buffer (including status byte)
    469          *
    470          * This function starts recording (initializes internal recording variables
    471          * and flags)
    472          *
    473          ******************************************************************************/
    474          

   \                                 In section .text, align 2, keep-with-next
    475          FMSTR_BPTR FMSTR_StartRec(FMSTR_BPTR pMessageIO)
    476          {
   \                     FMSTR_StartRec: (+1)
   \   00000000   0xB500             PUSH     {LR}
    477               FMSTR_U8 nResponseCode;
    478              /* must be configured */
    479              if(!pcm_wRecFlags.flg.bIsConfigured)
   \   00000002   0x....             LDR      R2,??DataTable15_1
   \   00000004   0x6812             LDR      R2,[R2, #+0]
   \   00000006   0x07D2             LSLS     R2,R2,#+31
   \   00000008   0xD402             BMI      ??FMSTR_StartRec_0
    480              {
    481          #if FMSTR_REC_COMMON_ERR_CODES
    482                  goto FMSTR_StartRec_exit_error;
    483          #else
    484                  nResponseCode = FMSTR_STC_NOTINIT;
   \   0000000A   0x2288             MOVS     R2,#+136
   \   0000000C   0x0011             MOVS     R1,R2
    485                  goto FMSTR_StartRec_exit;
   \   0000000E   0xE02D             B        ??FMSTR_StartRec_1
    486          #endif
    487              }
    488          
    489              /* already running ? */
    490              if(pcm_wRecFlags.flg.bIsRunning)
   \                     ??FMSTR_StartRec_0: (+1)
   \   00000010   0x....             LDR      R2,??DataTable15_1
   \   00000012   0x6812             LDR      R2,[R2, #+0]
   \   00000014   0x0013             MOVS     R3,R2
   \   00000016   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+31
   \   00000018   0x0FDB             LSRS     R3,R3,#+31
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD002             BEQ      ??FMSTR_StartRec_2
    491              {
    492          #if FMSTR_REC_COMMON_ERR_CODES
    493                  goto FMSTR_StartRec_exit_error;
    494          #else
    495                  nResponseCode = FMSTR_STS_RECRUN;
   \   0000001E   0x2201             MOVS     R2,#+1
   \   00000020   0x0011             MOVS     R1,R2
    496                  goto FMSTR_StartRec_exit;
   \   00000022   0xE023             B        ??FMSTR_StartRec_1
    497          #endif
    498              }
    499          
    500          #if (FMSTR_USE_FASTREC) == 0
    501              /* initialize write pointer */
    502              pcm_dwRecWritePtr = pcm_nRecBuffAddr;
   \                     ??FMSTR_StartRec_2: (+1)
   \   00000024   0x....             LDR      R2,??DataTable6
   \   00000026   0x6812             LDR      R2,[R2, #+0]
   \   00000028   0x....             LDR      R3,??DataTable15_2
   \   0000002A   0x601A             STR      R2,[R3, #+0]
    503          
    504              /* current (first) sample index */
    505              pcm_wRecBuffStartIx = 0U;
   \   0000002C   0x2200             MOVS     R2,#+0
   \   0000002E   0x....             LDR      R3,??DataTable15_3
   \   00000030   0x801A             STRH     R2,[R3, #+0]
    506          #endif /* (FMSTR_USE_FASTREC) == 0 */
    507          
    508              /* initialize time divisor */
    509          #if (FMSTR_REC_STATIC_DIVISOR) != 1
    510              pcm_wRecTimeDivCtr = 0U;
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x....             LDR      R3,??DataTable15_4
   \   00000036   0x801A             STRH     R2,[R3, #+0]
    511          #endif
    512          
    513              /* initiate virgin cycle */
    514              pcm_wRecFlags.flg.bIsStopping = 0U;          /* no trigger active */
   \   00000038   0x....             LDR      R2,??DataTable15_1
   \   0000003A   0x6812             LDR      R2,[R2, #+0]
   \   0000003C   0x2304             MOVS     R3,#+4
   \   0000003E   0x439A             BICS     R2,R2,R3
   \   00000040   0x....             LDR      R3,??DataTable15_1
   \   00000042   0x601A             STR      R2,[R3, #+0]
    515              pcm_wRecFlags.flg.bTrgCrossActive = 0U;      /* waiting for threshold crossing */
   \   00000044   0x....             LDR      R2,??DataTable15_1
   \   00000046   0x6812             LDR      R2,[R2, #+0]
   \   00000048   0x2310             MOVS     R3,#+16
   \   0000004A   0x439A             BICS     R2,R2,R3
   \   0000004C   0x....             LDR      R3,??DataTable15_1
   \   0000004E   0x601A             STR      R2,[R3, #+0]
    516              pcm_wRecFlags.flg.bInvirginCycle = 1U;       /* initial cycle */
   \   00000050   0x....             LDR      R2,??DataTable15_1
   \   00000052   0x6812             LDR      R2,[R2, #+0]
   \   00000054   0x2308             MOVS     R3,#+8
   \   00000056   0x4313             ORRS     R3,R3,R2
   \   00000058   0x....             LDR      R2,??DataTable15_1
   \   0000005A   0x6013             STR      R3,[R2, #+0]
    517              /* run now */
    518          
    519              /* start fast recorder */
    520          #if FMSTR_USE_FASTREC
    521              FMSTR_StartFastRec();
    522          #endif /* (MSTR_USE_FASTREC */
    523          
    524              /* run now */
    525              pcm_wRecFlags.flg.bIsRunning = 1U;           /* is running now! */
   \   0000005C   0x....             LDR      R2,??DataTable15_1
   \   0000005E   0x6812             LDR      R2,[R2, #+0]
   \   00000060   0x2302             MOVS     R3,#+2
   \   00000062   0x4313             ORRS     R3,R3,R2
   \   00000064   0x....             LDR      R2,??DataTable15_1
   \   00000066   0x6013             STR      R3,[R2, #+0]
    526          
    527              nResponseCode = FMSTR_STS_OK;
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x0011             MOVS     R1,R2
    528          #if FMSTR_REC_COMMON_ERR_CODES
    529              goto FMSTR_StartRec_exit;
    530          FMSTR_StartRec_exit_error:
    531              nResponseCode = FMSTR_STC_NOTINIT;
    532          #endif
    533          
    534          FMSTR_StartRec_exit:
    535              return FMSTR_ConstToBuffer8(pMessageIO, nResponseCode);
   \                     ??FMSTR_StartRec_1: (+1)
   \   0000006C   0x7001             STRB     R1,[R0, #+0]
   \   0000006E   0x1C40             ADDS     R0,R0,#+1
   \   00000070   0xBD00             POP      {PC}             ;; return
    536          }
    537          
    538          /**************************************************************************//*!
    539          *
    540          * @brief    Handling STOPREC command
    541          *
    542          * @param    pMessageIO - original command (in) and response buffer (out)
    543          *
    544          * @return   As all command handlers, the return value should be the length
    545          *           of the response filled into the buffer (including status byte)
    546          *
    547          * This function stops recording (same as manual trigger)
    548          *
    549          ******************************************************************************/
    550          

   \                                 In section .text, align 2, keep-with-next
    551          FMSTR_BPTR FMSTR_StopRec(FMSTR_BPTR pMessageIO)
    552          {
   \                     FMSTR_StopRec: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
    553              FMSTR_U8 nResponseCode;
    554              /* must be configured */
    555              if(!pcm_wRecFlags.flg.bIsConfigured)
   \   00000004   0x....             LDR      R0,??DataTable15_1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x07C0             LSLS     R0,R0,#+31
   \   0000000A   0xD402             BMI      ??FMSTR_StopRec_0
    556              {
    557                  nResponseCode = FMSTR_STC_NOTINIT;
   \   0000000C   0x2088             MOVS     R0,#+136
   \   0000000E   0x0005             MOVS     R5,R0
    558                  goto FMSTR_StopRec_exit;
   \   00000010   0xE00D             B        ??FMSTR_StopRec_1
    559              }
    560          
    561              /* already stopped ? */
    562              if(!pcm_wRecFlags.flg.bIsRunning)
   \                     ??FMSTR_StopRec_0: (+1)
   \   00000012   0x....             LDR      R0,??DataTable15_1
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x0001             MOVS     R1,R0
   \   00000018   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+31
   \   0000001A   0x0FC9             LSRS     R1,R1,#+31
   \   0000001C   0x2900             CMP      R1,#+0
   \   0000001E   0xD102             BNE      ??FMSTR_StopRec_2
    563              {
    564                  nResponseCode = FMSTR_STS_RECDONE;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0x0005             MOVS     R5,R0
    565                  goto FMSTR_StopRec_exit;
   \   00000024   0xE003             B        ??FMSTR_StopRec_1
    566              }
    567          
    568              /* simulate trigger */
    569              FMSTR_TriggerRec();
   \                     ??FMSTR_StopRec_2: (+1)
   \   00000026   0x.... 0x....      BL       FMSTR_TriggerRec
    570              nResponseCode = FMSTR_STS_OK;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x0005             MOVS     R5,R0
    571          
    572          FMSTR_StopRec_exit:
    573              return FMSTR_ConstToBuffer8(pMessageIO, nResponseCode);
   \                     ??FMSTR_StopRec_1: (+1)
   \   0000002E   0x7025             STRB     R5,[R4, #+0]
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \   00000032   0x0020             MOVS     R0,R4
   \   00000034   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    574          }
    575          
    576          /**************************************************************************//*!
    577          *
    578          * @brief    Handling GETRECSTS command
    579          *
    580          * @param    pMessageIO - original command (in) and response buffer (out)
    581          *
    582          * @return   As all command handlers, the return value should be the buffer
    583          *           pointer where the response output finished (except checksum)
    584          *
    585          * This function returns current recorder status
    586          *
    587          ******************************************************************************/
    588          

   \                                 In section .text, align 2, keep-with-next
    589          FMSTR_BPTR FMSTR_GetRecStatus(FMSTR_BPTR pMessageIO)
    590          {
   \                     FMSTR_GetRecStatus: (+1)
   \   00000000   0xB500             PUSH     {LR}
    591              FMSTR_U16 nResponseCode = (FMSTR_U16) (pcm_wRecFlags.flg.bIsRunning ?
    592                  FMSTR_STS_RECRUN : FMSTR_STS_RECDONE);
   \   00000002   0x....             LDR      R1,??DataTable16
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x000A             MOVS     R2,R1
   \   00000008   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+31
   \   0000000A   0x0FD2             LSRS     R2,R2,#+31
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD001             BEQ      ??FMSTR_GetRecStatus_0
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0xE000             B        ??FMSTR_GetRecStatus_1
   \                     ??FMSTR_GetRecStatus_0: (+1)
   \   00000014   0x2102             MOVS     R1,#+2
    593          
    594              /* must be configured */
    595              if(!pcm_wRecFlags.flg.bIsConfigured)
   \                     ??FMSTR_GetRecStatus_1: (+1)
   \   00000016   0x....             LDR      R2,??DataTable16
   \   00000018   0x6812             LDR      R2,[R2, #+0]
   \   0000001A   0x07D2             LSLS     R2,R2,#+31
   \   0000001C   0xD401             BMI      ??FMSTR_GetRecStatus_2
    596              {
    597                  nResponseCode = FMSTR_STC_NOTINIT;
   \   0000001E   0x2288             MOVS     R2,#+136
   \   00000020   0x0011             MOVS     R1,R2
    598              }
    599          
    600              /* get run/stop status */
    601              return FMSTR_ConstToBuffer8(pMessageIO, (FMSTR_U8) nResponseCode);
   \                     ??FMSTR_GetRecStatus_2: (+1)
   \   00000022   0x7001             STRB     R1,[R0, #+0]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0xBD00             POP      {PC}             ;; return
    602          }
    603          
    604          /* now follows the recorder only routines, skip that if FastRecorder is used */
    605          #if (FMSTR_USE_FASTREC) == 0
    606          
    607          /**************************************************************************//*!
    608          *
    609          * @brief    Get recorder memory size
    610          *
    611          * @return   Recorder memory size in native sizeof units (=bytes on most platforms)
    612          *
    613          ******************************************************************************/
    614          

   \                                 In section .text, align 2, keep-with-next
    615          FMSTR_SIZE_RECBUFF FMSTR_GetRecBuffSize()
    616          {
    617          #if FMSTR_REC_OWNBUFF
    618              return pcm_wRecBuffSize;
    619          #else
    620              return (FMSTR_SIZE_RECBUFF) FMSTR_REC_BUFF_SIZE;
   \                     FMSTR_GetRecBuffSize: (+1)
   \   00000000   0x2080             MOVS     R0,#+128
   \   00000002   0x00C0             LSLS     R0,R0,#+3        ;; #+1024
   \   00000004   0x4770             BX       LR               ;; return
    621          #endif
    622          }
    623          
    624          /**************************************************************************//*!
    625          *
    626          * @brief    Check wether given memory region is inside the recorder buffer
    627          *
    628          * @param    dwAddr - address of the memory to be checked
    629          * @param    wSize  - size of the memory to be checked
    630          *
    631          * @return   This function returns non-zero if user space is in recorder buffer
    632          *
    633          * This function is called as a part of TSA-checking process when the PC host
    634          * is requesting memory contents
    635          *
    636          ******************************************************************************/
    637          

   \                                 In section .text, align 2, keep-with-next
    638          FMSTR_BOOL FMSTR_IsInRecBuffer(FMSTR_ADDR dwAddr, FMSTR_SIZE8 nSize)
    639          {
   \                     FMSTR_IsInRecBuffer: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
    640              FMSTR_BOOL bRet = 0U;
   \   00000006   0x2600             MOVS     R6,#+0
    641          
    642              if(dwAddr >= pcm_nRecBuffAddr)
   \   00000008   0x....             LDR      R0,??DataTable16_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD30B             BCC      ??FMSTR_IsInRecBuffer_0
    643              {
    644                  bRet = (FMSTR_BOOL)((dwAddr + nSize) <= (pcm_nRecBuffAddr + FMSTR_GetRecBuffSize()) ? FMSTR_TRUE : FMSTR_FALSE);
   \   00000010   0x.... 0x....      BL       FMSTR_GetRecBuffSize
   \   00000014   0x....             LDR      R1,??DataTable16_1
   \   00000016   0x6809             LDR      R1,[R1, #+0]
   \   00000018   0x1808             ADDS     R0,R1,R0
   \   0000001A   0xB2E4             UXTB     R4,R4
   \   0000001C   0x1929             ADDS     R1,R5,R4
   \   0000001E   0x4288             CMP      R0,R1
   \   00000020   0xD301             BCC      ??FMSTR_IsInRecBuffer_1
   \   00000022   0x2601             MOVS     R6,#+1
   \   00000024   0xE000             B        ??FMSTR_IsInRecBuffer_0
   \                     ??FMSTR_IsInRecBuffer_1: (+1)
   \   00000026   0x2600             MOVS     R6,#+0
    645              }
    646          
    647              return bRet;
   \                     ??FMSTR_IsInRecBuffer_0: (+1)
   \   00000028   0x0030             MOVS     R0,R6
   \   0000002A   0xB2C0             UXTB     R0,R0
   \   0000002C   0xBD70             POP      {R4-R6,PC}       ;; return
    648          }
    649          
    650          
    651          /**************************************************************************//*!
    652          *
    653          * @brief    Handling GETRECBUFF and GETRECBUFF_EX command
    654          *
    655          * @param    pMessageIO - original command (in) and response buffer (out)
    656          *
    657          * @return   As all command handlers, the return value should be the buffer
    658          *           pointer where the response output finished (except checksum)
    659          *
    660          * This function returns recorder buffer information
    661          *
    662          ******************************************************************************/
    663          

   \                                 In section .text, align 2, keep-with-next
    664          FMSTR_BPTR FMSTR_GetRecBuff(FMSTR_BPTR pMessageIO)
    665          {
   \                     FMSTR_GetRecBuff: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
    666              volatile FMSTR_BPTR pResponse;
    667              /* must be configured */
    668              if(!pcm_wRecFlags.flg.bIsConfigured)
   \   00000006   0x....             LDR      R0,??DataTable15_1
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0x07C0             LSLS     R0,R0,#+31
   \   0000000C   0xD404             BMI      ??FMSTR_GetRecBuff_0
    669              {
    670                  return FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STC_NOTINIT);
   \   0000000E   0x2088             MOVS     R0,#+136
   \   00000010   0x7020             STRB     R0,[R4, #+0]
   \   00000012   0x1C64             ADDS     R4,R4,#+1
   \   00000014   0x0020             MOVS     R0,R4
   \   00000016   0xE01B             B        ??FMSTR_GetRecBuff_1
    671              }
    672          
    673              /* must be stopped */
    674              if(pcm_wRecFlags.flg.bIsRunning)
   \                     ??FMSTR_GetRecBuff_0: (+1)
   \   00000018   0x....             LDR      R0,??DataTable15_1
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x0001             MOVS     R1,R0
   \   0000001E   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+31
   \   00000020   0x0FC9             LSRS     R1,R1,#+31
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD004             BEQ      ??FMSTR_GetRecBuff_2
    675              {
    676                  return FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STC_SERVBUSY);
   \   00000026   0x2087             MOVS     R0,#+135
   \   00000028   0x7020             STRB     R0,[R4, #+0]
   \   0000002A   0x1C64             ADDS     R4,R4,#+1
   \   0000002C   0x0020             MOVS     R0,R4
   \   0000002E   0xE00F             B        ??FMSTR_GetRecBuff_1
    677              }
    678          
    679              /* fill the return info */
    680              pResponse = FMSTR_ConstToBuffer8(pMessageIO, FMSTR_STS_OK);
   \                     ??FMSTR_GetRecBuff_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x7020             STRB     R0,[R4, #+0]
   \   00000034   0x0020             MOVS     R0,R4
   \   00000036   0x1C40             ADDS     R0,R0,#+1
   \   00000038   0x9000             STR      R0,[SP, #+0]
    681              pResponse = FMSTR_AddressToBuffer(pResponse, pcm_nRecBuffAddr);
   \   0000003A   0x....             LDR      R0,??DataTable16_1
   \   0000003C   0x6801             LDR      R1,[R0, #+0]
   \   0000003E   0x9800             LDR      R0,[SP, #+0]
   \   00000040   0x.... 0x....      BL       FMSTR_AddressToBuffer
   \   00000044   0x9000             STR      R0,[SP, #+0]
    682              return FMSTR_ValueToBuffer16(pResponse, pcm_wRecBuffStartIx);
   \   00000046   0x....             LDR      R0,??DataTable16_2
   \   00000048   0x8801             LDRH     R1,[R0, #+0]
   \   0000004A   0x9800             LDR      R0,[SP, #+0]
   \   0000004C   0x.... 0x....      BL       FMSTR_ValueToBuffer16
   \                     ??FMSTR_GetRecBuff_1: (+1)
   \   00000050   0xBD16             POP      {R1,R2,R4,PC}    ;; return
    683          }
    684          
    685          /**************************************************************************//*!
    686          *
    687          * @brief    Compare macro used in trigger detection
    688          *
    689          * @param    v - original command
    690          * @param    t - response buffer
    691          *
    692          * @return   zero when value is lower than threshold.
    693          * @return   non-zero when value is greater than or equal as threshold
    694          *
    695          ******************************************************************************/
    696          
    697          #define CMP(v,t) ((FMSTR_BOOL)(((v) < (t)) ? 0 : 1))
    698          
    699          #if FMSTR_CFG_BUS_WIDTH == 1U
    700          

   \                                 In section .text, align 2, keep-with-next
    701          static FMSTR_BOOL FMSTR_Compare8S()
    702          {
   \                     FMSTR_Compare8S: (+1)
   \   00000000   0xB500             PUSH     {LR}
    703              return CMP(FMSTR_GetS8(pcm_nTrgVarAddr), pcm_uTrgThreshold.s8);
   \   00000002   0x....             LDR      R0,??DataTable16_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x5640             LDRSB    R0,[R0, R1]
   \   0000000A   0x....             LDR      R1,??DataTable16_4
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x5689             LDRSB    R1,[R1, R2]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xDA01             BGE      ??FMSTR_Compare8S_0
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE000             B        ??FMSTR_Compare8S_1
   \                     ??FMSTR_Compare8S_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \                     ??FMSTR_Compare8S_1: (+1)
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0xBD00             POP      {PC}             ;; return
    704          }
    705          

   \                                 In section .text, align 2, keep-with-next
    706          static FMSTR_BOOL FMSTR_Compare8U()
    707          {
   \                     FMSTR_Compare8U: (+1)
   \   00000000   0xB500             PUSH     {LR}
    708              return CMP(FMSTR_GetU8(pcm_nTrgVarAddr), pcm_uTrgThreshold.u8);
   \   00000002   0x....             LDR      R0,??DataTable16_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x....             LDR      R1,??DataTable16_4
   \   0000000A   0x7809             LDRB     R1,[R1, #+0]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD201             BCS      ??FMSTR_Compare8U_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE000             B        ??FMSTR_Compare8U_1
   \                     ??FMSTR_Compare8U_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \                     ??FMSTR_Compare8U_1: (+1)
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0xBD00             POP      {PC}             ;; return
    709          }
    710          
    711          #endif
    712          

   \                                 In section .text, align 2, keep-with-next
    713          static FMSTR_BOOL FMSTR_Compare16S()
    714          {
   \                     FMSTR_Compare16S: (+1)
   \   00000000   0xB500             PUSH     {LR}
    715              return CMP(FMSTR_GetS16(pcm_nTrgVarAddr), pcm_uTrgThreshold.s16);
   \   00000002   0x....             LDR      R0,??DataTable16_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x5E40             LDRSH    R0,[R0, R1]
   \   0000000A   0x....             LDR      R1,??DataTable16_4
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x5E89             LDRSH    R1,[R1, R2]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xDA01             BGE      ??FMSTR_Compare16S_0
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE000             B        ??FMSTR_Compare16S_1
   \                     ??FMSTR_Compare16S_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \                     ??FMSTR_Compare16S_1: (+1)
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0xBD00             POP      {PC}             ;; return
    716          }
    717          

   \                                 In section .text, align 2, keep-with-next
    718          static FMSTR_BOOL FMSTR_Compare16U()
    719          {
   \                     FMSTR_Compare16U: (+1)
   \   00000000   0xB500             PUSH     {LR}
    720              return CMP(FMSTR_GetU16(pcm_nTrgVarAddr), pcm_uTrgThreshold.u16);
   \   00000002   0x....             LDR      R0,??DataTable16_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0x....             LDR      R1,??DataTable16_4
   \   0000000A   0x8809             LDRH     R1,[R1, #+0]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD201             BCS      ??FMSTR_Compare16U_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE000             B        ??FMSTR_Compare16U_1
   \                     ??FMSTR_Compare16U_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \                     ??FMSTR_Compare16U_1: (+1)
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0xBD00             POP      {PC}             ;; return
    721          }
    722          

   \                                 In section .text, align 2, keep-with-next
    723          static FMSTR_BOOL FMSTR_Compare32S()
    724          {
   \                     FMSTR_Compare32S: (+1)
   \   00000000   0xB500             PUSH     {LR}
    725              return CMP(FMSTR_GetS32(pcm_nTrgVarAddr), pcm_uTrgThreshold.s32);
   \   00000002   0x....             LDR      R0,??DataTable16_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x....             LDR      R1,??DataTable16_4
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xDA01             BGE      ??FMSTR_Compare32S_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE000             B        ??FMSTR_Compare32S_1
   \                     ??FMSTR_Compare32S_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \                     ??FMSTR_Compare32S_1: (+1)
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0xBD00             POP      {PC}             ;; return
    726          }
    727          

   \                                 In section .text, align 2, keep-with-next
    728          static FMSTR_BOOL FMSTR_Compare32U()
    729          {
   \                     FMSTR_Compare32U: (+1)
   \   00000000   0xB500             PUSH     {LR}
    730              return CMP(FMSTR_GetU32(pcm_nTrgVarAddr), pcm_uTrgThreshold.u32);
   \   00000002   0x....             LDR      R0,??DataTable16_3
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x....             LDR      R1,??DataTable16_4
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xD201             BCS      ??FMSTR_Compare32U_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE000             B        ??FMSTR_Compare32U_1
   \                     ??FMSTR_Compare32U_0: (+1)
   \   00000014   0x2001             MOVS     R0,#+1
   \                     ??FMSTR_Compare32U_1: (+1)
   \   00000016   0xB2C0             UXTB     R0,R0
   \   00000018   0xBD00             POP      {PC}             ;; return
    731          }
    732          
    733          #if FMSTR_REC_FLOAT_TRIG
    734          static FMSTR_BOOL FMSTR_Comparefloat()
    735          {
    736              return CMP(FMSTR_GetFloat(pcm_nTrgVarAddr), pcm_uTrgThreshold.fp);
    737          }
    738          #endif
    739          
    740          /**************************************************************************//*!
    741          *
    742          * @brief    API: Recorder worker routine - can be called from application's timer ISR
    743          *
    744          *
    745          * This returns quickly if recorder is not running, otherwise it calls quite lengthy
    746          * recorder routine which does all the recorder work (sampling, triggering)
    747          *
    748          ******************************************************************************/
    749          
    750          #if defined(FMSTR_PLATFORM_56F8xxx) || defined(FMSTR_PLATFORM_56F8xx)
    751          #pragma interrupt called
    752          #endif
    753          

   \                                 In section .text, align 2, keep-with-next
    754          void FMSTR_Recorder(void)
    755          {
   \                     FMSTR_Recorder: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    756              /* recorder not active */
    757              if(!pcm_wRecFlags.flg.bIsRunning)
   \   00000002   0x....             LDR      R0,??DataTable16
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0001             MOVS     R1,R0
   \   00000008   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+31
   \   0000000A   0x0FC9             LSRS     R1,R1,#+31
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD001             BEQ      ??FMSTR_Recorder_0
    758              {
    759                  return ;
    760              }
    761          
    762              /* do the hard work      */
    763              FMSTR_Recorder2();
   \                     ??FMSTR_Recorder_1: (+1)
   \   00000010   0x.... 0x....      BL       FMSTR_Recorder2
    764          }
   \                     ??FMSTR_Recorder_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
    765          
    766          /**************************************************************************//*!
    767          *
    768          * @brief    Recorder function called when recorder is active
    769          *
    770          ******************************************************************************/
    771          
    772          #if defined(FMSTR_PLATFORM_56F8xxx) || defined(FMSTR_PLATFORM_56F8xx)
    773          #pragma interrupt called
    774          #endif
    775          

   \                                 In section .text, align 2, keep-with-next
    776          static void FMSTR_Recorder2(void)
    777          {
   \                     FMSTR_Recorder2: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    778              FMSTR_SIZE8 sz;
    779              FMSTR_BOOL cmp;
    780              FMSTR_U8 i;
    781          
    782          #if (FMSTR_REC_STATIC_DIVISOR) != 1
    783              /* skip this call ? */
    784              if(pcm_wRecTimeDivCtr)
   \   00000002   0x....             LDR      R0,??DataTable16_5
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD005             BEQ      ??FMSTR_Recorder2_0
    785              {
    786                  /* maybe next time... */
    787                  pcm_wRecTimeDivCtr--;
   \   0000000A   0x....             LDR      R0,??DataTable16_5
   \   0000000C   0x8800             LDRH     R0,[R0, #+0]
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x....             LDR      R1,??DataTable16_5
   \   00000012   0x8008             STRH     R0,[R1, #+0]
    788                  return;
   \   00000014   0xE089             B        ??FMSTR_Recorder2_1
    789              }
    790          
    791              /* re-initialize divider */
    792          #if (FMSTR_REC_STATIC_DIVISOR) == 0
    793              pcm_wRecTimeDivCtr = pcm_wRecTimeDiv;
   \                     ??FMSTR_Recorder2_0: (+1)
   \   00000016   0x....             LDR      R0,??DataTable16_6
   \   00000018   0x8800             LDRH     R0,[R0, #+0]
   \   0000001A   0x....             LDR      R1,??DataTable16_5
   \   0000001C   0x8008             STRH     R0,[R1, #+0]
    794          #else
    795              pcm_wRecTimeDivCtr = FMSTR_REC_STATIC_DIVISOR;
    796          #endif /* (FMSTR_REC_STATIC_DIVISOR) == 0 */
    797          #endif /* (FMSTR_REC_STATIC_DIVISOR) != 1 */
    798          
    799              /* take snapshot of variable values */
    800              for (i=0U; i<pcm_nRecVarCount; i++)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x0004             MOVS     R4,R0
   \                     ??FMSTR_Recorder2_2: (+1)
   \   00000022   0x....             LDR      R0,??DataTable16_7
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0xB2E4             UXTB     R4,R4
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD21C             BCS      ??FMSTR_Recorder2_3
    801              {
    802                  sz = pcm_pRecVarSize[i];
   \   0000002C   0x....             LDR      R0,??DataTable16_8
   \   0000002E   0xB2E4             UXTB     R4,R4
   \   00000030   0x5D00             LDRB     R0,[R0, R4]
   \   00000032   0x0005             MOVS     R5,R0
    803                  FMSTR_CopyMemory(pcm_dwRecWritePtr, pcm_pRecVarAddr[i], sz);
   \   00000034   0x002A             MOVS     R2,R5
   \   00000036   0xB2D2             UXTB     R2,R2
   \   00000038   0x....             LDR      R0,??DataTable16_9
   \   0000003A   0xB2E4             UXTB     R4,R4
   \   0000003C   0x2104             MOVS     R1,#+4
   \   0000003E   0x4361             MULS     R1,R4,R1
   \   00000040   0x5841             LDR      R1,[R0, R1]
   \   00000042   0x....             LDR      R0,??DataTable16_10
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x.... 0x....      BL       FMSTR_CopyMemory
    804                  sz /= FMSTR_CFG_BUS_WIDTH;
   \   0000004A   0xB2ED             UXTB     R5,R5
   \   0000004C   0x0028             MOVS     R0,R5
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x.... 0x....      BL       __aeabi_idiv
   \   00000054   0x0005             MOVS     R5,R0
    805                  pcm_dwRecWritePtr += sz;
   \   00000056   0x....             LDR      R0,??DataTable16_10
   \   00000058   0x6800             LDR      R0,[R0, #+0]
   \   0000005A   0xB2ED             UXTB     R5,R5
   \   0000005C   0x1940             ADDS     R0,R0,R5
   \   0000005E   0x....             LDR      R1,??DataTable16_10
   \   00000060   0x6008             STR      R0,[R1, #+0]
    806              }
   \   00000062   0x1C64             ADDS     R4,R4,#+1
   \   00000064   0xE7DD             B        ??FMSTR_Recorder2_2
    807          
    808              /* another sample taken (startIx "points" after sample just taken) */
    809              /* i.e. it points to the oldest sample */
    810              pcm_wRecBuffStartIx++;
   \                     ??FMSTR_Recorder2_3: (+1)
   \   00000066   0x....             LDR      R0,??DataTable16_2
   \   00000068   0x8800             LDRH     R0,[R0, #+0]
   \   0000006A   0x1C40             ADDS     R0,R0,#+1
   \   0000006C   0x....             LDR      R1,??DataTable16_2
   \   0000006E   0x8008             STRH     R0,[R1, #+0]
    811          
    812              /* wrap around (circular buffer) ? */
    813              if(pcm_dwRecWritePtr >= pcm_dwRecEndBuffPtr)
   \   00000070   0x....             LDR      R0,??DataTable16_10
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x....             LDR      R1,??DataTable16_11
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xD30C             BCC      ??FMSTR_Recorder2_4
    814              {
    815                  pcm_dwRecWritePtr = pcm_nRecBuffAddr;
   \   0000007C   0x....             LDR      R0,??DataTable16_1
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x....             LDR      R1,??DataTable16_10
   \   00000082   0x6008             STR      R0,[R1, #+0]
    816                  pcm_wRecFlags.flg.bInvirginCycle = 0U;
   \   00000084   0x....             LDR      R0,??DataTable16
   \   00000086   0x6800             LDR      R0,[R0, #+0]
   \   00000088   0x2108             MOVS     R1,#+8
   \   0000008A   0x4388             BICS     R0,R0,R1
   \   0000008C   0x....             LDR      R1,??DataTable16
   \   0000008E   0x6008             STR      R0,[R1, #+0]
    817                  pcm_wRecBuffStartIx = 0U;
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x....             LDR      R1,??DataTable16_2
   \   00000094   0x8008             STRH     R0,[R1, #+0]
    818              }
    819          
    820              /* no trigger testing in virgin cycle */
    821              if(pcm_wRecFlags.flg.bInvirginCycle)
   \                     ??FMSTR_Recorder2_4: (+1)
   \   00000096   0x....             LDR      R0,??DataTable16
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x0001             MOVS     R1,R0
   \   0000009C   0x0709             LSLS     R1,R1,#+28       ;; ZeroExtS R1,R1,#+28,#+31
   \   0000009E   0x0FC9             LSRS     R1,R1,#+31
   \   000000A0   0x2900             CMP      R1,#+0
   \   000000A2   0xD142             BNE      ??FMSTR_Recorder2_1
    822              {
    823                  return;
    824              }
    825          
    826              /* test trigger condition if still running */
    827              if(!pcm_wRecFlags.flg.bIsStopping && pcm_pCompareFunc != NULL)
   \                     ??FMSTR_Recorder2_5: (+1)
   \   000000A4   0x....             LDR      R0,??DataTable16
   \   000000A6   0x6800             LDR      R0,[R0, #+0]
   \   000000A8   0x0001             MOVS     R1,R0
   \   000000AA   0x0749             LSLS     R1,R1,#+29       ;; ZeroExtS R1,R1,#+29,#+31
   \   000000AC   0x0FC9             LSRS     R1,R1,#+31
   \   000000AE   0x2900             CMP      R1,#+0
   \   000000B0   0xD124             BNE      ??FMSTR_Recorder2_6
   \   000000B2   0x....             LDR      R0,??DataTable16_12
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD020             BEQ      ??FMSTR_Recorder2_6
    828              {
    829                  /* compare trigger threshold */
    830                  cmp = pcm_pCompareFunc();
   \   000000BA   0x....             LDR      R0,??DataTable16_12
   \   000000BC   0x6800             LDR      R0,[R0, #+0]
   \   000000BE   0x4780             BLX      R0
   \   000000C0   0x0006             MOVS     R6,R0
    831          
    832                  /* negated logic (falling-edge) ? */
    833                  if(pcm_nRecTriggerMode == 2U)
   \   000000C2   0x....             LDR      R0,??DataTable16_13
   \   000000C4   0x7800             LDRB     R0,[R0, #+0]
   \   000000C6   0x2802             CMP      R0,#+2
   \   000000C8   0xD105             BNE      ??FMSTR_Recorder2_7
    834                  {
    835                      cmp = (FMSTR_BOOL) !cmp;
   \   000000CA   0xB2F6             UXTB     R6,R6
   \   000000CC   0x2E00             CMP      R6,#+0
   \   000000CE   0xD101             BNE      ??FMSTR_Recorder2_8
   \   000000D0   0x2601             MOVS     R6,#+1
   \   000000D2   0xE000             B        ??FMSTR_Recorder2_7
   \                     ??FMSTR_Recorder2_8: (+1)
   \   000000D4   0x2600             MOVS     R6,#+0
    836                  }
    837          
    838                  /* above threshold ? */
    839                  if(cmp)
   \                     ??FMSTR_Recorder2_7: (+1)
   \   000000D6   0xB2F6             UXTB     R6,R6
   \   000000D8   0x2E00             CMP      R6,#+0
   \   000000DA   0xD009             BEQ      ??FMSTR_Recorder2_9
    840                  {
    841                      /* were we at least once below threshold ? */
    842                      if(pcm_wRecFlags.flg.bTrgCrossActive)
   \   000000DC   0x....             LDR      R0,??DataTable16
   \   000000DE   0x6800             LDR      R0,[R0, #+0]
   \   000000E0   0x0001             MOVS     R1,R0
   \   000000E2   0x06C9             LSLS     R1,R1,#+27       ;; ZeroExtS R1,R1,#+27,#+31
   \   000000E4   0x0FC9             LSRS     R1,R1,#+31
   \   000000E6   0x2900             CMP      R1,#+0
   \   000000E8   0xD008             BEQ      ??FMSTR_Recorder2_6
    843                      {
    844                          /* EDGE TRIGGER ! */
    845                          FMSTR_TriggerRec();
   \   000000EA   0x.... 0x....      BL       FMSTR_TriggerRec
   \   000000EE   0xE005             B        ??FMSTR_Recorder2_6
    846                      }
    847                  }
    848                  else
    849                  {
    850                      /* we got bellow threshold, now wait for being above threshold */
    851                      pcm_wRecFlags.flg.bTrgCrossActive = 1U;
   \                     ??FMSTR_Recorder2_9: (+1)
   \   000000F0   0x....             LDR      R0,??DataTable16
   \   000000F2   0x6800             LDR      R0,[R0, #+0]
   \   000000F4   0x2110             MOVS     R1,#+16
   \   000000F6   0x4301             ORRS     R1,R1,R0
   \   000000F8   0x....             LDR      R0,??DataTable16
   \   000000FA   0x6001             STR      R1,[R0, #+0]
    852                  }
    853              }
    854          
    855              /* in stopping mode ? (note that this bit might have been set just above!) */
    856              if(pcm_wRecFlags.flg.bIsStopping)
   \                     ??FMSTR_Recorder2_6: (+1)
   \   000000FC   0x....             LDR      R0,??DataTable16
   \   000000FE   0x6800             LDR      R0,[R0, #+0]
   \   00000100   0x0001             MOVS     R1,R0
   \   00000102   0x0749             LSLS     R1,R1,#+29       ;; ZeroExtS R1,R1,#+29,#+31
   \   00000104   0x0FC9             LSRS     R1,R1,#+31
   \   00000106   0x2900             CMP      R1,#+0
   \   00000108   0xD00F             BEQ      ??FMSTR_Recorder2_10
    857              {
    858                  /* count down post-trigger samples expired ? */
    859                  if(!pcm_wStoprecCountDown)
   \   0000010A   0x....             LDR      R0,??DataTable16_14
   \   0000010C   0x8800             LDRH     R0,[R0, #+0]
   \   0000010E   0x2800             CMP      R0,#+0
   \   00000110   0xD106             BNE      ??FMSTR_Recorder2_11
    860                  {
    861                      /* STOP RECORDER */
    862                      pcm_wRecFlags.flg.bIsRunning = 0U;
   \   00000112   0x....             LDR      R0,??DataTable16
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x2102             MOVS     R1,#+2
   \   00000118   0x4388             BICS     R0,R0,R1
   \   0000011A   0x....             LDR      R1,??DataTable16
   \   0000011C   0x6008             STR      R0,[R1, #+0]
    863                      return;
   \   0000011E   0xE004             B        ??FMSTR_Recorder2_1
    864                  }
    865          
    866                  /* perhaps next time */
    867                  pcm_wStoprecCountDown--;
   \                     ??FMSTR_Recorder2_11: (+1)
   \   00000120   0x....             LDR      R0,??DataTable16_14
   \   00000122   0x8800             LDRH     R0,[R0, #+0]
   \   00000124   0x1E40             SUBS     R0,R0,#+1
   \   00000126   0x....             LDR      R1,??DataTable16_14
   \   00000128   0x8008             STRH     R0,[R1, #+0]
    868              }
    869          }
   \                     ??FMSTR_Recorder2_10: (+1)
   \                     ??FMSTR_Recorder2_1: (+1)
   \   0000012A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     pcm_wRecFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     pcm_pOwnRecBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     pcm_nRecTriggerMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     pcm_wRecPostTrigger

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     pcm_wRecTimeDiv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     pcm_nTrgVarAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     pcm_nRecBuffAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     pcm_nTrgVarSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     pcm_bTrgVarSigned

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     pcm_uTrgThreshold

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     pcm_nRecVarCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     pcm_wRecTotalSmps

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x........         DC32     pcm_pRecVarSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x........         DC32     pcm_pRecVarAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     pcm_pCompareFunc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     FMSTR_Compare8S

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     FMSTR_Compare8U

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     FMSTR_Compare16S

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     FMSTR_Compare16U

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     FMSTR_Compare32S

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x........         DC32     FMSTR_Compare32U

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     pcm_dwRecEndBuffPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   0x........         DC32     pcm_wStoprecCountDown

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_1:
   \   00000000   0x........         DC32     pcm_wRecFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_2:
   \   00000000   0x........         DC32     pcm_dwRecWritePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_3:
   \   00000000   0x........         DC32     pcm_wRecBuffStartIx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable15_4:
   \   00000000   0x........         DC32     pcm_wRecTimeDivCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x........         DC32     pcm_wRecFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x........         DC32     pcm_nRecBuffAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0x........         DC32     pcm_wRecBuffStartIx

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     pcm_nTrgVarAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x........         DC32     pcm_uTrgThreshold

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     pcm_wRecTimeDivCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     pcm_wRecTimeDiv

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x........         DC32     pcm_nRecVarCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x........         DC32     pcm_pRecVarSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x........         DC32     pcm_pRecVarAddr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x........         DC32     pcm_dwRecWritePtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x........         DC32     pcm_dwRecEndBuffPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x........         DC32     pcm_pCompareFunc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x........         DC32     pcm_nRecTriggerMode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   0x........         DC32     pcm_wStoprecCountDown
    870          
    871          #endif /* (FMSTR_USE_FASTREC) == 0 */
    872          
    873          #else /* FMSTR_USE_RECORDER && (!FMSTR_DISABLE) */
    874          
    875          /* use void recorder API functions */
    876          void FMSTR_Recorder(void)
    877          {
    878          }
    879          
    880          void FMSTR_TriggerRec(void)
    881          {
    882          }
    883          
    884          void FMSTR_SetUpRecBuff(FMSTR_ADDR pBuffer, FMSTR_SIZE wBuffSize)
    885          {
    886              FMSTR_UNUSED(pBuffer);
    887              FMSTR_UNUSED(wBuffSize);
    888          }
    889          
    890          /*lint -efile(766, freemaster_protocol.h) include file is not used in this case */
    891          
    892          #endif /* FMSTR_USE_RECORDER && (!FMSTR_DISABLE) */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FMSTR_AbortRec
       4   FMSTR_Compare16S
       4   FMSTR_Compare16U
       4   FMSTR_Compare32S
       4   FMSTR_Compare32U
       4   FMSTR_Compare8S
       4   FMSTR_Compare8U
      16   FMSTR_GetRecBuff
        16   -> FMSTR_AddressToBuffer
        16   -> FMSTR_ValueToBuffer16
       0   FMSTR_GetRecBuffSize
       4   FMSTR_GetRecStatus
       0   FMSTR_InitRec
      16   FMSTR_IsInRecBuffer
        16   -> FMSTR_GetRecBuffSize
       8   FMSTR_Recorder
         8   -> FMSTR_Recorder2
      16   FMSTR_Recorder2
        16   -- Indirect call
        16   -> FMSTR_CopyMemory
        16   -> FMSTR_TriggerRec
        16 __aeabi_idiv
      32   FMSTR_SetUpRec
        32   -> FMSTR_AbortRec
        32   -> FMSTR_AddressFromBuffer
        32   -> FMSTR_GetRecBuffSize
        32   -> FMSTR_ValueFromBuffer16
        32   -> FMSTR_ValueFromBuffer32
        32 __aeabi_idiv
       0   FMSTR_SetUpRecBuff
       4   FMSTR_StartRec
      16   FMSTR_StopRec
        16   -> FMSTR_TriggerRec
       4   FMSTR_TriggerRec


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable3
       4  ??DataTable4
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable9
       8  FMSTR_AbortRec
      30  FMSTR_Compare16S
      26  FMSTR_Compare16U
      26  FMSTR_Compare32S
      26  FMSTR_Compare32U
      30  FMSTR_Compare8S
      26  FMSTR_Compare8U
      82  FMSTR_GetRecBuff
       6  FMSTR_GetRecBuffSize
      40  FMSTR_GetRecStatus
      14  FMSTR_InitRec
      46  FMSTR_IsInRecBuffer
      22  FMSTR_Recorder
     300  FMSTR_Recorder2
     410  FMSTR_SetUpRec
       2  FMSTR_SetUpRecBuff
     114  FMSTR_StartRec
      54  FMSTR_StopRec
      38  FMSTR_TriggerRec
       1  pcm_bTrgVarSigned
       4  pcm_dwRecEndBuffPtr
       4  pcm_dwRecWritePtr
       4  pcm_nRecBuffAddr
       1  pcm_nRecTriggerMode
       1  pcm_nRecVarCount
       4  pcm_nTrgVarAddr
       1  pcm_nTrgVarSize
       4  pcm_pCompareFunc
    1024  pcm_pOwnRecBuffer
      32  pcm_pRecVarAddr
       8  pcm_pRecVarSize
       4  pcm_uTrgThreshold
       2  pcm_wRecBuffStartIx
       4  pcm_wRecFlags
       2  pcm_wRecPostTrigger
       2  pcm_wRecTimeDiv
       2  pcm_wRecTimeDivCtr
       2  pcm_wRecTotalSmps
       2  pcm_wStoprecCountDown

 
 1 108 bytes in section .bss
 1 468 bytes in section .text
 
 1 468 bytes of CODE memory
 1 108 bytes of DATA memory

Errors: none
Warnings: none
