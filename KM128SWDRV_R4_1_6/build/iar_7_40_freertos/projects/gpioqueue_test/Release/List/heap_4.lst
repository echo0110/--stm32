###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        07/Feb/2017  17:55:52
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Freescale\KM128SWDRV_R4_1_6\src\freertos\heap_4.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freertos\heap_4.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\freertos\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\freertos\iar\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\projects\gpioqueue_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\List\heap_4.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\Obj\heap_4.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\freertos\heap_4.c
      1          /*
      2              FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /*
     71           * A sample implementation of pvPortMalloc() and vPortFree() that combines
     72           * (coalescences) adjacent memory blocks as they are freed, and in so doing
     73           * limits memory fragmentation.
     74           *
     75           * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the
     76           * memory management pages of http://www.FreeRTOS.org for more information.
     77           */
     78          #include <stdlib.h>
     79          
     80          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     81          all the API functions to use the MPU wrappers.  That should only be done when
     82          task.h is included from an application file. */
     83          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     84          
     85          #include "freertos.h"
     86          #include "task.h"
     87          
     88          #if(configUSE_HEAP_4)
     89          
     90          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     91          
     92          /* Block sizes must not get too small. */
     93          #define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( xHeapStructSize * 2 ) )
     94          
     95          /* Assumes 8bit bytes! */
     96          #define heapBITS_PER_BYTE		( ( size_t ) 8 )
     97          
     98          /* Allocate the memory for the heap. */
     99          #if( configAPPLICATION_ALLOCATED_HEAP == 1 )
    100          	/* The application writer has already defined the array used for the RTOS
    101          	heap - probably so it can be placed in a special segment or address. */
    102          	extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
    103          #else
    104          	static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
    105          #endif /* configAPPLICATION_ALLOCATED_HEAP */
    106          
    107          /* Define the linked list structure.  This is used to link free blocks in order
    108          of their memory address. */
    109          typedef struct A_BLOCK_LINK
    110          {
    111          	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
    112          	size_t xBlockSize;						/*<< The size of the free block. */
    113          } BlockLink_t;
    114          
    115          /*-----------------------------------------------------------*/
    116          
    117          /*
    118           * Inserts a block of memory that is being freed into the correct position in
    119           * the list of free memory blocks.  The block being freed will be merged with
    120           * the block in front it and/or the block behind it if the memory blocks are
    121           * adjacent to each other.
    122           */
    123          static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
    124          
    125          /*
    126           * Called automatically to setup the required heap structures the first time
    127           * pvPortMalloc() is called.
    128           */
    129          static void prvHeapInit( void );
    130          
    131          /*-----------------------------------------------------------*/
    132          
    133          /* The size of the structure placed at the beginning of each allocated memory
    134          block must by correctly byte aligned. */
    135          static const size_t xHeapStructSize	= ( ( sizeof( BlockLink_t ) + ( ( ( size_t ) portBYTE_ALIGNMENT_MASK ) - ( size_t ) 1 ) ) & ~( ( size_t ) portBYTE_ALIGNMENT_MASK ) );
    136          
    137          /* Create a couple of list links to mark the start and end of the list. */
    138          static BlockLink_t xStart, *pxEnd = NULL;
    139          
    140          /* Keeps track of the number of free bytes remaining, but says nothing about
    141          fragmentation. */
    142          static size_t xFreeBytesRemaining = 0U;
    143          static size_t xMinimumEverFreeBytesRemaining = 0U;
    144          
    145          /* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
    146          member of an BlockLink_t structure is set then the block belongs to the
    147          application.  When the bit is free the block is still part of the free heap
    148          space. */
    149          static size_t xBlockAllocatedBit = 0;
    150          
    151          /*-----------------------------------------------------------*/
    152          
    153          void *pvPortMalloc( size_t xWantedSize )
    154          {
    155          BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
    156          void *pvReturn = NULL;
    157          
    158          	vTaskSuspendAll();
    159          	{
    160          		/* If this is the first call to malloc then the heap will require
    161          		initialisation to setup the list of free blocks. */
    162          		if( pxEnd == NULL )
    163          		{
    164          			prvHeapInit();
    165          		}
    166          		else
    167          		{
    168          			mtCOVERAGE_TEST_MARKER();
    169          		}
    170          
    171          		/* Check the requested block size is not so large that the top bit is
    172          		set.  The top bit of the block size member of the BlockLink_t structure
    173          		is used to determine who owns the block - the application or the
    174          		kernel, so it must be free. */
    175          		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    176          		{
    177          			/* The wanted size is increased so it can contain a BlockLink_t
    178          			structure in addition to the requested amount of bytes. */
    179          			if( xWantedSize > 0 )
    180          			{
    181          				xWantedSize += xHeapStructSize;
    182          
    183          				/* Ensure that blocks are always aligned to the required number
    184          				of bytes. */
    185          				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
    186          				{
    187          					/* Byte alignment required. */
    188          					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
    189          					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
    190          				}
    191          				else
    192          				{
    193          					mtCOVERAGE_TEST_MARKER();
    194          				}
    195          			}
    196          			else
    197          			{
    198          				mtCOVERAGE_TEST_MARKER();
    199          			}
    200          
    201          			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    202          			{
    203          				/* Traverse the list from the start	(lowest address) block until
    204          				one	of adequate size is found. */
    205          				pxPreviousBlock = &xStart;
    206          				pxBlock = xStart.pxNextFreeBlock;
    207          				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    208          				{
    209          					pxPreviousBlock = pxBlock;
    210          					pxBlock = pxBlock->pxNextFreeBlock;
    211          				}
    212          
    213          				/* If the end marker was reached then a block of adequate size
    214          				was	not found. */
    215          				if( pxBlock != pxEnd )
    216          				{
    217          					/* Return the memory space pointed to - jumping over the
    218          					BlockLink_t structure at its start. */
    219          					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    220          
    221          					/* This block is being returned for use so must be taken out
    222          					of the list of free blocks. */
    223          					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    224          
    225          					/* If the block is larger than required it can be split into
    226          					two. */
    227          					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    228          					{
    229          						/* This block is to be split into two.  Create a new
    230          						block following the number of bytes requested. The void
    231          						cast is used to prevent byte alignment warnings from the
    232          						compiler. */
    233          						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    234          						configASSERT( ( ( ( uint32_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    235          
    236          						/* Calculate the sizes of two blocks split from the
    237          						single block. */
    238          						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    239          						pxBlock->xBlockSize = xWantedSize;
    240          
    241          						/* Insert the new block into the list of free blocks. */
    242          						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    243          					}
    244          					else
    245          					{
    246          						mtCOVERAGE_TEST_MARKER();
    247          					}
    248          
    249          					xFreeBytesRemaining -= pxBlock->xBlockSize;
    250          
    251          					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    252          					{
    253          						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    254          					}
    255          					else
    256          					{
    257          						mtCOVERAGE_TEST_MARKER();
    258          					}
    259          
    260          					/* The block is being returned - it is allocated and owned
    261          					by the application and has no "next" block. */
    262          					pxBlock->xBlockSize |= xBlockAllocatedBit;
    263          					pxBlock->pxNextFreeBlock = NULL;
    264          				}
    265          				else
    266          				{
    267          					mtCOVERAGE_TEST_MARKER();
    268          				}
    269          			}
    270          			else
    271          			{
    272          				mtCOVERAGE_TEST_MARKER();
    273          			}
    274          		}
    275          		else
    276          		{
    277          			mtCOVERAGE_TEST_MARKER();
    278          		}
    279          
    280          		traceMALLOC( pvReturn, xWantedSize );
    281          	}
    282          	( void ) xTaskResumeAll();
    283          
    284          	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
    285          	{
    286          		if( pvReturn == NULL )
    287          		{
    288          			extern void vApplicationMallocFailedHook( void );
    289          			vApplicationMallocFailedHook();
    290          		}
    291          		else
    292          		{
    293          			mtCOVERAGE_TEST_MARKER();
    294          		}
    295          	}
    296          	#endif
    297          
    298          	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
    299          	return pvReturn;
    300          }
    301          /*-----------------------------------------------------------*/
    302          
    303          void vPortFree( void *pv )
    304          {
    305          uint8_t *puc = ( uint8_t * ) pv;
    306          BlockLink_t *pxLink;
    307          
    308          	if( pv != NULL )
    309          	{
    310          		/* The memory being freed will have an BlockLink_t structure immediately
    311          		before it. */
    312          		puc -= xHeapStructSize;
    313          
    314          		/* This casting is to keep the compiler from issuing warnings. */
    315          		pxLink = ( void * ) puc;
    316          
    317          		/* Check the block is actually allocated. */
    318          		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
    319          		configASSERT( pxLink->pxNextFreeBlock == NULL );
    320          
    321          		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    322          		{
    323          			if( pxLink->pxNextFreeBlock == NULL )
    324          			{
    325          				/* The block is being returned to the heap - it is no longer
    326          				allocated. */
    327          				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    328          
    329          				vTaskSuspendAll();
    330          				{
    331          					/* Add this block to the list of free blocks. */
    332          					xFreeBytesRemaining += pxLink->xBlockSize;
    333          					traceFREE( pv, pxLink->xBlockSize );
    334          					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    335          				}
    336          				( void ) xTaskResumeAll();
    337          			}
    338          			else
    339          			{
    340          				mtCOVERAGE_TEST_MARKER();
    341          			}
    342          		}
    343          		else
    344          		{
    345          			mtCOVERAGE_TEST_MARKER();
    346          		}
    347          	}
    348          }
    349          /*-----------------------------------------------------------*/
    350          
    351          size_t xPortGetFreeHeapSize( void )
    352          {
    353          	return xFreeBytesRemaining;
    354          }
    355          /*-----------------------------------------------------------*/
    356          
    357          size_t xPortGetMinimumEverFreeHeapSize( void )
    358          {
    359          	return xMinimumEverFreeBytesRemaining;
    360          }
    361          /*-----------------------------------------------------------*/
    362          
    363          void vPortInitialiseBlocks( void )
    364          {
    365          	/* This just exists to keep the linker quiet. */
    366          }
    367          /*-----------------------------------------------------------*/
    368          
    369          static void prvHeapInit( void )
    370          {
    371          BlockLink_t *pxFirstFreeBlock;
    372          uint8_t *pucAlignedHeap;
    373          uint32_t ulAddress;
    374          size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
    375          
    376          	/* Ensure the heap starts on a correctly aligned boundary. */
    377          	ulAddress = ( uint32_t ) ucHeap;
    378          
    379          	if( ( ulAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
    380          	{
    381          		ulAddress += ( portBYTE_ALIGNMENT - 1 );
    382          		ulAddress &= ~( ( uint32_t ) portBYTE_ALIGNMENT_MASK );
    383          		xTotalHeapSize -= ulAddress - ( uint32_t ) ucHeap;
    384          	}
    385          
    386          	pucAlignedHeap = ( uint8_t * ) ulAddress;
    387          
    388          	/* xStart is used to hold a pointer to the first item in the list of free
    389          	blocks.  The void cast is used to prevent compiler warnings. */
    390          	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    391          	xStart.xBlockSize = ( size_t ) 0;
    392          
    393          	/* pxEnd is used to mark the end of the list of free blocks and is inserted
    394          	at the end of the heap space. */
    395          	ulAddress = ( ( uint32_t ) pucAlignedHeap ) + xTotalHeapSize;
    396          	ulAddress -= xHeapStructSize;
    397          	ulAddress &= ~( ( uint32_t ) portBYTE_ALIGNMENT_MASK );
    398          	pxEnd = ( void * ) ulAddress;
    399          	pxEnd->xBlockSize = 0;
    400          	pxEnd->pxNextFreeBlock = NULL;
    401          
    402          	/* To start with there is a single free block that is sized to take up the
    403          	entire heap space, minus the space taken by pxEnd. */
    404          	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
    405          	pxFirstFreeBlock->xBlockSize = ulAddress - ( uint32_t ) pxFirstFreeBlock;
    406          	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    407          
    408          	/* Only one block exists - and it covers the entire usable heap space. */
    409          	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    410          	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    411          
    412          	/* Work out the position of the top bit in a size_t variable. */
    413          	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    414          }
    415          /*-----------------------------------------------------------*/
    416          
    417          static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
    418          {
    419          BlockLink_t *pxIterator;
    420          uint8_t *puc;
    421          
    422          	/* Iterate through the list until a block is found that has a higher address
    423          	than the block being inserted. */
    424          	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    425          	{
    426          		/* Nothing to do here, just iterate to the right position. */
    427          	}
    428          
    429          	/* Do the block being inserted, and the block it is being inserted after
    430          	make a contiguous block of memory? */
    431          	puc = ( uint8_t * ) pxIterator;
    432          	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    433          	{
    434          		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    435          		pxBlockToInsert = pxIterator;
    436          	}
    437          	else
    438          	{
    439          		mtCOVERAGE_TEST_MARKER();
    440          	}
    441          
    442          	/* Do the block being inserted, and the block it is being inserted before
    443          	make a contiguous block of memory? */
    444          	puc = ( uint8_t * ) pxBlockToInsert;
    445          	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    446          	{
    447          		if( pxIterator->pxNextFreeBlock != pxEnd )
    448          		{
    449          			/* Form one big block from the two blocks. */
    450          			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    451          			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    452          		}
    453          		else
    454          		{
    455          			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    456          		}
    457          	}
    458          	else
    459          	{
    460          		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    461          	}
    462          
    463          	/* If the block being inserted plugged a gab, so was merged with the block
    464          	before and the block after, then it's pxNextFreeBlock pointer will have
    465          	already been set, and should not be set here as that would make it point
    466          	to itself. */
    467          	if( pxIterator != pxBlockToInsert )
    468          	{
    469          		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    470          	}
    471          	else
    472          	{
    473          		mtCOVERAGE_TEST_MARKER();
    474          	}
    475          }
    476          
    477          #endif /* configUSE_HEAP_4 */ 


 

 


Errors: none
Warnings: none
