###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        07/Feb/2017  17:55:55
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Freescale\KM128SWDRV_R4_1_6\src\freertos\queue.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freertos\queue.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\freertos\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\freertos\iar\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\projects\gpioqueue_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\List\queue.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\Obj\queue.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\freertos\queue.c
      1          /*
      2              FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          #include <stdlib.h>
     71          #include <string.h>
     72          
     73          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     74          all the API functions to use the MPU wrappers.  That should only be done when
     75          task.h is included from an application file. */
     76          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     77          
     78          #include "freertos.h"
     79          #include "task.h"
     80          #include "queue.h"
     81          
     82          #if ( configUSE_CO_ROUTINES == 1 )
     83          	#include "croutine.h"
     84          #endif
     85          
     86          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     87          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     88          header files above, but not in this file, in order to generate the correct
     89          privileged Vs unprivileged linkage and placement. */
     90          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     91          
     92          
     93          /* Constants used with the xRxLock and xTxLock structure members. */
     94          #define queueUNLOCKED					( ( BaseType_t ) -1 )
     95          #define queueLOCKED_UNMODIFIED			( ( BaseType_t ) 0 )
     96          
     97          /* When the Queue_t structure is used to represent a base queue its pcHead and
     98          pcTail members are used as pointers into the queue storage area.  When the
     99          Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
    100          not necessary, and the pcHead pointer is set to NULL to indicate that the
    101          pcTail pointer actually points to the mutex holder (if any).  Map alternative
    102          names to the pcHead and pcTail structure members to ensure the readability of
    103          the code is maintained despite this dual use of two structure members.  An
    104          alternative implementation would be to use a union, but use of a union is
    105          against the coding standard (although an exception to the standard has been
    106          permitted where the dual use also significantly changes the type of the
    107          structure member). */
    108          #define pxMutexHolder					pcTail
    109          #define uxQueueType						pcHead
    110          #define queueQUEUE_IS_MUTEX				NULL
    111          
    112          /* Semaphores do not actually store or copy data, so have an item size of
    113          zero. */
    114          #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
    115          #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
    116          
    117          #if( configUSE_PREEMPTION == 0 )
    118          	/* If the cooperative scheduler is being used then a yield should not be
    119          	performed just because a higher priority task has been woken. */
    120          	#define queueYIELD_IF_USING_PREEMPTION()
    121          #else
    122          	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
    123          #endif
    124          
    125          /*
    126           * Definition of the queue used by the scheduler.
    127           * Items are queued by copy, not reference.  See the following link for the
    128           * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
    129           */
    130          typedef struct QueueDefinition
    131          {
    132          	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
    133          	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
    134          	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
    135          
    136          	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclusive structure members don't appear simultaneously (wasting RAM). */
    137          	{
    138          		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
    139          		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
    140          	} u;
    141          
    142          	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
    143          	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
    144          
    145          	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
    146          	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
    147          	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
    148          
    149          	volatile BaseType_t xRxLock;	/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
    150          	volatile BaseType_t xTxLock;	/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
    151          
    152          	#if ( configUSE_TRACE_FACILITY == 1 )
    153          		UBaseType_t uxQueueNumber;
    154          		uint8_t ucQueueType;
    155          	#endif
    156          
    157          	#if ( configUSE_QUEUE_SETS == 1 )
    158          		struct QueueDefinition *pxQueueSetContainer;
    159          	#endif
    160          
    161          } xQUEUE;
    162          
    163          /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
    164          name below to enable the use of older kernel aware debuggers. */
    165          typedef xQUEUE Queue_t;
    166          
    167          /*-----------------------------------------------------------*/
    168          
    169          /*
    170           * The queue registry is just a means for kernel aware debuggers to locate
    171           * queue structures.  It has no other purpose so is an optional component.
    172           */
    173          #if ( configQUEUE_REGISTRY_SIZE > 0 )
    174          
    175          	/* The type stored within the queue registry array.  This allows a name
    176          	to be assigned to each queue making kernel aware debugging a little
    177          	more user friendly. */
    178          	typedef struct QUEUE_REGISTRY_ITEM
    179          	{
    180          		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    181          		QueueHandle_t xHandle;
    182          	} xQueueRegistryItem;
    183          
    184          	/* The old xQueueRegistryItem name is maintained above then typedefed to the
    185          	new xQueueRegistryItem name below to enable the use of older kernel aware
    186          	debuggers. */
    187          	typedef xQueueRegistryItem QueueRegistryItem_t;
    188          
    189          	/* The queue registry is simply an array of QueueRegistryItem_t structures.
    190          	The pcQueueName member of a structure being NULL is indicative of the
    191          	array position being vacant. */

   \                                 In section .bss, align 4
    192          	QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
   \                     xQueueRegistry:
   \   00000000                      DS8 80
    193          
    194          #endif /* configQUEUE_REGISTRY_SIZE */
    195          
    196          /*
    197           * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
    198           * prevent an ISR from adding or removing items to the queue, but does prevent
    199           * an ISR from removing tasks from the queue event lists.  If an ISR finds a
    200           * queue is locked it will instead increment the appropriate queue lock count
    201           * to indicate that a task may require unblocking.  When the queue in unlocked
    202           * these lock counts are inspected, and the appropriate action taken.
    203           */
    204          static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
    205          
    206          /*
    207           * Uses a critical section to determine if there is any data in a queue.
    208           *
    209           * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
    210           */
    211          static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
    212          
    213          /*
    214           * Uses a critical section to determine if there is any space in a queue.
    215           *
    216           * @return pdTRUE if there is no space, otherwise pdFALSE;
    217           */
    218          static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
    219          
    220          /*
    221           * Copies an item into the queue, either at the front of the queue or the
    222           * back of the queue.
    223           */
    224          static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
    225          
    226          /*
    227           * Copies an item out of a queue.
    228           */
    229          static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
    230          
    231          #if ( configUSE_QUEUE_SETS == 1 )
    232          	/*
    233          	 * Checks to see if a queue is a member of a queue set, and if so, notifies
    234          	 * the queue set that the queue contains data.
    235          	 */
    236          	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
    237          #endif
    238          
    239          /*-----------------------------------------------------------*/
    240          
    241          /*
    242           * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
    243           * accessing the queue event lists.
    244           */
    245          #define prvLockQueue( pxQueue )								\
    246          	taskENTER_CRITICAL();									\
    247          	{														\
    248          		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
    249          		{													\
    250          			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
    251          		}													\
    252          		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
    253          		{													\
    254          			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
    255          		}													\
    256          	}														\
    257          	taskEXIT_CRITICAL()
    258          /*-----------------------------------------------------------*/
    259          

   \                                 In section .text, align 4, keep-with-next
    260          BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
    261          {
   \                     xQueueGenericReset: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
    262          Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    263          
    264          	configASSERT( pxQueue );
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE      ??xQueueGenericReset_0
   \   0000000C   0xB672             cpsid i
   \                     ??xQueueGenericReset_1: (+1)
   \   0000000E   0xE7FE             B        ??xQueueGenericReset_1
    265          
    266          	taskENTER_CRITICAL();
   \                     ??xQueueGenericReset_0: (+1)
   \   00000010   0x.... 0x....      BL       vPortEnterCritical
    267          	{
    268          		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   \   00000014   0x6828             LDR      R0,[R5, #+0]
   \   00000016   0x6BE9             LDR      R1,[R5, #+60]
   \   00000018   0x6C2A             LDR      R2,[R5, #+64]
   \   0000001A   0x4351             MULS     R1,R2,R1
   \   0000001C   0x1840             ADDS     R0,R0,R1
   \   0000001E   0x6068             STR      R0,[R5, #+4]
    269          		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x63A8             STR      R0,[R5, #+56]
    270          		pxQueue->pcWriteTo = pxQueue->pcHead;
   \   00000024   0x6828             LDR      R0,[R5, #+0]
   \   00000026   0x60A8             STR      R0,[R5, #+8]
    271          		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
   \   00000028   0x6828             LDR      R0,[R5, #+0]
   \   0000002A   0x6BE9             LDR      R1,[R5, #+60]
   \   0000002C   0x1E49             SUBS     R1,R1,#+1
   \   0000002E   0x6C2A             LDR      R2,[R5, #+64]
   \   00000030   0x4351             MULS     R1,R2,R1
   \   00000032   0x1840             ADDS     R0,R0,R1
   \   00000034   0x60E8             STR      R0,[R5, #+12]
    272          		pxQueue->xRxLock = queueUNLOCKED;
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000003A   0x6468             STR      R0,[R5, #+68]
    273          		pxQueue->xTxLock = queueUNLOCKED;
   \   0000003C   0x64A8             STR      R0,[R5, #+72]
    274          
    275          		if( xNewQueue == pdFALSE )
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD10B             BNE      ??xQueueGenericReset_2
    276          		{
    277          			/* If there are tasks blocked waiting to read from the queue, then
    278          			the tasks will remain blocked as after this function exits the queue
    279          			will still be empty.  If there are tasks blocked waiting to write to
    280          			the queue, then one should be unblocked as after this function exits
    281          			it will be possible to write to it. */
    282          			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   \   00000042   0x6928             LDR      R0,[R5, #+16]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD010             BEQ      ??xQueueGenericReset_3
    283          			{
    284          				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   \   00000048   0x3510             ADDS     R5,R5,#+16
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD10A             BNE      ??xQueueGenericReset_3
    285          				{
    286          					queueYIELD_IF_USING_PREEMPTION();
   \   00000054   0x.... 0x....      BL       vPortYield
   \   00000058   0xE007             B        ??xQueueGenericReset_3
    287          				}
    288          				else
    289          				{
    290          					mtCOVERAGE_TEST_MARKER();
    291          				}
    292          			}
    293          			else
    294          			{
    295          				mtCOVERAGE_TEST_MARKER();
    296          			}
    297          		}
    298          		else
    299          		{
    300          			/* Ensure the event queues start in the correct state. */
    301          			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   \                     ??xQueueGenericReset_2: (+1)
   \   0000005A   0x0028             MOVS     R0,R5
   \   0000005C   0x3010             ADDS     R0,R0,#+16
   \   0000005E   0x.... 0x....      BL       vListInitialise
    302          			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   \   00000062   0x3524             ADDS     R5,R5,#+36
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0x.... 0x....      BL       vListInitialise
    303          		}
    304          	}
    305          	taskEXIT_CRITICAL();
   \                     ??xQueueGenericReset_3: (+1)
   \   0000006A   0x.... 0x....      BL       vPortExitCritical
    306          
    307          	/* A value is returned for calling semantic consistency with previous
    308          	versions. */
    309          	return pdPASS;
   \   0000006E   0x2001             MOVS     R0,#+1
   \   00000070   0xB001             ADD      SP,SP,#+4
   \   00000072   0xBD30             POP      {R4,R5,PC}       ;; return
    310          }
    311          /*-----------------------------------------------------------*/
    312          

   \                                 In section .text, align 4, keep-with-next
    313          QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
    314          {
   \                     xQueueGenericCreate: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
    315          Queue_t *pxNewQueue;
    316          size_t xQueueSizeInBytes;
    317          QueueHandle_t xReturn = NULL;
    318          int8_t *pcAllocatedBuffer;
    319          
    320          	/* Remove compiler warnings about unused parameters should
    321          	configUSE_TRACE_FACILITY not be set to 1. */
    322          	( void ) ucQueueType;
    323          
    324          	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE      ??xQueueGenericCreate_0
   \   0000000A   0xB672             cpsid i
   \                     ??xQueueGenericCreate_1: (+1)
   \   0000000C   0xE7FE             B        ??xQueueGenericCreate_1
    325          
    326          	if( uxItemSize == ( UBaseType_t ) 0 )
   \                     ??xQueueGenericCreate_0: (+1)
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD101             BNE      ??xQueueGenericCreate_2
    327          	{
    328          		/* There is not going to be a queue storage area. */
    329          		xQueueSizeInBytes = ( size_t ) 0;
   \   00000012   0x204C             MOVS     R0,#+76
   \   00000014   0xE001             B        ??xQueueGenericCreate_3
    330          	}
    331          	else
    332          	{
    333          		/* The queue is one byte longer than asked for to make wrap checking
    334          		easier/faster. */
    335          		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \                     ??xQueueGenericCreate_2: (+1)
   \   00000016   0x4370             MULS     R0,R6,R0
   \   00000018   0x304D             ADDS     R0,R0,#+77
    336          	}
    337          
    338          	/* Allocate the new queue structure and storage area. */
    339          	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
   \                     ??xQueueGenericCreate_3: (+1)
   \   0000001A   0x.... 0x....      BL       pvPortMalloc
   \   0000001E   0x0005             MOVS     R5,R0
    340          
    341          	if( pcAllocatedBuffer != NULL )
   \   00000020   0x2D00             CMP      R5,#+0
   \   00000022   0xD00D             BEQ      ??xQueueGenericCreate_4
    342          	{
    343          		pxNewQueue = ( Queue_t * ) pcAllocatedBuffer; /*lint !e826 MISRA The buffer cannot be too small because it was dimensioned by sizeof( Queue_t ) + xQueueSizeInBytes. */
    344          
    345          		if( uxItemSize == ( UBaseType_t ) 0 )
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD101             BNE      ??xQueueGenericCreate_5
    346          		{
    347          			/* No RAM was allocated for the queue storage area, but PC head
    348          			cannot be set to NULL because NULL is used as a key to say the queue
    349          			is used as a mutex.  Therefore just set pcHead to point to the queue
    350          			as a benign value that is known to be within the memory map. */
    351          			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
   \   00000028   0x602D             STR      R5,[R5, #+0]
   \   0000002A   0xE001             B        ??xQueueGenericCreate_6
    352          		}
    353          		else
    354          		{
    355          			/* Jump past the queue structure to find the location of the queue
    356          			storage area - adding the padding bytes to get a better alignment. */
    357          			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
   \                     ??xQueueGenericCreate_5: (+1)
   \   0000002C   0x304C             ADDS     R0,R0,#+76
   \   0000002E   0x6028             STR      R0,[R5, #+0]
    358          		}
    359          
    360          		/* Initialise the queue members as described above where the queue type
    361          		is defined. */
    362          		pxNewQueue->uxLength = uxQueueLength;
   \                     ??xQueueGenericCreate_6: (+1)
   \   00000030   0x63EC             STR      R4,[R5, #+60]
    363          		pxNewQueue->uxItemSize = uxItemSize;
   \   00000032   0x642E             STR      R6,[R5, #+64]
    364          		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x0028             MOVS     R0,R5
   \   00000038   0x.... 0x....      BL       xQueueGenericReset
    365          
    366          		#if ( configUSE_TRACE_FACILITY == 1 )
    367          		{
    368          			pxNewQueue->ucQueueType = ucQueueType;
    369          		}
    370          		#endif /* configUSE_TRACE_FACILITY */
    371          
    372          		#if( configUSE_QUEUE_SETS == 1 )
    373          		{
    374          			pxNewQueue->pxQueueSetContainer = NULL;
    375          		}
    376          		#endif /* configUSE_QUEUE_SETS */
    377          
    378          		traceQUEUE_CREATE( pxNewQueue );
    379          		xReturn = pxNewQueue;
    380          	}
    381          	else
    382          	{
    383          		mtCOVERAGE_TEST_MARKER();
    384          	}
    385          
    386          	configASSERT( xReturn );
    387          
    388          	return xReturn;
   \   0000003C   0x0028             MOVS     R0,R5
   \   0000003E   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??xQueueGenericCreate_4: (+1)
   \   00000040   0xB672             cpsid i
   \                     ??xQueueGenericCreate_7: (+1)
   \   00000042   0xE7FE             B        ??xQueueGenericCreate_7
    389          }
    390          /*-----------------------------------------------------------*/
    391          
    392          #if ( configUSE_MUTEXES == 1 )
    393          
    394          	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
    395          	{
    396          	Queue_t *pxNewQueue;
    397          
    398          		/* Prevent compiler warnings about unused parameters if
    399          		configUSE_TRACE_FACILITY does not equal 1. */
    400          		( void ) ucQueueType;
    401          
    402          		/* Allocate the new queue structure. */
    403          		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
    404          		if( pxNewQueue != NULL )
    405          		{
    406          			/* Information required for priority inheritance. */
    407          			pxNewQueue->pxMutexHolder = NULL;
    408          			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    409          
    410          			/* Queues used as a mutex no data is actually copied into or out
    411          			of the queue. */
    412          			pxNewQueue->pcWriteTo = NULL;
    413          			pxNewQueue->u.pcReadFrom = NULL;
    414          
    415          			/* Each mutex has a length of 1 (like a binary semaphore) and
    416          			an item size of 0 as nothing is actually copied into or out
    417          			of the mutex. */
    418          			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    419          			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
    420          			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
    421          			pxNewQueue->xRxLock = queueUNLOCKED;
    422          			pxNewQueue->xTxLock = queueUNLOCKED;
    423          
    424          			#if ( configUSE_TRACE_FACILITY == 1 )
    425          			{
    426          				pxNewQueue->ucQueueType = ucQueueType;
    427          			}
    428          			#endif
    429          
    430          			#if ( configUSE_QUEUE_SETS == 1 )
    431          			{
    432          				pxNewQueue->pxQueueSetContainer = NULL;
    433          			}
    434          			#endif
    435          
    436          			/* Ensure the event queues start with the correct state. */
    437          			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    438          			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    439          
    440          			traceCREATE_MUTEX( pxNewQueue );
    441          
    442          			/* Start with the semaphore in the expected state. */
    443          			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    444          		}
    445          		else
    446          		{
    447          			traceCREATE_MUTEX_FAILED();
    448          		}
    449          
    450          		configASSERT( pxNewQueue );
    451          		return pxNewQueue;
    452          	}
    453          
    454          #endif /* configUSE_MUTEXES */
    455          /*-----------------------------------------------------------*/
    456          
    457          #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
    458          
    459          	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
    460          	{
    461          	void *pxReturn;
    462          
    463          		/* This function is called by xSemaphoreGetMutexHolder(), and should not
    464          		be called directly.  Note:  This is a good way of determining if the
    465          		calling task is the mutex holder, but not a good way of determining the
    466          		identity of the mutex holder, as the holder may change between the
    467          		following critical section exiting and the function returning. */
    468          		taskENTER_CRITICAL();
    469          		{
    470          			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
    471          			{
    472          				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
    473          			}
    474          			else
    475          			{
    476          				pxReturn = NULL;
    477          			}
    478          		}
    479          		taskEXIT_CRITICAL();
    480          
    481          		return pxReturn;
    482          	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
    483          
    484          #endif
    485          /*-----------------------------------------------------------*/
    486          
    487          #if ( configUSE_RECURSIVE_MUTEXES == 1 )
    488          
    489          	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
    490          	{
    491          	BaseType_t xReturn;
    492          	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    493          
    494          		configASSERT( pxMutex );
    495          
    496          		/* If this is the task that holds the mutex then pxMutexHolder will not
    497          		change outside of this task.  If this task does not hold the mutex then
    498          		pxMutexHolder can never coincidentally equal the tasks handle, and as
    499          		this is the only condition we are interested in it does not matter if
    500          		pxMutexHolder is accessed simultaneously by another task.  Therefore no
    501          		mutual exclusion is required to test the pxMutexHolder variable. */
    502          		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
    503          		{
    504          			traceGIVE_MUTEX_RECURSIVE( pxMutex );
    505          
    506          			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
    507          			the task handle, therefore no underflow check is required.  Also,
    508          			uxRecursiveCallCount is only modified by the mutex holder, and as
    509          			there can only be one, no mutual exclusion is required to modify the
    510          			uxRecursiveCallCount member. */
    511          			( pxMutex->u.uxRecursiveCallCount )--;
    512          
    513          			/* Have we unwound the call count? */
    514          			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
    515          			{
    516          				/* Return the mutex.  This will automatically unblock any other
    517          				task that might be waiting to access the mutex. */
    518          				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
    519          			}
    520          			else
    521          			{
    522          				mtCOVERAGE_TEST_MARKER();
    523          			}
    524          
    525          			xReturn = pdPASS;
    526          		}
    527          		else
    528          		{
    529          			/* The mutex cannot be given because the calling task is not the
    530          			holder. */
    531          			xReturn = pdFAIL;
    532          
    533          			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
    534          		}
    535          
    536          		return xReturn;
    537          	}
    538          
    539          #endif /* configUSE_RECURSIVE_MUTEXES */
    540          /*-----------------------------------------------------------*/
    541          
    542          #if ( configUSE_RECURSIVE_MUTEXES == 1 )
    543          
    544          	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
    545          	{
    546          	BaseType_t xReturn;
    547          	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
    548          
    549          		configASSERT( pxMutex );
    550          
    551          		/* Comments regarding mutual exclusion as per those within
    552          		xQueueGiveMutexRecursive(). */
    553          
    554          		traceTAKE_MUTEX_RECURSIVE( pxMutex );
    555          
    556          		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    557          		{
    558          			( pxMutex->u.uxRecursiveCallCount )++;
    559          			xReturn = pdPASS;
    560          		}
    561          		else
    562          		{
    563          			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
    564          
    565          			/* pdPASS will only be returned if the mutex was successfully
    566          			obtained.  The calling task may have entered the Blocked state
    567          			before reaching here. */
    568          			if( xReturn == pdPASS )
    569          			{
    570          				( pxMutex->u.uxRecursiveCallCount )++;
    571          			}
    572          			else
    573          			{
    574          				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
    575          			}
    576          		}
    577          
    578          		return xReturn;
    579          	}
    580          
    581          #endif /* configUSE_RECURSIVE_MUTEXES */
    582          /*-----------------------------------------------------------*/
    583          
    584          #if ( configUSE_COUNTING_SEMAPHORES == 1 )
    585          
    586          	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
    587          	{
    588          	QueueHandle_t xHandle;
    589          
    590          		configASSERT( uxMaxCount != 0 );
    591          		configASSERT( uxInitialCount <= uxMaxCount );
    592          
    593          		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
    594          
    595          		if( xHandle != NULL )
    596          		{
    597          			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
    598          
    599          			traceCREATE_COUNTING_SEMAPHORE();
    600          		}
    601          		else
    602          		{
    603          			traceCREATE_COUNTING_SEMAPHORE_FAILED();
    604          		}
    605          
    606          		configASSERT( xHandle );
    607          		return xHandle;
    608          	}
    609          
    610          #endif /* configUSE_COUNTING_SEMAPHORES */
    611          /*-----------------------------------------------------------*/
    612          

   \                                 In section .text, align 4, keep-with-next
    613          BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
    614          {
   \                     xQueueGenericSend: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x2700             MOVS     R7,#+0
    615          BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    616          TimeOut_t xTimeOut;
    617          Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    618          
    619          	configASSERT( pxQueue );
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE      ??xQueueGenericSend_0
   \   0000000C   0xB672             cpsid i
   \                     ??xQueueGenericSend_1: (+1)
   \   0000000E   0xE7FE             B        ??xQueueGenericSend_1
    620          	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueueGenericSend_0: (+1)
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD102             BNE      ??xQueueGenericSend_2
   \   00000014   0x6C20             LDR      R0,[R4, #+64]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD10D             BNE      ??xQueueGenericSend_3
    621          	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   \                     ??xQueueGenericSend_2: (+1)
   \   0000001A   0x2B02             CMP      R3,#+2
   \   0000001C   0xD102             BNE      ??xQueueGenericSend_4
   \   0000001E   0x6BE0             LDR      R0,[R4, #+60]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD10A             BNE      ??xQueueGenericSend_5
    622          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    623          	{
    624          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xQueueGenericSend_4: (+1)
   \   00000024   0x.... 0x....      BL       xTaskGetSchedulerState
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD11E             BNE      ??xQueueGenericSend_6
   \   0000002C   0x9803             LDR      R0,[SP, #+12]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD01B             BEQ      ??xQueueGenericSend_6
   \   00000032   0xB672             cpsid i
   \                     ??xQueueGenericSend_7: (+1)
   \   00000034   0xE7FE             B        ??xQueueGenericSend_7
    625          	}
   \                     ??xQueueGenericSend_3: (+1)
   \   00000036   0xB672             cpsid i
   \                     ??xQueueGenericSend_8: (+1)
   \   00000038   0xE7FE             B        ??xQueueGenericSend_8
   \                     ??xQueueGenericSend_5: (+1)
   \   0000003A   0xB672             cpsid i
   \                     ??xQueueGenericSend_9: (+1)
   \   0000003C   0xE7FE             B        ??xQueueGenericSend_9
    626          	#endif
    627          
    628          
    629          	/* This function relaxes the coding standard somewhat to allow return
    630          	statements within the function itself.  This is done in the interest
    631          	of execution time efficiency. */
    632          	for( ;; )
    633          	{
    634          		taskENTER_CRITICAL();
    635          		{
    636          			/* Is there room on the queue now?  The running task must be the
    637          			highest priority task wanting to access the queue.  If the head item
    638          			in the queue is to be overwritten then it does not matter if the
    639          			queue is full. */
    640          			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    641          			{
    642          				traceQUEUE_SEND( pxQueue );
    643          				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    644          
    645          				#if ( configUSE_QUEUE_SETS == 1 )
    646          				{
    647          					if( pxQueue->pxQueueSetContainer != NULL )
    648          					{
    649          						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
    650          						{
    651          							/* The queue is a member of a queue set, and posting
    652          							to the queue set caused a higher priority task to
    653          							unblock. A context switch is required. */
    654          							queueYIELD_IF_USING_PREEMPTION();
    655          						}
    656          						else
    657          						{
    658          							mtCOVERAGE_TEST_MARKER();
    659          						}
    660          					}
    661          					else
    662          					{
    663          						/* If there was a task waiting for data to arrive on the
    664          						queue then unblock it now. */
    665          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    666          						{
    667          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    668          							{
    669          								/* The unblocked task has a priority higher than
    670          								our own so yield immediately.  Yes it is ok to
    671          								do this from within the critical section - the
    672          								kernel takes care of that. */
    673          								queueYIELD_IF_USING_PREEMPTION();
    674          							}
    675          							else
    676          							{
    677          								mtCOVERAGE_TEST_MARKER();
    678          							}
    679          						}
    680          						else if( xYieldRequired != pdFALSE )
    681          						{
    682          							/* This path is a special case that will only get
    683          							executed if the task was holding multiple mutexes
    684          							and the mutexes were given back in an order that is
    685          							different to that in which they were taken. */
    686          							queueYIELD_IF_USING_PREEMPTION();
    687          						}
    688          						else
    689          						{
    690          							mtCOVERAGE_TEST_MARKER();
    691          						}
    692          					}
    693          				}
    694          				#else /* configUSE_QUEUE_SETS */
    695          				{
    696          					/* If there was a task waiting for data to arrive on the
    697          					queue then unblock it now. */
    698          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    699          					{
    700          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    701          						{
    702          							/* The unblocked task has a priority higher than
    703          							our own so yield immediately.  Yes it is ok to do
    704          							this from within the critical section - the kernel
    705          							takes care of that. */
    706          							queueYIELD_IF_USING_PREEMPTION();
    707          						}
    708          						else
    709          						{
    710          							mtCOVERAGE_TEST_MARKER();
    711          						}
    712          					}
    713          					else if( xYieldRequired != pdFALSE )
    714          					{
    715          						/* This path is a special case that will only get
    716          						executed if the task was holding multiple mutexes and
    717          						the mutexes were given back in an order that is
    718          						different to that in which they were taken. */
    719          						queueYIELD_IF_USING_PREEMPTION();
    720          					}
    721          					else
    722          					{
    723          						mtCOVERAGE_TEST_MARKER();
    724          					}
    725          				}
    726          				#endif /* configUSE_QUEUE_SETS */
    727          
    728          				taskEXIT_CRITICAL();
    729          				return pdPASS;
    730          			}
    731          			else
    732          			{
    733          				if( xTicksToWait == ( TickType_t ) 0 )
    734          				{
    735          					/* The queue was full and no block time is specified (or
    736          					the block time has expired) so leave now. */
    737          					taskEXIT_CRITICAL();
    738          
    739          					/* Return to the original privilege level before exiting
    740          					the function. */
    741          					traceQUEUE_SEND_FAILED( pxQueue );
    742          					return errQUEUE_FULL;
    743          				}
    744          				else if( xEntryTimeSet == pdFALSE )
    745          				{
    746          					/* The queue was full and a block time was specified so
    747          					configure the timeout structure. */
    748          					vTaskSetTimeOutState( &xTimeOut );
    749          					xEntryTimeSet = pdTRUE;
    750          				}
    751          				else
    752          				{
    753          					/* Entry time was already set. */
    754          					mtCOVERAGE_TEST_MARKER();
    755          				}
    756          			}
    757          		}
    758          		taskEXIT_CRITICAL();
    759          
    760          		/* Interrupts and other tasks can send to and receive from the queue
    761          		now the critical section has been exited. */
    762          
    763          		vTaskSuspendAll();
    764          		prvLockQueue( pxQueue );
    765          
    766          		/* Update the timeout state to see if it has expired yet. */
    767          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    768          		{
    769          			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    770          			{
    771          				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
    772          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    773          
    774          				/* Unlocking the queue means queue events can effect the
    775          				event list.  It is possible	that interrupts occurring now
    776          				remove this task from the event	list again - but as the
    777          				scheduler is suspended the task will go onto the pending
    778          				ready last instead of the actual ready list. */
    779          				prvUnlockQueue( pxQueue );
    780          
    781          				/* Resuming the scheduler will move tasks from the pending
    782          				ready list into the ready list - so it is feasible that this
    783          				task is already in a ready list before it yields - in which
    784          				case the yield will not cause a context switch unless there
    785          				is also a higher priority task in the pending ready list. */
    786          				if( xTaskResumeAll() == pdFALSE )
    787          				{
    788          					portYIELD_WITHIN_API();
    789          				}
    790          			}
    791          			else
    792          			{
   \                     ??xQueueGenericSend_10: (+1)
   \   0000003E   0x0020             MOVS     R0,R4
   \   00000040   0x3010             ADDS     R0,R0,#+16
   \   00000042   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD001             BEQ      ??xQueueGenericSend_11
   \   0000004A   0x.... 0x....      BL       vTaskMissedYield
   \                     ??xQueueGenericSend_11: (+1)
   \   0000004E   0x6C60             LDR      R0,[R4, #+68]
   \   00000050   0x1E40             SUBS     R0,R0,#+1
   \   00000052   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueGenericSend_12: (+1)
   \   00000054   0x6C60             LDR      R0,[R4, #+68]
   \   00000056   0x2801             CMP      R0,#+1
   \   00000058   0xDB02             BLT      ??xQueueGenericSend_13
   \   0000005A   0x6920             LDR      R0,[R4, #+16]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD1EE             BNE      ??xQueueGenericSend_10
   \                     ??xQueueGenericSend_13: (+1)
   \   00000060   0x6465             STR      R5,[R4, #+68]
   \   00000062   0x.... 0x....      BL       vPortExitCritical
    793          				/* Try again. */
    794          				prvUnlockQueue( pxQueue );
    795          				( void ) xTaskResumeAll();
   \   00000066   0x.... 0x....      BL       xTaskResumeAll
   \                     ??xQueueGenericSend_6: (+1)
   \   0000006A   0x.... 0x....      BL       vPortEnterCritical
   \   0000006E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000070   0x6BE1             LDR      R1,[R4, #+60]
   \   00000072   0x4288             CMP      R0,R1
   \   00000074   0xD302             BCC      ??xQueueGenericSend_14
   \   00000076   0x9804             LDR      R0,[SP, #+16]
   \   00000078   0x2802             CMP      R0,#+2
   \   0000007A   0xD13C             BNE      ??xQueueGenericSend_15
   \                     ??xQueueGenericSend_14: (+1)
   \   0000007C   0x6C22             LDR      R2,[R4, #+64]
   \   0000007E   0x2A00             CMP      R2,#+0
   \   00000080   0xD027             BEQ      ??xQueueGenericSend_16
   \   00000082   0x9804             LDR      R0,[SP, #+16]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0x9902             LDR      R1,[SP, #+8]
   \   00000088   0xD10C             BNE      ??xQueueGenericSend_17
   \   0000008A   0x68A0             LDR      R0,[R4, #+8]
   \   0000008C   0x.... 0x....      BL       __aeabi_memcpy
   \   00000090   0x68A0             LDR      R0,[R4, #+8]
   \   00000092   0x6C21             LDR      R1,[R4, #+64]
   \   00000094   0x1840             ADDS     R0,R0,R1
   \   00000096   0x60A0             STR      R0,[R4, #+8]
   \   00000098   0x6861             LDR      R1,[R4, #+4]
   \   0000009A   0x4288             CMP      R0,R1
   \   0000009C   0xD319             BCC      ??xQueueGenericSend_16
   \   0000009E   0x6820             LDR      R0,[R4, #+0]
   \   000000A0   0x60A0             STR      R0,[R4, #+8]
   \   000000A2   0xE016             B        ??xQueueGenericSend_16
   \                     ??xQueueGenericSend_17: (+1)
   \   000000A4   0x68E0             LDR      R0,[R4, #+12]
   \   000000A6   0x.... 0x....      BL       __aeabi_memcpy
   \   000000AA   0x68E0             LDR      R0,[R4, #+12]
   \   000000AC   0x6C21             LDR      R1,[R4, #+64]
   \   000000AE   0x1A40             SUBS     R0,R0,R1
   \   000000B0   0x60E0             STR      R0,[R4, #+12]
   \   000000B2   0x6821             LDR      R1,[R4, #+0]
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xD203             BCS      ??xQueueGenericSend_18
   \   000000B8   0x6860             LDR      R0,[R4, #+4]
   \   000000BA   0x6C21             LDR      R1,[R4, #+64]
   \   000000BC   0x1A40             SUBS     R0,R0,R1
   \   000000BE   0x60E0             STR      R0,[R4, #+12]
   \                     ??xQueueGenericSend_18: (+1)
   \   000000C0   0x9804             LDR      R0,[SP, #+16]
   \   000000C2   0x2802             CMP      R0,#+2
   \   000000C4   0xD105             BNE      ??xQueueGenericSend_16
   \   000000C6   0x6BA0             LDR      R0,[R4, #+56]
   \   000000C8   0x2800             CMP      R0,#+0
   \   000000CA   0xD002             BEQ      ??xQueueGenericSend_16
   \   000000CC   0x6BA0             LDR      R0,[R4, #+56]
   \   000000CE   0x1E40             SUBS     R0,R0,#+1
   \   000000D0   0x63A0             STR      R0,[R4, #+56]
   \                     ??xQueueGenericSend_16: (+1)
   \   000000D2   0x6BA0             LDR      R0,[R4, #+56]
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x63A0             STR      R0,[R4, #+56]
   \   000000D8   0x6A60             LDR      R0,[R4, #+36]
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD007             BEQ      ??xQueueGenericSend_19
   \   000000DE   0x3424             ADDS     R4,R4,#+36
   \   000000E0   0x0020             MOVS     R0,R4
   \   000000E2   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   000000E6   0x2801             CMP      R0,#+1
   \   000000E8   0xD101             BNE      ??xQueueGenericSend_19
   \   000000EA   0x.... 0x....      BL       vPortYield
   \                     ??xQueueGenericSend_19: (+1)
   \   000000EE   0x.... 0x....      BL       vPortExitCritical
   \   000000F2   0x2001             MOVS     R0,#+1
   \   000000F4   0xE0B8             B        ??xQueueGenericSend_20
   \                     ??xQueueGenericSend_15: (+1)
   \   000000F6   0x9803             LDR      R0,[SP, #+12]
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD102             BNE      ??xQueueGenericSend_21
   \   000000FC   0x.... 0x....      BL       vPortExitCritical
   \   00000100   0xE0B1             B        ??xQueueGenericSend_22
   \                     ??xQueueGenericSend_21: (+1)
   \   00000102   0x2F00             CMP      R7,#+0
   \   00000104   0xD103             BNE      ??xQueueGenericSend_23
   \   00000106   0x4668             MOV      R0,SP
   \   00000108   0x.... 0x....      BL       vTaskSetTimeOutState
   \   0000010C   0x2701             MOVS     R7,#+1
   \                     ??xQueueGenericSend_23: (+1)
   \   0000010E   0x.... 0x....      BL       vPortExitCritical
   \   00000112   0x.... 0x....      BL       vTaskSuspendAll
   \   00000116   0x.... 0x....      BL       vPortEnterCritical
   \   0000011A   0x2500             MOVS     R5,#+0
   \   0000011C   0x43ED             MVNS     R5,R5            ;; #-1
   \   0000011E   0x6C60             LDR      R0,[R4, #+68]
   \   00000120   0x42A8             CMP      R0,R5
   \   00000122   0xD101             BNE      ??xQueueGenericSend_24
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueGenericSend_24: (+1)
   \   00000128   0x6CA0             LDR      R0,[R4, #+72]
   \   0000012A   0x42A8             CMP      R0,R5
   \   0000012C   0xD101             BNE      ??xQueueGenericSend_25
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x64A0             STR      R0,[R4, #+72]
   \                     ??xQueueGenericSend_25: (+1)
   \   00000132   0x.... 0x....      BL       vPortExitCritical
   \   00000136   0xA903             ADD      R1,SP,#+12
   \   00000138   0x4668             MOV      R0,SP
   \   0000013A   0x.... 0x....      BL       xTaskCheckForTimeOut
   \   0000013E   0x2800             CMP      R0,#+0
   \   00000140   0xD161             BNE      ??xQueueGenericSend_26
   \   00000142   0x.... 0x....      BL       vPortEnterCritical
   \   00000146   0x6BA0             LDR      R0,[R4, #+56]
   \   00000148   0x6BE1             LDR      R1,[R4, #+60]
   \   0000014A   0x4288             CMP      R0,R1
   \   0000014C   0xD101             BNE      ??xQueueGenericSend_27
   \   0000014E   0x2601             MOVS     R6,#+1
   \   00000150   0xE000             B        ??xQueueGenericSend_28
   \                     ??xQueueGenericSend_27: (+1)
   \   00000152   0x2600             MOVS     R6,#+0
   \                     ??xQueueGenericSend_28: (+1)
   \   00000154   0x.... 0x....      BL       vPortExitCritical
   \   00000158   0x2E00             CMP      R6,#+0
   \   0000015A   0xD03A             BEQ      ??xQueueGenericSend_29
   \   0000015C   0x9903             LDR      R1,[SP, #+12]
   \   0000015E   0x0020             MOVS     R0,R4
   \   00000160   0x3010             ADDS     R0,R0,#+16
   \   00000162   0x.... 0x....      BL       vTaskPlaceOnEventList
   \   00000166   0x.... 0x....      BL       vPortEnterCritical
   \   0000016A   0xE00A             B        ??xQueueGenericSend_30
   \                     ??xQueueGenericSend_31: (+1)
   \   0000016C   0x0020             MOVS     R0,R4
   \   0000016E   0x3024             ADDS     R0,R0,#+36
   \   00000170   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000174   0x2800             CMP      R0,#+0
   \   00000176   0xD001             BEQ      ??xQueueGenericSend_32
   \   00000178   0x.... 0x....      BL       vTaskMissedYield
   \                     ??xQueueGenericSend_32: (+1)
   \   0000017C   0x6CA0             LDR      R0,[R4, #+72]
   \   0000017E   0x1E40             SUBS     R0,R0,#+1
   \   00000180   0x64A0             STR      R0,[R4, #+72]
   \                     ??xQueueGenericSend_30: (+1)
   \   00000182   0x6CA0             LDR      R0,[R4, #+72]
   \   00000184   0x2801             CMP      R0,#+1
   \   00000186   0xDB02             BLT      ??xQueueGenericSend_33
   \   00000188   0x6A60             LDR      R0,[R4, #+36]
   \   0000018A   0x2800             CMP      R0,#+0
   \   0000018C   0xD1EE             BNE      ??xQueueGenericSend_31
   \                     ??xQueueGenericSend_33: (+1)
   \   0000018E   0x64A5             STR      R5,[R4, #+72]
   \   00000190   0x.... 0x....      BL       vPortExitCritical
   \   00000194   0x.... 0x....      BL       vPortEnterCritical
   \   00000198   0xE00A             B        ??xQueueGenericSend_34
   \                     ??xQueueGenericSend_35: (+1)
   \   0000019A   0x0020             MOVS     R0,R4
   \   0000019C   0x3010             ADDS     R0,R0,#+16
   \   0000019E   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   000001A2   0x2800             CMP      R0,#+0
   \   000001A4   0xD001             BEQ      ??xQueueGenericSend_36
   \   000001A6   0x.... 0x....      BL       vTaskMissedYield
   \                     ??xQueueGenericSend_36: (+1)
   \   000001AA   0x6C60             LDR      R0,[R4, #+68]
   \   000001AC   0x1E40             SUBS     R0,R0,#+1
   \   000001AE   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueGenericSend_34: (+1)
   \   000001B0   0x6C60             LDR      R0,[R4, #+68]
   \   000001B2   0x2801             CMP      R0,#+1
   \   000001B4   0xDB02             BLT      ??xQueueGenericSend_37
   \   000001B6   0x6920             LDR      R0,[R4, #+16]
   \   000001B8   0x2800             CMP      R0,#+0
   \   000001BA   0xD1EE             BNE      ??xQueueGenericSend_35
   \                     ??xQueueGenericSend_37: (+1)
   \   000001BC   0x6465             STR      R5,[R4, #+68]
   \   000001BE   0x.... 0x....      BL       vPortExitCritical
   \   000001C2   0x.... 0x....      BL       xTaskResumeAll
   \   000001C6   0x2800             CMP      R0,#+0
   \   000001C8   0xD000             BEQ      .+4
   \   000001CA   0xE74E             B        ??xQueueGenericSend_6
   \   000001CC   0x.... 0x....      BL       vPortYield
   \   000001D0   0xE74B             B        ??xQueueGenericSend_6
   \                     ??xQueueGenericSend_29: (+1)
   \   000001D2   0x.... 0x....      BL       vPortEnterCritical
   \   000001D6   0xE00A             B        ??xQueueGenericSend_38
   \                     ??xQueueGenericSend_39: (+1)
   \   000001D8   0x0020             MOVS     R0,R4
   \   000001DA   0x3024             ADDS     R0,R0,#+36
   \   000001DC   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   000001E0   0x2800             CMP      R0,#+0
   \   000001E2   0xD001             BEQ      ??xQueueGenericSend_40
   \   000001E4   0x.... 0x....      BL       vTaskMissedYield
   \                     ??xQueueGenericSend_40: (+1)
   \   000001E8   0x6CA0             LDR      R0,[R4, #+72]
   \   000001EA   0x1E40             SUBS     R0,R0,#+1
   \   000001EC   0x64A0             STR      R0,[R4, #+72]
   \                     ??xQueueGenericSend_38: (+1)
   \   000001EE   0x6CA0             LDR      R0,[R4, #+72]
   \   000001F0   0x2801             CMP      R0,#+1
   \   000001F2   0xDB02             BLT      ??xQueueGenericSend_41
   \   000001F4   0x6A60             LDR      R0,[R4, #+36]
   \   000001F6   0x2800             CMP      R0,#+0
   \   000001F8   0xD1EE             BNE      ??xQueueGenericSend_39
   \                     ??xQueueGenericSend_41: (+1)
   \   000001FA   0x64A5             STR      R5,[R4, #+72]
   \   000001FC   0x.... 0x....      BL       vPortExitCritical
   \   00000200   0x.... 0x....      BL       vPortEnterCritical
   \   00000204   0xE726             B        ??xQueueGenericSend_12
    796          			}
    797          		}
    798          		else
    799          		{
    800          			/* The timeout has expired. */
    801          			prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericSend_26: (+1)
   \   00000206   0x.... 0x....      BL       vPortEnterCritical
   \   0000020A   0xE00A             B        ??xQueueGenericSend_42
   \                     ??xQueueGenericSend_43: (+1)
   \   0000020C   0x0020             MOVS     R0,R4
   \   0000020E   0x3024             ADDS     R0,R0,#+36
   \   00000210   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000214   0x2800             CMP      R0,#+0
   \   00000216   0xD001             BEQ      ??xQueueGenericSend_44
   \   00000218   0x.... 0x....      BL       vTaskMissedYield
   \                     ??xQueueGenericSend_44: (+1)
   \   0000021C   0x6CA0             LDR      R0,[R4, #+72]
   \   0000021E   0x1E40             SUBS     R0,R0,#+1
   \   00000220   0x64A0             STR      R0,[R4, #+72]
   \                     ??xQueueGenericSend_42: (+1)
   \   00000222   0x6CA0             LDR      R0,[R4, #+72]
   \   00000224   0x2801             CMP      R0,#+1
   \   00000226   0xDB02             BLT      ??xQueueGenericSend_45
   \   00000228   0x6A60             LDR      R0,[R4, #+36]
   \   0000022A   0x2800             CMP      R0,#+0
   \   0000022C   0xD1EE             BNE      ??xQueueGenericSend_43
   \                     ??xQueueGenericSend_45: (+1)
   \   0000022E   0x64A5             STR      R5,[R4, #+72]
   \   00000230   0x.... 0x....      BL       vPortExitCritical
   \   00000234   0x.... 0x....      BL       vPortEnterCritical
   \   00000238   0xE00A             B        ??xQueueGenericSend_46
   \                     ??xQueueGenericSend_47: (+1)
   \   0000023A   0x0020             MOVS     R0,R4
   \   0000023C   0x3010             ADDS     R0,R0,#+16
   \   0000023E   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000242   0x2800             CMP      R0,#+0
   \   00000244   0xD001             BEQ      ??xQueueGenericSend_48
   \   00000246   0x.... 0x....      BL       vTaskMissedYield
   \                     ??xQueueGenericSend_48: (+1)
   \   0000024A   0x6C60             LDR      R0,[R4, #+68]
   \   0000024C   0x1E40             SUBS     R0,R0,#+1
   \   0000024E   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueGenericSend_46: (+1)
   \   00000250   0x6C60             LDR      R0,[R4, #+68]
   \   00000252   0x2801             CMP      R0,#+1
   \   00000254   0xDB02             BLT      ??xQueueGenericSend_49
   \   00000256   0x6920             LDR      R0,[R4, #+16]
   \   00000258   0x2800             CMP      R0,#+0
   \   0000025A   0xD1EE             BNE      ??xQueueGenericSend_47
   \                     ??xQueueGenericSend_49: (+1)
   \   0000025C   0x6465             STR      R5,[R4, #+68]
   \   0000025E   0x.... 0x....      BL       vPortExitCritical
    802          			( void ) xTaskResumeAll();
   \   00000262   0x.... 0x....      BL       xTaskResumeAll
    803          
    804          			/* Return to the original privilege level before exiting the
    805          			function. */
    806          			traceQUEUE_SEND_FAILED( pxQueue );
    807          			return errQUEUE_FULL;
   \                     ??xQueueGenericSend_22: (+1)
   \   00000266   0x2000             MOVS     R0,#+0
   \                     ??xQueueGenericSend_20: (+1)
   \   00000268   0xB005             ADD      SP,SP,#+20
   \   0000026A   0xBDF0             POP      {R4-R7,PC}       ;; return
    808          		}
    809          	}
    810          }
    811          /*-----------------------------------------------------------*/
    812          
    813          #if ( configUSE_ALTERNATIVE_API == 1 )
    814          
    815          	BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition )
    816          	{
    817          	BaseType_t xEntryTimeSet = pdFALSE;
    818          	TimeOut_t xTimeOut;
    819          	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    820          
    821          		configASSERT( pxQueue );
    822          		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    823          
    824          		for( ;; )
    825          		{
    826          			taskENTER_CRITICAL();
    827          			{
    828          				/* Is there room on the queue now?  To be running we must be
    829          				the highest priority task wanting to access the queue. */
    830          				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    831          				{
    832          					traceQUEUE_SEND( pxQueue );
    833          					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    834          
    835          					/* If there was a task waiting for data to arrive on the
    836          					queue then unblock it now. */
    837          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    838          					{
    839          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    840          						{
    841          							/* The unblocked task has a priority higher than
    842          							our own so yield immediately. */
    843          							portYIELD_WITHIN_API();
    844          						}
    845          						else
    846          						{
    847          							mtCOVERAGE_TEST_MARKER();
    848          						}
    849          					}
    850          					else
    851          					{
    852          						mtCOVERAGE_TEST_MARKER();
    853          					}
    854          
    855          					taskEXIT_CRITICAL();
    856          					return pdPASS;
    857          				}
    858          				else
    859          				{
    860          					if( xTicksToWait == ( TickType_t ) 0 )
    861          					{
    862          						taskEXIT_CRITICAL();
    863          						return errQUEUE_FULL;
    864          					}
    865          					else if( xEntryTimeSet == pdFALSE )
    866          					{
    867          						vTaskSetTimeOutState( &xTimeOut );
    868          						xEntryTimeSet = pdTRUE;
    869          					}
    870          				}
    871          			}
    872          			taskEXIT_CRITICAL();
    873          
    874          			taskENTER_CRITICAL();
    875          			{
    876          				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    877          				{
    878          					if( prvIsQueueFull( pxQueue ) != pdFALSE )
    879          					{
    880          						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
    881          						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    882          						portYIELD_WITHIN_API();
    883          					}
    884          					else
    885          					{
    886          						mtCOVERAGE_TEST_MARKER();
    887          					}
    888          				}
    889          				else
    890          				{
    891          					taskEXIT_CRITICAL();
    892          					traceQUEUE_SEND_FAILED( pxQueue );
    893          					return errQUEUE_FULL;
    894          				}
    895          			}
    896          			taskEXIT_CRITICAL();
    897          		}
    898          	}
    899          
    900          #endif /* configUSE_ALTERNATIVE_API */
    901          /*-----------------------------------------------------------*/
    902          
    903          #if ( configUSE_ALTERNATIVE_API == 1 )
    904          
    905          	BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking )
    906          	{
    907          	BaseType_t xEntryTimeSet = pdFALSE;
    908          	TimeOut_t xTimeOut;
    909          	int8_t *pcOriginalReadPosition;
    910          	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
    911          
    912          		configASSERT( pxQueue );
    913          		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
    914          
    915          		for( ;; )
    916          		{
    917          			taskENTER_CRITICAL();
    918          			{
    919          				if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    920          				{
    921          					/* Remember our read position in case we are just peeking. */
    922          					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    923          
    924          					prvCopyDataFromQueue( pxQueue, pvBuffer );
    925          
    926          					if( xJustPeeking == pdFALSE )
    927          					{
    928          						traceQUEUE_RECEIVE( pxQueue );
    929          
    930          						/* Data is actually being removed (not just peeked). */
    931          						--( pxQueue->uxMessagesWaiting );
    932          
    933          						#if ( configUSE_MUTEXES == 1 )
    934          						{
    935          							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    936          							{
    937          								/* Record the information required to implement
    938          								priority inheritance should it become necessary. */
    939          								pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle();
    940          							}
    941          							else
    942          							{
    943          								mtCOVERAGE_TEST_MARKER();
    944          							}
    945          						}
    946          						#endif
    947          
    948          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    949          						{
    950          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    951          							{
    952          								portYIELD_WITHIN_API();
    953          							}
    954          							else
    955          							{
    956          								mtCOVERAGE_TEST_MARKER();
    957          							}
    958          						}
    959          					}
    960          					else
    961          					{
    962          						traceQUEUE_PEEK( pxQueue );
    963          
    964          						/* The data is not being removed, so reset our read
    965          						pointer. */
    966          						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    967          
    968          						/* The data is being left in the queue, so see if there are
    969          						any other tasks waiting for the data. */
    970          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    971          						{
    972          							/* Tasks that are removed from the event list will get added to
    973          							the pending ready list as the scheduler is still suspended. */
    974          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    975          							{
    976          								/* The task waiting has a higher priority than this task. */
    977          								portYIELD_WITHIN_API();
    978          							}
    979          							else
    980          							{
    981          								mtCOVERAGE_TEST_MARKER();
    982          							}
    983          						}
    984          						else
    985          						{
    986          							mtCOVERAGE_TEST_MARKER();
    987          						}
    988          					}
    989          
    990          					taskEXIT_CRITICAL();
    991          					return pdPASS;
    992          				}
    993          				else
    994          				{
    995          					if( xTicksToWait == ( TickType_t ) 0 )
    996          					{
    997          						taskEXIT_CRITICAL();
    998          						traceQUEUE_RECEIVE_FAILED( pxQueue );
    999          						return errQUEUE_EMPTY;
   1000          					}
   1001          					else if( xEntryTimeSet == pdFALSE )
   1002          					{
   1003          						vTaskSetTimeOutState( &xTimeOut );
   1004          						xEntryTimeSet = pdTRUE;
   1005          					}
   1006          				}
   1007          			}
   1008          			taskEXIT_CRITICAL();
   1009          
   1010          			taskENTER_CRITICAL();
   1011          			{
   1012          				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1013          				{
   1014          					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1015          					{
   1016          						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
   1017          
   1018          						#if ( configUSE_MUTEXES == 1 )
   1019          						{
   1020          							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1021          							{
   1022          								taskENTER_CRITICAL();
   1023          								{
   1024          									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   1025          								}
   1026          								taskEXIT_CRITICAL();
   1027          							}
   1028          							else
   1029          							{
   1030          								mtCOVERAGE_TEST_MARKER();
   1031          							}
   1032          						}
   1033          						#endif
   1034          
   1035          						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1036          						portYIELD_WITHIN_API();
   1037          					}
   1038          					else
   1039          					{
   1040          						mtCOVERAGE_TEST_MARKER();
   1041          					}
   1042          				}
   1043          				else
   1044          				{
   1045          					taskEXIT_CRITICAL();
   1046          					traceQUEUE_RECEIVE_FAILED( pxQueue );
   1047          					return errQUEUE_EMPTY;
   1048          				}
   1049          			}
   1050          			taskEXIT_CRITICAL();
   1051          		}
   1052          	}
   1053          
   1054          
   1055          #endif /* configUSE_ALTERNATIVE_API */
   1056          /*-----------------------------------------------------------*/
   1057          

   \                                 In section .text, align 4, keep-with-next
   1058          BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
   1059          {
   \                     xQueueGenericSendFromISR: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0016             MOVS     R6,R2
   \   00000006   0x001D             MOVS     R5,R3
   1060          BaseType_t xReturn;
   1061          UBaseType_t uxSavedInterruptStatus;
   1062          Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   1063          
   1064          	configASSERT( pxQueue );
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE      ??xQueueGenericSendFromISR_0
   \   0000000C   0xB672             cpsid i
   \                     ??xQueueGenericSendFromISR_1: (+1)
   \   0000000E   0xE7FE             B        ??xQueueGenericSendFromISR_1
   1065          	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueueGenericSendFromISR_0: (+1)
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD102             BNE      ??xQueueGenericSendFromISR_2
   \   00000014   0x6C20             LDR      R0,[R4, #+64]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD120             BNE      ??xQueueGenericSendFromISR_3
   1066          	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   \                     ??xQueueGenericSendFromISR_2: (+1)
   \   0000001A   0x2D02             CMP      R5,#+2
   \   0000001C   0xD102             BNE      ??xQueueGenericSendFromISR_4
   \   0000001E   0x6BE0             LDR      R0,[R4, #+60]
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD11D             BNE      ??xQueueGenericSendFromISR_5
   1067          
   1068          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1069          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1070          	above the maximum system call priority are kept permanently enabled, even
   1071          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1072          	FreeRTOS API functions.  If configASSERT() is defined in freertos_cfg.h
   1073          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1074          	failure if a FreeRTOS API function is called from an interrupt that has been
   1075          	assigned a priority above the configured maximum system call priority.
   1076          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1077          	that have been assigned a priority at or (logically) below the maximum
   1078          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1079          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1080          	More information (albeit Cortex-M specific) is provided on the following
   1081          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1082          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1083          
   1084          	/* Similar to xQueueGenericSend, except without blocking if there is no room
   1085          	in the queue.  Also don't directly wake a task that was blocked on a queue
   1086          	read, instead return a flag to say whether a context switch is required or
   1087          	not (i.e. has a task with a higher priority than us been woken by this
   1088          	post). */
   1089          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??xQueueGenericSendFromISR_4: (+1)
   \   00000024   0x.... 0x....      BL       ulSetInterruptMaskFromISR
   \   00000028   0x0007             MOVS     R7,R0
   1090          	{
   1091          		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   \   0000002A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000002C   0x6BE1             LDR      R1,[R4, #+60]
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD301             BCC      ??xQueueGenericSendFromISR_6
   \   00000032   0x2D02             CMP      R5,#+2
   \   00000034   0xD147             BNE      ??xQueueGenericSendFromISR_7
   1092          		{
   1093          			traceQUEUE_SEND_FROM_ISR( pxQueue );
   1094          
   1095          			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
   1096          			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
   1097          			in a task disinheriting a priority and prvCopyDataToQueue() can be
   1098          			called here even though the disinherit function does not check if
   1099          			the scheduler is suspended before accessing the ready lists. */
   1100          			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   \                     ??xQueueGenericSendFromISR_6: (+1)
   \   00000036   0x6C22             LDR      R2,[R4, #+64]
   \   00000038   0x2A00             CMP      R2,#+0
   \   0000003A   0xD029             BEQ      ??xQueueGenericSendFromISR_8
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0x9900             LDR      R1,[SP, #+0]
   \   00000040   0xD110             BNE      ??xQueueGenericSendFromISR_9
   \   00000042   0x68A0             LDR      R0,[R4, #+8]
   \   00000044   0x.... 0x....      BL       __aeabi_memcpy
   \   00000048   0x68A0             LDR      R0,[R4, #+8]
   \   0000004A   0x6C21             LDR      R1,[R4, #+64]
   \   0000004C   0x1840             ADDS     R0,R0,R1
   \   0000004E   0x60A0             STR      R0,[R4, #+8]
   \   00000050   0x6861             LDR      R1,[R4, #+4]
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD31C             BCC      ??xQueueGenericSendFromISR_8
   \   00000056   0x6820             LDR      R0,[R4, #+0]
   \   00000058   0x60A0             STR      R0,[R4, #+8]
   \   0000005A   0xE019             B        ??xQueueGenericSendFromISR_8
   \                     ??xQueueGenericSendFromISR_3: (+1)
   \   0000005C   0xB672             cpsid i
   \                     ??xQueueGenericSendFromISR_10: (+1)
   \   0000005E   0xE7FE             B        ??xQueueGenericSendFromISR_10
   \                     ??xQueueGenericSendFromISR_5: (+1)
   \   00000060   0xB672             cpsid i
   \                     ??xQueueGenericSendFromISR_11: (+1)
   \   00000062   0xE7FE             B        ??xQueueGenericSendFromISR_11
   \                     ??xQueueGenericSendFromISR_9: (+1)
   \   00000064   0x68E0             LDR      R0,[R4, #+12]
   \   00000066   0x.... 0x....      BL       __aeabi_memcpy
   \   0000006A   0x68E0             LDR      R0,[R4, #+12]
   \   0000006C   0x6C21             LDR      R1,[R4, #+64]
   \   0000006E   0x1A40             SUBS     R0,R0,R1
   \   00000070   0x60E0             STR      R0,[R4, #+12]
   \   00000072   0x6821             LDR      R1,[R4, #+0]
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD203             BCS      ??xQueueGenericSendFromISR_12
   \   00000078   0x6860             LDR      R0,[R4, #+4]
   \   0000007A   0x6C21             LDR      R1,[R4, #+64]
   \   0000007C   0x1A40             SUBS     R0,R0,R1
   \   0000007E   0x60E0             STR      R0,[R4, #+12]
   \                     ??xQueueGenericSendFromISR_12: (+1)
   \   00000080   0x2D02             CMP      R5,#+2
   \   00000082   0xD105             BNE      ??xQueueGenericSendFromISR_8
   \   00000084   0x6BA0             LDR      R0,[R4, #+56]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD002             BEQ      ??xQueueGenericSendFromISR_8
   \   0000008A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000008C   0x1E40             SUBS     R0,R0,#+1
   \   0000008E   0x63A0             STR      R0,[R4, #+56]
   \                     ??xQueueGenericSendFromISR_8: (+1)
   \   00000090   0x6BA0             LDR      R0,[R4, #+56]
   \   00000092   0x1C40             ADDS     R0,R0,#+1
   \   00000094   0x63A0             STR      R0,[R4, #+56]
   1101          
   1102          			/* The event list is not altered if the queue is locked.  This will
   1103          			be done when the queue is unlocked later. */
   1104          			if( pxQueue->xTxLock == queueUNLOCKED )
   \   00000096   0x6CA0             LDR      R0,[R4, #+72]
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD10D             BNE      ??xQueueGenericSendFromISR_13
   1105          			{
   1106          				#if ( configUSE_QUEUE_SETS == 1 )
   1107          				{
   1108          					if( pxQueue->pxQueueSetContainer != NULL )
   1109          					{
   1110          						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
   1111          						{
   1112          							/* The queue is a member of a queue set, and posting
   1113          							to the queue set caused a higher priority task to
   1114          							unblock.  A context switch is required. */
   1115          							if( pxHigherPriorityTaskWoken != NULL )
   1116          							{
   1117          								*pxHigherPriorityTaskWoken = pdTRUE;
   1118          							}
   1119          							else
   1120          							{
   1121          								mtCOVERAGE_TEST_MARKER();
   1122          							}
   1123          						}
   1124          						else
   1125          						{
   1126          							mtCOVERAGE_TEST_MARKER();
   1127          						}
   1128          					}
   1129          					else
   1130          					{
   1131          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1132          						{
   1133          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1134          							{
   1135          								/* The task waiting has a higher priority so
   1136          								record that a context switch is required. */
   1137          								if( pxHigherPriorityTaskWoken != NULL )
   1138          								{
   1139          									*pxHigherPriorityTaskWoken = pdTRUE;
   1140          								}
   1141          								else
   1142          								{
   1143          									mtCOVERAGE_TEST_MARKER();
   1144          								}
   1145          							}
   1146          							else
   1147          							{
   1148          								mtCOVERAGE_TEST_MARKER();
   1149          							}
   1150          						}
   1151          						else
   1152          						{
   1153          							mtCOVERAGE_TEST_MARKER();
   1154          						}
   1155          					}
   1156          				}
   1157          				#else /* configUSE_QUEUE_SETS */
   1158          				{
   1159          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   \   000000A0   0x6A60             LDR      R0,[R4, #+36]
   \   000000A2   0x2800             CMP      R0,#+0
   \   000000A4   0xD00D             BEQ      ??xQueueGenericSendFromISR_14
   1160          					{
   1161          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \   000000A6   0x3424             ADDS     R4,R4,#+36
   \   000000A8   0x0020             MOVS     R0,R4
   \   000000AA   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD007             BEQ      ??xQueueGenericSendFromISR_14
   1162          						{
   1163          							/* The task waiting has a higher priority so record that a
   1164          							context	switch is required. */
   1165          							if( pxHigherPriorityTaskWoken != NULL )
   \   000000B2   0x2E00             CMP      R6,#+0
   \   000000B4   0xD005             BEQ      ??xQueueGenericSendFromISR_14
   1166          							{
   1167          								*pxHigherPriorityTaskWoken = pdTRUE;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x6030             STR      R0,[R6, #+0]
   \   000000BA   0xE002             B        ??xQueueGenericSendFromISR_14
   1168          							}
   1169          							else
   1170          							{
   1171          								mtCOVERAGE_TEST_MARKER();
   1172          							}
   1173          						}
   1174          						else
   1175          						{
   1176          							mtCOVERAGE_TEST_MARKER();
   1177          						}
   1178          					}
   1179          					else
   1180          					{
   1181          						mtCOVERAGE_TEST_MARKER();
   1182          					}
   1183          				}
   1184          				#endif /* configUSE_QUEUE_SETS */
   1185          			}
   1186          			else
   1187          			{
   1188          				/* Increment the lock count so the task that unlocks the queue
   1189          				knows that data was posted while it was locked. */
   1190          				++( pxQueue->xTxLock );
   \                     ??xQueueGenericSendFromISR_13: (+1)
   \   000000BC   0x6CA0             LDR      R0,[R4, #+72]
   \   000000BE   0x1C40             ADDS     R0,R0,#+1
   \   000000C0   0x64A0             STR      R0,[R4, #+72]
   1191          			}
   1192          
   1193          			xReturn = pdPASS;
   \                     ??xQueueGenericSendFromISR_14: (+1)
   \   000000C2   0x2401             MOVS     R4,#+1
   \   000000C4   0xE000             B        ??xQueueGenericSendFromISR_15
   1194          		}
   1195          		else
   1196          		{
   1197          			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   1198          			xReturn = errQUEUE_FULL;
   \                     ??xQueueGenericSendFromISR_7: (+1)
   \   000000C6   0x2400             MOVS     R4,#+0
   1199          		}
   1200          	}
   1201          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueGenericSendFromISR_15: (+1)
   \   000000C8   0x0038             MOVS     R0,R7
   \   000000CA   0x.... 0x....      BL       vClearInterruptMaskFromISR
   1202          
   1203          	return xReturn;
   \   000000CE   0x0020             MOVS     R0,R4
   \   000000D0   0xB001             ADD      SP,SP,#+4
   \   000000D2   0xBDF0             POP      {R4-R7,PC}       ;; return
   1204          }
   1205          /*-----------------------------------------------------------*/
   1206          

   \                                 In section .text, align 4, keep-with-next
   1207          BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
   1208          {
   \                     xQueueGiveFromISR: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   1209          BaseType_t xReturn;
   1210          UBaseType_t uxSavedInterruptStatus;
   1211          Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   1212          
   1213          	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
   1214          	item size is 0.  Don't directly wake a task that was blocked on a queue
   1215          	read, instead return a flag to say whether a context switch is required or
   1216          	not (i.e. has a task with a higher priority than us been woken by this
   1217          	post). */
   1218          
   1219          	configASSERT( pxQueue );
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD101             BNE      ??xQueueGiveFromISR_0
   \   0000000A   0xB672             cpsid i
   \                     ??xQueueGiveFromISR_1: (+1)
   \   0000000C   0xE7FE             B        ??xQueueGiveFromISR_1
   1220          
   1221          	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
   1222          	if the item size is not 0. */
   1223          	configASSERT( pxQueue->uxItemSize == 0 );
   \                     ??xQueueGiveFromISR_0: (+1)
   \   0000000E   0x6C28             LDR      R0,[R5, #+64]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD001             BEQ      ??xQueueGiveFromISR_2
   \   00000014   0xB672             cpsid i
   \                     ??xQueueGiveFromISR_3: (+1)
   \   00000016   0xE7FE             B        ??xQueueGiveFromISR_3
   1224          
   1225          	/* Normally a mutex would not be given from an interrupt, and doing so is
   1226          	definitely wrong if there is a mutex holder as priority inheritance makes no
   1227          	sense for an interrupts, only tasks. */
   1228          	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
   \                     ??xQueueGiveFromISR_2: (+1)
   \   00000018   0x6828             LDR      R0,[R5, #+0]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD102             BNE      ??xQueueGiveFromISR_4
   \   0000001E   0x6868             LDR      R0,[R5, #+4]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD11C             BNE      ??xQueueGiveFromISR_5
   1229          
   1230          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1231          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1232          	above the maximum system call priority are kept permanently enabled, even
   1233          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1234          	FreeRTOS API functions.  If configASSERT() is defined in freertos_cfg.h
   1235          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1236          	failure if a FreeRTOS API function is called from an interrupt that has been
   1237          	assigned a priority above the configured maximum system call priority.
   1238          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1239          	that have been assigned a priority at or (logically) below the maximum
   1240          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1241          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1242          	More information (albeit Cortex-M specific) is provided on the following
   1243          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1244          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1245          
   1246          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??xQueueGiveFromISR_4: (+1)
   \   00000024   0x.... 0x....      BL       ulSetInterruptMaskFromISR
   \   00000028   0x0006             MOVS     R6,R0
   1247          	{
   1248          		/* When the queue is used to implement a semaphore no data is ever
   1249          		moved through the queue but it is still valid to see if the queue 'has
   1250          		space'. */
   1251          		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   \   0000002A   0x6BA8             LDR      R0,[R5, #+56]
   \   0000002C   0x6BE9             LDR      R1,[R5, #+60]
   \   0000002E   0x4288             CMP      R0,R1
   \   00000030   0xD21C             BCS      ??xQueueGiveFromISR_6
   1252          		{
   1253          			traceQUEUE_SEND_FROM_ISR( pxQueue );
   1254          
   1255          			/* A task can only have an inherited priority if it is a mutex
   1256          			holder - and if there is a mutex holder then the mutex cannot be
   1257          			given from an ISR.  As this is the ISR version of the function it
   1258          			can be assumed there is no mutex holder and no need to determine if
   1259          			priority disinheritance is needed.  Simply increase the count of
   1260          			messages (semaphores) available. */
   1261          			++( pxQueue->uxMessagesWaiting );
   \   00000032   0x6BA8             LDR      R0,[R5, #+56]
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0x63A8             STR      R0,[R5, #+56]
   1262          
   1263          			/* The event list is not altered if the queue is locked.  This will
   1264          			be done when the queue is unlocked later. */
   1265          			if( pxQueue->xTxLock == queueUNLOCKED )
   \   00000038   0x6CA8             LDR      R0,[R5, #+72]
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD10F             BNE      ??xQueueGiveFromISR_7
   1266          			{
   1267          				#if ( configUSE_QUEUE_SETS == 1 )
   1268          				{
   1269          					if( pxQueue->pxQueueSetContainer != NULL )
   1270          					{
   1271          						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
   1272          						{
   1273          							/* The semaphore is a member of a queue set, and
   1274          							posting	to the queue set caused a higher priority
   1275          							task to	unblock.  A context switch is required. */
   1276          							if( pxHigherPriorityTaskWoken != NULL )
   1277          							{
   1278          								*pxHigherPriorityTaskWoken = pdTRUE;
   1279          							}
   1280          							else
   1281          							{
   1282          								mtCOVERAGE_TEST_MARKER();
   1283          							}
   1284          						}
   1285          						else
   1286          						{
   1287          							mtCOVERAGE_TEST_MARKER();
   1288          						}
   1289          					}
   1290          					else
   1291          					{
   1292          						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1293          						{
   1294          							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1295          							{
   1296          								/* The task waiting has a higher priority so
   1297          								record that a context switch is required. */
   1298          								if( pxHigherPriorityTaskWoken != NULL )
   1299          								{
   1300          									*pxHigherPriorityTaskWoken = pdTRUE;
   1301          								}
   1302          								else
   1303          								{
   1304          									mtCOVERAGE_TEST_MARKER();
   1305          								}
   1306          							}
   1307          							else
   1308          							{
   1309          								mtCOVERAGE_TEST_MARKER();
   1310          							}
   1311          						}
   1312          						else
   1313          						{
   1314          							mtCOVERAGE_TEST_MARKER();
   1315          						}
   1316          					}
   1317          				}
   1318          				#else /* configUSE_QUEUE_SETS */
   1319          				{
   1320          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   \   00000042   0x6A68             LDR      R0,[R5, #+36]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD00F             BEQ      ??xQueueGiveFromISR_8
   1321          					{
   1322          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   \   00000048   0x3524             ADDS     R5,R5,#+36
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD009             BEQ      ??xQueueGiveFromISR_8
   1323          						{
   1324          							/* The task waiting has a higher priority so record that a
   1325          							context	switch is required. */
   1326          							if( pxHigherPriorityTaskWoken != NULL )
   \   00000054   0x2C00             CMP      R4,#+0
   \   00000056   0xD007             BEQ      ??xQueueGiveFromISR_8
   1327          							{
   1328          								*pxHigherPriorityTaskWoken = pdTRUE;
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x6020             STR      R0,[R4, #+0]
   \   0000005C   0xE004             B        ??xQueueGiveFromISR_8
   1329          							}
   1330          							else
   1331          							{
   1332          								mtCOVERAGE_TEST_MARKER();
   1333          							}
   1334          						}
   1335          						else
   1336          						{
   1337          							mtCOVERAGE_TEST_MARKER();
   1338          						}
   1339          					}
   1340          					else
   1341          					{
   1342          						mtCOVERAGE_TEST_MARKER();
   1343          					}
   1344          				}
   1345          				#endif /* configUSE_QUEUE_SETS */
   1346          			}
   \                     ??xQueueGiveFromISR_5: (+1)
   \   0000005E   0xB672             cpsid i
   \                     ??xQueueGiveFromISR_9: (+1)
   \   00000060   0xE7FE             B        ??xQueueGiveFromISR_9
   1347          			else
   1348          			{
   1349          				/* Increment the lock count so the task that unlocks the queue
   1350          				knows that data was posted while it was locked. */
   1351          				++( pxQueue->xTxLock );
   \                     ??xQueueGiveFromISR_7: (+1)
   \   00000062   0x6CA8             LDR      R0,[R5, #+72]
   \   00000064   0x1C40             ADDS     R0,R0,#+1
   \   00000066   0x64A8             STR      R0,[R5, #+72]
   1352          			}
   1353          
   1354          			xReturn = pdPASS;
   \                     ??xQueueGiveFromISR_8: (+1)
   \   00000068   0x2401             MOVS     R4,#+1
   \   0000006A   0xE000             B        ??xQueueGiveFromISR_10
   1355          		}
   1356          		else
   1357          		{
   1358          			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
   1359          			xReturn = errQUEUE_FULL;
   \                     ??xQueueGiveFromISR_6: (+1)
   \   0000006C   0x2400             MOVS     R4,#+0
   1360          		}
   1361          	}
   1362          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueGiveFromISR_10: (+1)
   \   0000006E   0x0030             MOVS     R0,R6
   \   00000070   0x.... 0x....      BL       vClearInterruptMaskFromISR
   1363          
   1364          	return xReturn;
   \   00000074   0x0020             MOVS     R0,R4
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return
   1365          }
   1366          /*-----------------------------------------------------------*/
   1367          

   \                                 In section .text, align 4, keep-with-next
   1368          BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
   1369          {
   \                     xQueueGenericReceive: (+1)
   \   00000000   0xB5FE             PUSH     {R1-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x2700             MOVS     R7,#+0
   1370          BaseType_t xEntryTimeSet = pdFALSE;
   1371          TimeOut_t xTimeOut;
   1372          int8_t *pcOriginalReadPosition;
   1373          Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   1374          
   1375          	configASSERT( pxQueue );
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE      ??xQueueGenericReceive_0
   \   0000000C   0xB672             cpsid i
   \                     ??xQueueGenericReceive_1: (+1)
   \   0000000E   0xE7FE             B        ??xQueueGenericReceive_1
   1376          	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueueGenericReceive_0: (+1)
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD102             BNE      ??xQueueGenericReceive_2
   \   00000014   0x6C20             LDR      R0,[R4, #+64]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD108             BNE      ??xQueueGenericReceive_3
   1377          	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   1378          	{
   1379          		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   \                     ??xQueueGenericReceive_2: (+1)
   \   0000001A   0x.... 0x....      BL       xTaskGetSchedulerState
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD11C             BNE      ??xQueueGenericReceive_4
   \   00000022   0x9803             LDR      R0,[SP, #+12]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD019             BEQ      ??xQueueGenericReceive_4
   \   00000028   0xB672             cpsid i
   \                     ??xQueueGenericReceive_5: (+1)
   \   0000002A   0xE7FE             B        ??xQueueGenericReceive_5
   1380          	}
   \                     ??xQueueGenericReceive_3: (+1)
   \   0000002C   0xB672             cpsid i
   \                     ??xQueueGenericReceive_6: (+1)
   \   0000002E   0xE7FE             B        ??xQueueGenericReceive_6
   1381          	#endif
   1382          
   1383          	/* This function relaxes the coding standard somewhat to allow return
   1384          	statements within the function itself.  This is done in the interest
   1385          	of execution time efficiency. */
   1386          
   1387          	for( ;; )
   1388          	{
   1389          		taskENTER_CRITICAL();
   1390          		{
   1391          			/* Is there data in the queue now?  To be running the calling task
   1392          			must be	the highest priority task wanting to access the queue. */
   1393          			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   1394          			{
   1395          				/* Remember the read position in case the queue is only being
   1396          				peeked. */
   1397          				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
   1398          
   1399          				prvCopyDataFromQueue( pxQueue, pvBuffer );
   1400          
   1401          				if( xJustPeeking == pdFALSE )
   1402          				{
   1403          					traceQUEUE_RECEIVE( pxQueue );
   1404          
   1405          					/* Actually removing data, not just peeking. */
   1406          					--( pxQueue->uxMessagesWaiting );
   1407          
   1408          					#if ( configUSE_MUTEXES == 1 )
   1409          					{
   1410          						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1411          						{
   1412          							/* Record the information required to implement
   1413          							priority inheritance should it become necessary. */
   1414          							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
   1415          						}
   1416          						else
   1417          						{
   1418          							mtCOVERAGE_TEST_MARKER();
   1419          						}
   1420          					}
   1421          					#endif /* configUSE_MUTEXES */
   1422          
   1423          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1424          					{
   1425          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   1426          						{
   1427          							queueYIELD_IF_USING_PREEMPTION();
   1428          						}
   1429          						else
   1430          						{
   1431          							mtCOVERAGE_TEST_MARKER();
   1432          						}
   1433          					}
   1434          					else
   1435          					{
   1436          						mtCOVERAGE_TEST_MARKER();
   1437          					}
   1438          				}
   1439          				else
   1440          				{
   1441          					traceQUEUE_PEEK( pxQueue );
   1442          
   1443          					/* The data is not being removed, so reset the read
   1444          					pointer. */
   1445          					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
   1446          
   1447          					/* The data is being left in the queue, so see if there are
   1448          					any other tasks waiting for the data. */
   1449          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1450          					{
   1451          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1452          						{
   1453          							/* The task waiting has a higher priority than this task. */
   1454          							queueYIELD_IF_USING_PREEMPTION();
   1455          						}
   1456          						else
   1457          						{
   1458          							mtCOVERAGE_TEST_MARKER();
   1459          						}
   1460          					}
   1461          					else
   1462          					{
   1463          						mtCOVERAGE_TEST_MARKER();
   1464          					}
   1465          				}
   1466          
   1467          				taskEXIT_CRITICAL();
   1468          				return pdPASS;
   1469          			}
   1470          			else
   1471          			{
   1472          				if( xTicksToWait == ( TickType_t ) 0 )
   1473          				{
   1474          					/* The queue was empty and no block time is specified (or
   1475          					the block time has expired) so leave now. */
   1476          					taskEXIT_CRITICAL();
   1477          					traceQUEUE_RECEIVE_FAILED( pxQueue );
   1478          					return errQUEUE_EMPTY;
   1479          				}
   1480          				else if( xEntryTimeSet == pdFALSE )
   1481          				{
   1482          					/* The queue was empty and a block time was specified so
   1483          					configure the timeout structure. */
   1484          					vTaskSetTimeOutState( &xTimeOut );
   1485          					xEntryTimeSet = pdTRUE;
   1486          				}
   1487          				else
   1488          				{
   1489          					/* Entry time was already set. */
   1490          					mtCOVERAGE_TEST_MARKER();
   1491          				}
   1492          			}
   1493          		}
   1494          		taskEXIT_CRITICAL();
   1495          
   1496          		/* Interrupts and other tasks can send to and receive from the queue
   1497          		now the critical section has been exited. */
   1498          
   1499          		vTaskSuspendAll();
   1500          		prvLockQueue( pxQueue );
   1501          
   1502          		/* Update the timeout state to see if it has expired yet. */
   1503          		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   1504          		{
   1505          			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   1506          			{
   1507          				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
   1508          
   1509          				#if ( configUSE_MUTEXES == 1 )
   1510          				{
   1511          					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1512          					{
   1513          						taskENTER_CRITICAL();
   1514          						{
   1515          							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   1516          						}
   1517          						taskEXIT_CRITICAL();
   1518          					}
   1519          					else
   1520          					{
   1521          						mtCOVERAGE_TEST_MARKER();
   1522          					}
   1523          				}
   1524          				#endif
   1525          
   1526          				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   1527          				prvUnlockQueue( pxQueue );
   1528          				if( xTaskResumeAll() == pdFALSE )
   1529          				{
   1530          					portYIELD_WITHIN_API();
   1531          				}
   1532          				else
   1533          				{
   1534          					mtCOVERAGE_TEST_MARKER();
   1535          				}
   1536          			}
   1537          			else
   1538          			{
   \                     ??xQueueGenericReceive_7: (+1)
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0x3010             ADDS     R0,R0,#+16
   \   00000034   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD001             BEQ      ??xQueueGenericReceive_8
   \   0000003C   0x.... 0x....      BL       vTaskMissedYield
   \                     ??xQueueGenericReceive_8: (+1)
   \   00000040   0x6C60             LDR      R0,[R4, #+68]
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueGenericReceive_9: (+1)
   \   00000046   0x6C60             LDR      R0,[R4, #+68]
   \   00000048   0x2801             CMP      R0,#+1
   \   0000004A   0xDB02             BLT      ??xQueueGenericReceive_10
   \   0000004C   0x6920             LDR      R0,[R4, #+16]
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD1EE             BNE      ??xQueueGenericReceive_7
   \                     ??xQueueGenericReceive_10: (+1)
   \   00000052   0x6465             STR      R5,[R4, #+68]
   \   00000054   0x.... 0x....      BL       vPortExitCritical
   1539          				/* Try again. */
   1540          				prvUnlockQueue( pxQueue );
   1541          				( void ) xTaskResumeAll();
   \   00000058   0x.... 0x....      BL       xTaskResumeAll
   \                     ??xQueueGenericReceive_4: (+1)
   \   0000005C   0x.... 0x....      BL       vPortEnterCritical
   \   00000060   0x6BA0             LDR      R0,[R4, #+56]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD030             BEQ      ??xQueueGenericReceive_11
   \   00000066   0x68E0             LDR      R0,[R4, #+12]
   \   00000068   0x0005             MOVS     R5,R0
   \   0000006A   0x6C21             LDR      R1,[R4, #+64]
   \   0000006C   0x2900             CMP      R1,#+0
   \   0000006E   0xD00B             BEQ      ??xQueueGenericReceive_12
   \   00000070   0x1840             ADDS     R0,R0,R1
   \   00000072   0x60E0             STR      R0,[R4, #+12]
   \   00000074   0x6861             LDR      R1,[R4, #+4]
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD301             BCC      ??xQueueGenericReceive_13
   \   0000007A   0x6820             LDR      R0,[R4, #+0]
   \   0000007C   0x60E0             STR      R0,[R4, #+12]
   \                     ??xQueueGenericReceive_13: (+1)
   \   0000007E   0x6C22             LDR      R2,[R4, #+64]
   \   00000080   0x68E1             LDR      R1,[R4, #+12]
   \   00000082   0x9802             LDR      R0,[SP, #+8]
   \   00000084   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??xQueueGenericReceive_12: (+1)
   \   00000088   0x9804             LDR      R0,[SP, #+16]
   \   0000008A   0x2800             CMP      R0,#+0
   \   0000008C   0xD10C             BNE      ??xQueueGenericReceive_14
   \   0000008E   0x6BA0             LDR      R0,[R4, #+56]
   \   00000090   0x1E40             SUBS     R0,R0,#+1
   \   00000092   0x63A0             STR      R0,[R4, #+56]
   \   00000094   0x6920             LDR      R0,[R4, #+16]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD012             BEQ      ??xQueueGenericReceive_15
   \   0000009A   0x3410             ADDS     R4,R4,#+16
   \   0000009C   0x0020             MOVS     R0,R4
   \   0000009E   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   000000A2   0x2801             CMP      R0,#+1
   \   000000A4   0xD10C             BNE      ??xQueueGenericReceive_15
   \   000000A6   0xE009             B        ??xQueueGenericReceive_16
   \                     ??xQueueGenericReceive_14: (+1)
   \   000000A8   0x60E5             STR      R5,[R4, #+12]
   \   000000AA   0x6A60             LDR      R0,[R4, #+36]
   \   000000AC   0x2800             CMP      R0,#+0
   \   000000AE   0xD007             BEQ      ??xQueueGenericReceive_15
   \   000000B0   0x3424             ADDS     R4,R4,#+36
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD001             BEQ      ??xQueueGenericReceive_15
   \                     ??xQueueGenericReceive_16: (+1)
   \   000000BC   0x.... 0x....      BL       vPortYield
   \                     ??xQueueGenericReceive_15: (+1)
   \   000000C0   0x.... 0x....      BL       vPortExitCritical
   \   000000C4   0x2001             MOVS     R0,#+1
   \   000000C6   0xE0B5             B        ??xQueueGenericReceive_17
   \                     ??xQueueGenericReceive_11: (+1)
   \   000000C8   0x9803             LDR      R0,[SP, #+12]
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD102             BNE      ??xQueueGenericReceive_18
   \   000000CE   0x.... 0x....      BL       vPortExitCritical
   \   000000D2   0xE0AE             B        ??xQueueGenericReceive_19
   \                     ??xQueueGenericReceive_18: (+1)
   \   000000D4   0x2F00             CMP      R7,#+0
   \   000000D6   0xD103             BNE      ??xQueueGenericReceive_20
   \   000000D8   0x4668             MOV      R0,SP
   \   000000DA   0x.... 0x....      BL       vTaskSetTimeOutState
   \   000000DE   0x2701             MOVS     R7,#+1
   \                     ??xQueueGenericReceive_20: (+1)
   \   000000E0   0x.... 0x....      BL       vPortExitCritical
   \   000000E4   0x.... 0x....      BL       vTaskSuspendAll
   \   000000E8   0x.... 0x....      BL       vPortEnterCritical
   \   000000EC   0x2500             MOVS     R5,#+0
   \   000000EE   0x43ED             MVNS     R5,R5            ;; #-1
   \   000000F0   0x6C60             LDR      R0,[R4, #+68]
   \   000000F2   0x42A8             CMP      R0,R5
   \   000000F4   0xD101             BNE      ??xQueueGenericReceive_21
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueGenericReceive_21: (+1)
   \   000000FA   0x6CA0             LDR      R0,[R4, #+72]
   \   000000FC   0x42A8             CMP      R0,R5
   \   000000FE   0xD101             BNE      ??xQueueGenericReceive_22
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x64A0             STR      R0,[R4, #+72]
   \                     ??xQueueGenericReceive_22: (+1)
   \   00000104   0x.... 0x....      BL       vPortExitCritical
   \   00000108   0xA903             ADD      R1,SP,#+12
   \   0000010A   0x4668             MOV      R0,SP
   \   0000010C   0x.... 0x....      BL       xTaskCheckForTimeOut
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD15E             BNE      ??xQueueGenericReceive_23
   \   00000114   0x.... 0x....      BL       vPortEnterCritical
   \   00000118   0x6BA0             LDR      R0,[R4, #+56]
   \   0000011A   0x1E46             SUBS     R6,R0,#+1
   \   0000011C   0x41B6             SBCS     R6,R6,R6
   \   0000011E   0x0FF6             LSRS     R6,R6,#+31
   \   00000120   0x.... 0x....      BL       vPortExitCritical
   \   00000124   0x2E00             CMP      R6,#+0
   \   00000126   0xD03A             BEQ      ??xQueueGenericReceive_24
   \   00000128   0x9903             LDR      R1,[SP, #+12]
   \   0000012A   0x0020             MOVS     R0,R4
   \   0000012C   0x3024             ADDS     R0,R0,#+36
   \   0000012E   0x.... 0x....      BL       vTaskPlaceOnEventList
   \   00000132   0x.... 0x....      BL       vPortEnterCritical
   \   00000136   0xE00A             B        ??xQueueGenericReceive_25
   \                     ??xQueueGenericReceive_26: (+1)
   \   00000138   0x0020             MOVS     R0,R4
   \   0000013A   0x3024             ADDS     R0,R0,#+36
   \   0000013C   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD001             BEQ      ??xQueueGenericReceive_27
   \   00000144   0x.... 0x....      BL       vTaskMissedYield
   \                     ??xQueueGenericReceive_27: (+1)
   \   00000148   0x6CA0             LDR      R0,[R4, #+72]
   \   0000014A   0x1E40             SUBS     R0,R0,#+1
   \   0000014C   0x64A0             STR      R0,[R4, #+72]
   \                     ??xQueueGenericReceive_25: (+1)
   \   0000014E   0x6CA0             LDR      R0,[R4, #+72]
   \   00000150   0x2801             CMP      R0,#+1
   \   00000152   0xDB02             BLT      ??xQueueGenericReceive_28
   \   00000154   0x6A60             LDR      R0,[R4, #+36]
   \   00000156   0x2800             CMP      R0,#+0
   \   00000158   0xD1EE             BNE      ??xQueueGenericReceive_26
   \                     ??xQueueGenericReceive_28: (+1)
   \   0000015A   0x64A5             STR      R5,[R4, #+72]
   \   0000015C   0x.... 0x....      BL       vPortExitCritical
   \   00000160   0x.... 0x....      BL       vPortEnterCritical
   \   00000164   0xE00A             B        ??xQueueGenericReceive_29
   \                     ??xQueueGenericReceive_30: (+1)
   \   00000166   0x0020             MOVS     R0,R4
   \   00000168   0x3010             ADDS     R0,R0,#+16
   \   0000016A   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   0000016E   0x2800             CMP      R0,#+0
   \   00000170   0xD001             BEQ      ??xQueueGenericReceive_31
   \   00000172   0x.... 0x....      BL       vTaskMissedYield
   \                     ??xQueueGenericReceive_31: (+1)
   \   00000176   0x6C60             LDR      R0,[R4, #+68]
   \   00000178   0x1E40             SUBS     R0,R0,#+1
   \   0000017A   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueGenericReceive_29: (+1)
   \   0000017C   0x6C60             LDR      R0,[R4, #+68]
   \   0000017E   0x2801             CMP      R0,#+1
   \   00000180   0xDB02             BLT      ??xQueueGenericReceive_32
   \   00000182   0x6920             LDR      R0,[R4, #+16]
   \   00000184   0x2800             CMP      R0,#+0
   \   00000186   0xD1EE             BNE      ??xQueueGenericReceive_30
   \                     ??xQueueGenericReceive_32: (+1)
   \   00000188   0x6465             STR      R5,[R4, #+68]
   \   0000018A   0x.... 0x....      BL       vPortExitCritical
   \   0000018E   0x.... 0x....      BL       xTaskResumeAll
   \   00000192   0x2800             CMP      R0,#+0
   \   00000194   0xD000             BEQ      .+4
   \   00000196   0xE761             B        ??xQueueGenericReceive_4
   \   00000198   0x.... 0x....      BL       vPortYield
   \   0000019C   0xE75E             B        ??xQueueGenericReceive_4
   \                     ??xQueueGenericReceive_24: (+1)
   \   0000019E   0x.... 0x....      BL       vPortEnterCritical
   \   000001A2   0xE00A             B        ??xQueueGenericReceive_33
   \                     ??xQueueGenericReceive_34: (+1)
   \   000001A4   0x0020             MOVS     R0,R4
   \   000001A6   0x3024             ADDS     R0,R0,#+36
   \   000001A8   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   000001AC   0x2800             CMP      R0,#+0
   \   000001AE   0xD001             BEQ      ??xQueueGenericReceive_35
   \   000001B0   0x.... 0x....      BL       vTaskMissedYield
   \                     ??xQueueGenericReceive_35: (+1)
   \   000001B4   0x6CA0             LDR      R0,[R4, #+72]
   \   000001B6   0x1E40             SUBS     R0,R0,#+1
   \   000001B8   0x64A0             STR      R0,[R4, #+72]
   \                     ??xQueueGenericReceive_33: (+1)
   \   000001BA   0x6CA0             LDR      R0,[R4, #+72]
   \   000001BC   0x2801             CMP      R0,#+1
   \   000001BE   0xDB02             BLT      ??xQueueGenericReceive_36
   \   000001C0   0x6A60             LDR      R0,[R4, #+36]
   \   000001C2   0x2800             CMP      R0,#+0
   \   000001C4   0xD1EE             BNE      ??xQueueGenericReceive_34
   \                     ??xQueueGenericReceive_36: (+1)
   \   000001C6   0x64A5             STR      R5,[R4, #+72]
   \   000001C8   0x.... 0x....      BL       vPortExitCritical
   \   000001CC   0x.... 0x....      BL       vPortEnterCritical
   \   000001D0   0xE739             B        ??xQueueGenericReceive_9
   1542          			}
   1543          		}
   1544          		else
   1545          		{
   1546          			prvUnlockQueue( pxQueue );
   \                     ??xQueueGenericReceive_23: (+1)
   \   000001D2   0x.... 0x....      BL       vPortEnterCritical
   \   000001D6   0xE00A             B        ??xQueueGenericReceive_37
   \                     ??xQueueGenericReceive_38: (+1)
   \   000001D8   0x0020             MOVS     R0,R4
   \   000001DA   0x3024             ADDS     R0,R0,#+36
   \   000001DC   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   000001E0   0x2800             CMP      R0,#+0
   \   000001E2   0xD001             BEQ      ??xQueueGenericReceive_39
   \   000001E4   0x.... 0x....      BL       vTaskMissedYield
   \                     ??xQueueGenericReceive_39: (+1)
   \   000001E8   0x6CA0             LDR      R0,[R4, #+72]
   \   000001EA   0x1E40             SUBS     R0,R0,#+1
   \   000001EC   0x64A0             STR      R0,[R4, #+72]
   \                     ??xQueueGenericReceive_37: (+1)
   \   000001EE   0x6CA0             LDR      R0,[R4, #+72]
   \   000001F0   0x2801             CMP      R0,#+1
   \   000001F2   0xDB02             BLT      ??xQueueGenericReceive_40
   \   000001F4   0x6A60             LDR      R0,[R4, #+36]
   \   000001F6   0x2800             CMP      R0,#+0
   \   000001F8   0xD1EE             BNE      ??xQueueGenericReceive_38
   \                     ??xQueueGenericReceive_40: (+1)
   \   000001FA   0x64A5             STR      R5,[R4, #+72]
   \   000001FC   0x.... 0x....      BL       vPortExitCritical
   \   00000200   0x.... 0x....      BL       vPortEnterCritical
   \   00000204   0xE00A             B        ??xQueueGenericReceive_41
   \                     ??xQueueGenericReceive_42: (+1)
   \   00000206   0x0020             MOVS     R0,R4
   \   00000208   0x3010             ADDS     R0,R0,#+16
   \   0000020A   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   0000020E   0x2800             CMP      R0,#+0
   \   00000210   0xD001             BEQ      ??xQueueGenericReceive_43
   \   00000212   0x.... 0x....      BL       vTaskMissedYield
   \                     ??xQueueGenericReceive_43: (+1)
   \   00000216   0x6C60             LDR      R0,[R4, #+68]
   \   00000218   0x1E40             SUBS     R0,R0,#+1
   \   0000021A   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueGenericReceive_41: (+1)
   \   0000021C   0x6C60             LDR      R0,[R4, #+68]
   \   0000021E   0x2801             CMP      R0,#+1
   \   00000220   0xDB02             BLT      ??xQueueGenericReceive_44
   \   00000222   0x6920             LDR      R0,[R4, #+16]
   \   00000224   0x2800             CMP      R0,#+0
   \   00000226   0xD1EE             BNE      ??xQueueGenericReceive_42
   \                     ??xQueueGenericReceive_44: (+1)
   \   00000228   0x6465             STR      R5,[R4, #+68]
   \   0000022A   0x.... 0x....      BL       vPortExitCritical
   1547          			( void ) xTaskResumeAll();
   \   0000022E   0x.... 0x....      BL       xTaskResumeAll
   1548          			traceQUEUE_RECEIVE_FAILED( pxQueue );
   1549          			return errQUEUE_EMPTY;
   \                     ??xQueueGenericReceive_19: (+1)
   \   00000232   0x2000             MOVS     R0,#+0
   \                     ??xQueueGenericReceive_17: (+1)
   \   00000234   0xB005             ADD      SP,SP,#+20
   \   00000236   0xBDF0             POP      {R4-R7,PC}       ;; return
   1550          		}
   1551          	}
   1552          }
   1553          /*-----------------------------------------------------------*/
   1554          

   \                                 In section .text, align 4, keep-with-next
   1555          BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
   1556          {
   \                     xQueueReceiveFromISR: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
   1557          BaseType_t xReturn;
   1558          UBaseType_t uxSavedInterruptStatus;
   1559          Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   1560          
   1561          	configASSERT( pxQueue );
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE      ??xQueueReceiveFromISR_0
   \   0000000E   0xB672             cpsid i
   \                     ??xQueueReceiveFromISR_1: (+1)
   \   00000010   0xE7FE             B        ??xQueueReceiveFromISR_1
   1562          	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueueReceiveFromISR_0: (+1)
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD102             BNE      ??xQueueReceiveFromISR_2
   \   00000016   0x6C20             LDR      R0,[R4, #+64]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD10C             BNE      ??xQueueReceiveFromISR_3
   1563          
   1564          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1565          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1566          	above the maximum system call priority are kept permanently enabled, even
   1567          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1568          	FreeRTOS API functions.  If configASSERT() is defined in freertos_cfg.h
   1569          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1570          	failure if a FreeRTOS API function is called from an interrupt that has been
   1571          	assigned a priority above the configured maximum system call priority.
   1572          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1573          	that have been assigned a priority at or (logically) below the maximum
   1574          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1575          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1576          	More information (albeit Cortex-M specific) is provided on the following
   1577          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1578          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1579          
   1580          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??xQueueReceiveFromISR_2: (+1)
   \   0000001C   0x.... 0x....      BL       ulSetInterruptMaskFromISR
   \   00000020   0x0007             MOVS     R7,R0
   1581          	{
   1582          		/* Cannot block in an ISR, so check there is data available. */
   1583          		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   \   00000022   0x6BA0             LDR      R0,[R4, #+56]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD108             BNE      ??xQueueReceiveFromISR_4
   1584          		{
   1585          			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
   1586          
   1587          			prvCopyDataFromQueue( pxQueue, pvBuffer );
   1588          			--( pxQueue->uxMessagesWaiting );
   1589          
   1590          			/* If the queue is locked the event list will not be modified.
   1591          			Instead update the lock count so the task that unlocks the queue
   1592          			will know that an ISR has removed data while the queue was
   1593          			locked. */
   1594          			if( pxQueue->xRxLock == queueUNLOCKED )
   1595          			{
   1596          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1597          				{
   1598          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1599          					{
   1600          						/* The task waiting has a higher priority than us so
   1601          						force a context switch. */
   1602          						if( pxHigherPriorityTaskWoken != NULL )
   1603          						{
   1604          							*pxHigherPriorityTaskWoken = pdTRUE;
   1605          						}
   1606          						else
   1607          						{
   1608          							mtCOVERAGE_TEST_MARKER();
   1609          						}
   1610          					}
   1611          					else
   1612          					{
   1613          						mtCOVERAGE_TEST_MARKER();
   1614          					}
   1615          				}
   1616          				else
   1617          				{
   1618          					mtCOVERAGE_TEST_MARKER();
   1619          				}
   1620          			}
   1621          			else
   1622          			{
   1623          				/* Increment the lock count so the task that unlocks the queue
   1624          				knows that data was removed while it was locked. */
   1625          				++( pxQueue->xRxLock );
   1626          			}
   1627          
   1628          			xReturn = pdPASS;
   1629          		}
   1630          		else
   1631          		{
   1632          			xReturn = pdFAIL;
   \   00000028   0x2400             MOVS     R4,#+0
   1633          			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
   1634          		}
   1635          	}
   1636          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueueReceiveFromISR_5: (+1)
   \   0000002A   0x0038             MOVS     R0,R7
   \   0000002C   0x.... 0x....      BL       vClearInterruptMaskFromISR
   1637          
   1638          	return xReturn;
   \   00000030   0x0020             MOVS     R0,R4
   \   00000032   0xB001             ADD      SP,SP,#+4
   \   00000034   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??xQueueReceiveFromISR_3: (+1)
   \   00000036   0xB672             cpsid i
   \                     ??xQueueReceiveFromISR_6: (+1)
   \   00000038   0xE7FE             B        ??xQueueReceiveFromISR_6
   \                     ??xQueueReceiveFromISR_4: (+1)
   \   0000003A   0x6C20             LDR      R0,[R4, #+64]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD00C             BEQ      ??xQueueReceiveFromISR_7
   \   00000040   0x68E1             LDR      R1,[R4, #+12]
   \   00000042   0x1808             ADDS     R0,R1,R0
   \   00000044   0x60E0             STR      R0,[R4, #+12]
   \   00000046   0x6861             LDR      R1,[R4, #+4]
   \   00000048   0x4288             CMP      R0,R1
   \   0000004A   0xD301             BCC      ??xQueueReceiveFromISR_8
   \   0000004C   0x6820             LDR      R0,[R4, #+0]
   \   0000004E   0x60E0             STR      R0,[R4, #+12]
   \                     ??xQueueReceiveFromISR_8: (+1)
   \   00000050   0x6C22             LDR      R2,[R4, #+64]
   \   00000052   0x68E1             LDR      R1,[R4, #+12]
   \   00000054   0x0028             MOVS     R0,R5
   \   00000056   0x.... 0x....      BL       __aeabi_memcpy
   \                     ??xQueueReceiveFromISR_7: (+1)
   \   0000005A   0x6BA0             LDR      R0,[R4, #+56]
   \   0000005C   0x1E40             SUBS     R0,R0,#+1
   \   0000005E   0x63A0             STR      R0,[R4, #+56]
   \   00000060   0x6C60             LDR      R0,[R4, #+68]
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000066   0x4288             CMP      R0,R1
   \   00000068   0xD10D             BNE      ??xQueueReceiveFromISR_9
   \   0000006A   0x6920             LDR      R0,[R4, #+16]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD00D             BEQ      ??xQueueReceiveFromISR_10
   \   00000070   0x3410             ADDS     R4,R4,#+16
   \   00000072   0x0020             MOVS     R0,R4
   \   00000074   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD007             BEQ      ??xQueueReceiveFromISR_10
   \   0000007C   0x2E00             CMP      R6,#+0
   \   0000007E   0xD005             BEQ      ??xQueueReceiveFromISR_10
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x6030             STR      R0,[R6, #+0]
   \   00000084   0xE002             B        ??xQueueReceiveFromISR_10
   \                     ??xQueueReceiveFromISR_9: (+1)
   \   00000086   0x6C60             LDR      R0,[R4, #+68]
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0x6460             STR      R0,[R4, #+68]
   \                     ??xQueueReceiveFromISR_10: (+1)
   \   0000008C   0x2401             MOVS     R4,#+1
   \   0000008E   0xE7CC             B        ??xQueueReceiveFromISR_5
   1639          }
   1640          /*-----------------------------------------------------------*/
   1641          

   \                                 In section .text, align 4, keep-with-next
   1642          BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
   1643          {
   \                     xQueuePeekFromISR: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   1644          BaseType_t xReturn;
   1645          UBaseType_t uxSavedInterruptStatus;
   1646          int8_t *pcOriginalReadPosition;
   1647          Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   1648          
   1649          	configASSERT( pxQueue );
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE      ??xQueuePeekFromISR_0
   \   0000000C   0xB672             cpsid i
   \                     ??xQueuePeekFromISR_1: (+1)
   \   0000000E   0xE7FE             B        ??xQueuePeekFromISR_1
   1650          	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   \                     ??xQueuePeekFromISR_0: (+1)
   \   00000010   0x6C20             LDR      R0,[R4, #+64]
   \   00000012   0x2D00             CMP      R5,#+0
   \   00000014   0xD103             BNE      ??xQueuePeekFromISR_2
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD11D             BNE      ??xQueuePeekFromISR_3
   1651          	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
   \                     ??xQueuePeekFromISR_4: (+1)
   \   0000001A   0xB672             cpsid i
   \                     ??xQueuePeekFromISR_5: (+1)
   \   0000001C   0xE7FE             B        ??xQueuePeekFromISR_5
   \                     ??xQueuePeekFromISR_2: (+1)
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD0FB             BEQ      ??xQueuePeekFromISR_4
   1652          
   1653          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1654          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1655          	above the maximum system call priority are kept permanently enabled, even
   1656          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1657          	FreeRTOS API functions.  If configASSERT() is defined in freertos_cfg.h
   1658          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1659          	failure if a FreeRTOS API function is called from an interrupt that has been
   1660          	assigned a priority above the configured maximum system call priority.
   1661          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1662          	that have been assigned a priority at or (logically) below the maximum
   1663          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1664          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1665          	More information (albeit Cortex-M specific) is provided on the following
   1666          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1667          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1668          
   1669          	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \   00000022   0x.... 0x....      BL       ulSetInterruptMaskFromISR
   \   00000026   0x0006             MOVS     R6,R0
   1670          	{
   1671          		/* Cannot block in an ISR, so check there is data available. */
   1672          		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   \   00000028   0x6BA0             LDR      R0,[R4, #+56]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD015             BEQ      ??xQueuePeekFromISR_6
   1673          		{
   1674          			traceQUEUE_PEEK_FROM_ISR( pxQueue );
   1675          
   1676          			/* Remember the read position so it can be reset as nothing is
   1677          			actually being removed from the queue. */
   1678          			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
   \   0000002E   0x68E0             LDR      R0,[R4, #+12]
   \   00000030   0x0007             MOVS     R7,R0
   1679          			prvCopyDataFromQueue( pxQueue, pvBuffer );
   \   00000032   0x6C21             LDR      R1,[R4, #+64]
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD00B             BEQ      ??xQueuePeekFromISR_7
   \   00000038   0x1840             ADDS     R0,R0,R1
   \   0000003A   0x60E0             STR      R0,[R4, #+12]
   \   0000003C   0x6861             LDR      R1,[R4, #+4]
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD301             BCC      ??xQueuePeekFromISR_8
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x60E0             STR      R0,[R4, #+12]
   \                     ??xQueuePeekFromISR_8: (+1)
   \   00000046   0x6C22             LDR      R2,[R4, #+64]
   \   00000048   0x68E1             LDR      R1,[R4, #+12]
   \   0000004A   0x0028             MOVS     R0,R5
   \   0000004C   0x.... 0x....      BL       __aeabi_memcpy
   1680          			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
   \                     ??xQueuePeekFromISR_7: (+1)
   \   00000050   0x60E7             STR      R7,[R4, #+12]
   1681          
   1682          			xReturn = pdPASS;
   \   00000052   0x2401             MOVS     R4,#+1
   \   00000054   0xE002             B        ??xQueuePeekFromISR_9
   1683          		}
   \                     ??xQueuePeekFromISR_3: (+1)
   \   00000056   0xB672             cpsid i
   \                     ??xQueuePeekFromISR_10: (+1)
   \   00000058   0xE7FE             B        ??xQueuePeekFromISR_10
   1684          		else
   1685          		{
   1686          			xReturn = pdFAIL;
   \                     ??xQueuePeekFromISR_6: (+1)
   \   0000005A   0x2400             MOVS     R4,#+0
   1687          			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
   1688          		}
   1689          	}
   1690          	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xQueuePeekFromISR_9: (+1)
   \   0000005C   0x0030             MOVS     R0,R6
   \   0000005E   0x.... 0x....      BL       vClearInterruptMaskFromISR
   1691          
   1692          	return xReturn;
   \   00000062   0x0020             MOVS     R0,R4
   \   00000064   0xB001             ADD      SP,SP,#+4
   \   00000066   0xBDF0             POP      {R4-R7,PC}       ;; return
   1693          }
   1694          /*-----------------------------------------------------------*/
   1695          

   \                                 In section .text, align 4, keep-with-next
   1696          UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
   1697          {
   \                     uxQueueMessagesWaiting: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1698          UBaseType_t uxReturn;
   1699          
   1700          	configASSERT( xQueue );
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE      ??uxQueueMessagesWaiting_0
   \   00000008   0xB672             cpsid i
   \                     ??uxQueueMessagesWaiting_1: (+1)
   \   0000000A   0xE7FE             B        ??uxQueueMessagesWaiting_1
   1701          
   1702          	taskENTER_CRITICAL();
   \                     ??uxQueueMessagesWaiting_0: (+1)
   \   0000000C   0x.... 0x....      BL       vPortEnterCritical
   1703          	{
   1704          		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
   \   00000010   0x6BA4             LDR      R4,[R4, #+56]
   1705          	}
   1706          	taskEXIT_CRITICAL();
   \   00000012   0x.... 0x....      BL       vPortExitCritical
   1707          
   1708          	return uxReturn;
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1709          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1710          /*-----------------------------------------------------------*/
   1711          

   \                                 In section .text, align 4, keep-with-next
   1712          UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
   1713          {
   \                     uxQueueSpacesAvailable: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1714          UBaseType_t uxReturn;
   1715          Queue_t *pxQueue;
   1716          
   1717          	pxQueue = ( Queue_t * ) xQueue;
   1718          	configASSERT( pxQueue );
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE      ??uxQueueSpacesAvailable_0
   \   00000008   0xB672             cpsid i
   \                     ??uxQueueSpacesAvailable_1: (+1)
   \   0000000A   0xE7FE             B        ??uxQueueSpacesAvailable_1
   1719          
   1720          	taskENTER_CRITICAL();
   \                     ??uxQueueSpacesAvailable_0: (+1)
   \   0000000C   0x.... 0x....      BL       vPortEnterCritical
   1721          	{
   1722          		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
   \   00000010   0x6BE0             LDR      R0,[R4, #+60]
   \   00000012   0x6BA1             LDR      R1,[R4, #+56]
   \   00000014   0x1A44             SUBS     R4,R0,R1
   1723          	}
   1724          	taskEXIT_CRITICAL();
   \   00000016   0x.... 0x....      BL       vPortExitCritical
   1725          
   1726          	return uxReturn;
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0xBD10             POP      {R4,PC}          ;; return
   1727          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1728          /*-----------------------------------------------------------*/
   1729          

   \                                 In section .text, align 4, keep-with-next
   1730          UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
   1731          {
   1732          UBaseType_t uxReturn;
   1733          
   1734          	configASSERT( xQueue );
   \                     uxQueueMessagesWaitingFromISR: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD101             BNE      ??uxQueueMessagesWaitingFromISR_0
   \   00000004   0xB672             cpsid i
   \                     ??uxQueueMessagesWaitingFromISR_1: (+1)
   \   00000006   0xE7FE             B        ??uxQueueMessagesWaitingFromISR_1
   1735          
   1736          	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
   \                     ??uxQueueMessagesWaitingFromISR_0: (+1)
   \   00000008   0x6B80             LDR      R0,[R0, #+56]
   1737          
   1738          	return uxReturn;
   \   0000000A   0x4770             BX       LR               ;; return
   1739          } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
   1740          /*-----------------------------------------------------------*/
   1741          

   \                                 In section .text, align 4, keep-with-next
   1742          void vQueueDelete( QueueHandle_t xQueue )
   1743          {
   \                     vQueueDelete: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1744          Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   1745          
   1746          	configASSERT( pxQueue );
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD101             BNE      ??vQueueDelete_0
   \   00000008   0xB672             cpsid i
   \                     ??vQueueDelete_1: (+1)
   \   0000000A   0xE7FE             B        ??vQueueDelete_1
   1747          
   1748          	traceQUEUE_DELETE( pxQueue );
   1749          	#if ( configQUEUE_REGISTRY_SIZE > 0 )
   1750          	{
   1751          		vQueueUnregisterQueue( pxQueue );
   \                     ??vQueueDelete_0: (+1)
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x2200             MOVS     R2,#+0
   \   00000010   0x....             LDR      R3,??DataTable2
   \   00000012   0x1D1C             ADDS     R4,R3,#+4
   \                     ??vQueueDelete_2: (+1)
   \   00000014   0x6825             LDR      R5,[R4, #+0]
   \   00000016   0x4285             CMP      R5,R0
   \   00000018   0xD004             BEQ      ??vQueueDelete_3
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0x3408             ADDS     R4,R4,#+8
   \   0000001E   0x2A0A             CMP      R2,#+10
   \   00000020   0xD202             BCS      ??vQueueDelete_4
   \   00000022   0xE7F7             B        ??vQueueDelete_2
   \                     ??vQueueDelete_3: (+1)
   \   00000024   0x00D2             LSLS     R2,R2,#+3
   \   00000026   0x5099             STR      R1,[R3, R2]
   1752          	}
   1753          	#endif
   1754          	vPortFree( pxQueue );
   \                     ??vQueueDelete_4: (+1)
   \   00000028   0x.... 0x....      BL       vPortFree
   1755          }
   \   0000002C   0xB001             ADD      SP,SP,#+4
   \   0000002E   0xBD30             POP      {R4,R5,PC}       ;; return
   1756          /*-----------------------------------------------------------*/
   1757          
   1758          #if ( configUSE_TRACE_FACILITY == 1 )
   1759          
   1760          	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
   1761          	{
   1762          		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
   1763          	}
   1764          
   1765          #endif /* configUSE_TRACE_FACILITY */
   1766          /*-----------------------------------------------------------*/
   1767          
   1768          #if ( configUSE_TRACE_FACILITY == 1 )
   1769          
   1770          	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
   1771          	{
   1772          		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
   1773          	}
   1774          
   1775          #endif /* configUSE_TRACE_FACILITY */
   1776          /*-----------------------------------------------------------*/
   1777          
   1778          #if ( configUSE_TRACE_FACILITY == 1 )
   1779          
   1780          	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
   1781          	{
   1782          		return ( ( Queue_t * ) xQueue )->ucQueueType;
   1783          	}
   1784          
   1785          #endif /* configUSE_TRACE_FACILITY */
   1786          /*-----------------------------------------------------------*/
   1787          
   1788          static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
   1789          {
   1790          BaseType_t xReturn = pdFALSE;
   1791          
   1792          	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   1793          	{
   1794          		#if ( configUSE_MUTEXES == 1 )
   1795          		{
   1796          			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   1797          			{
   1798          				/* The mutex is no longer being held. */
   1799          				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   1800          				pxQueue->pxMutexHolder = NULL;
   1801          			}
   1802          			else
   1803          			{
   1804          				mtCOVERAGE_TEST_MARKER();
   1805          			}
   1806          		}
   1807          		#endif /* configUSE_MUTEXES */
   1808          	}
   1809          	else if( xPosition == queueSEND_TO_BACK )
   1810          	{
   1811          		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
   1812          		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   1813          		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   1814          		{
   1815          			pxQueue->pcWriteTo = pxQueue->pcHead;
   1816          		}
   1817          		else
   1818          		{
   1819          			mtCOVERAGE_TEST_MARKER();
   1820          		}
   1821          	}
   1822          	else
   1823          	{
   1824          		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1825          		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   1826          		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   1827          		{
   1828          			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   1829          		}
   1830          		else
   1831          		{
   1832          			mtCOVERAGE_TEST_MARKER();
   1833          		}
   1834          
   1835          		if( xPosition == queueOVERWRITE )
   1836          		{
   1837          			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   1838          			{
   1839          				/* An item is not being added but overwritten, so subtract
   1840          				one from the recorded number of items in the queue so when
   1841          				one is added again below the number of recorded items remains
   1842          				correct. */
   1843          				--( pxQueue->uxMessagesWaiting );
   1844          			}
   1845          			else
   1846          			{
   1847          				mtCOVERAGE_TEST_MARKER();
   1848          			}
   1849          		}
   1850          		else
   1851          		{
   1852          			mtCOVERAGE_TEST_MARKER();
   1853          		}
   1854          	}
   1855          
   1856          	++( pxQueue->uxMessagesWaiting );
   1857          
   1858          	return xReturn;
   1859          }
   1860          /*-----------------------------------------------------------*/
   1861          
   1862          static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
   1863          {
   1864          	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   1865          	{
   1866          		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   1867          		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   1868          		{
   1869          			pxQueue->u.pcReadFrom = pxQueue->pcHead;
   1870          		}
   1871          		else
   1872          		{
   1873          			mtCOVERAGE_TEST_MARKER();
   1874          		}
   1875          		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
   1876          	}
   1877          }
   1878          /*-----------------------------------------------------------*/
   1879          
   1880          static void prvUnlockQueue( Queue_t * const pxQueue )
   1881          {
   1882          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
   1883          
   1884          	/* The lock counts contains the number of extra data items placed or
   1885          	removed from the queue while the queue was locked.  When a queue is
   1886          	locked items can be added or removed, but the event lists cannot be
   1887          	updated. */
   1888          	taskENTER_CRITICAL();
   1889          	{
   1890          		/* See if data was added to the queue while it was locked. */
   1891          		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   1892          		{
   1893          			/* Data was posted while the queue was locked.  Are any tasks
   1894          			blocked waiting for data to become available? */
   1895          			#if ( configUSE_QUEUE_SETS == 1 )
   1896          			{
   1897          				if( pxQueue->pxQueueSetContainer != NULL )
   1898          				{
   1899          					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
   1900          					{
   1901          						/* The queue is a member of a queue set, and posting to
   1902          						the queue set caused a higher priority task to unblock.
   1903          						A context switch is required. */
   1904          						vTaskMissedYield();
   1905          					}
   1906          					else
   1907          					{
   1908          						mtCOVERAGE_TEST_MARKER();
   1909          					}
   1910          				}
   1911          				else
   1912          				{
   1913          					/* Tasks that are removed from the event list will get added to
   1914          					the pending ready list as the scheduler is still suspended. */
   1915          					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1916          					{
   1917          						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1918          						{
   1919          							/* The task waiting has a higher priority so record that a
   1920          							context	switch is required. */
   1921          							vTaskMissedYield();
   1922          						}
   1923          						else
   1924          						{
   1925          							mtCOVERAGE_TEST_MARKER();
   1926          						}
   1927          					}
   1928          					else
   1929          					{
   1930          						break;
   1931          					}
   1932          				}
   1933          			}
   1934          			#else /* configUSE_QUEUE_SETS */
   1935          			{
   1936          				/* Tasks that are removed from the event list will get added to
   1937          				the pending ready list as the scheduler is still suspended. */
   1938          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   1939          				{
   1940          					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   1941          					{
   1942          						/* The task waiting has a higher priority so record that a
   1943          						context	switch is required. */
   1944          						vTaskMissedYield();
   1945          					}
   1946          					else
   1947          					{
   1948          						mtCOVERAGE_TEST_MARKER();
   1949          					}
   1950          				}
   1951          				else
   1952          				{
   1953          					break;
   1954          				}
   1955          			}
   1956          			#endif /* configUSE_QUEUE_SETS */
   1957          
   1958          			--( pxQueue->xTxLock );
   1959          		}
   1960          
   1961          		pxQueue->xTxLock = queueUNLOCKED;
   1962          	}
   1963          	taskEXIT_CRITICAL();
   1964          
   1965          	/* Do the same for the Rx lock. */
   1966          	taskENTER_CRITICAL();
   1967          	{
   1968          		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   1969          		{
   1970          			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   1971          			{
   1972          				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   1973          				{
   1974          					vTaskMissedYield();
   1975          				}
   1976          				else
   1977          				{
   1978          					mtCOVERAGE_TEST_MARKER();
   1979          				}
   1980          
   1981          				--( pxQueue->xRxLock );
   1982          			}
   1983          			else
   1984          			{
   1985          				break;
   1986          			}
   1987          		}
   1988          
   1989          		pxQueue->xRxLock = queueUNLOCKED;
   1990          	}
   1991          	taskEXIT_CRITICAL();
   1992          }
   1993          /*-----------------------------------------------------------*/
   1994          
   1995          static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
   1996          {
   1997          BaseType_t xReturn;
   1998          
   1999          	taskENTER_CRITICAL();
   2000          	{
   2001          		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   2002          		{
   2003          			xReturn = pdTRUE;
   2004          		}
   2005          		else
   2006          		{
   2007          			xReturn = pdFALSE;
   2008          		}
   2009          	}
   2010          	taskEXIT_CRITICAL();
   2011          
   2012          	return xReturn;
   2013          }
   2014          /*-----------------------------------------------------------*/
   2015          

   \                                 In section .text, align 4, keep-with-next
   2016          BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
   2017          {
   2018          BaseType_t xReturn;
   2019          
   2020          	configASSERT( xQueue );
   \                     xQueueIsQueueEmptyFromISR: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD101             BNE      ??xQueueIsQueueEmptyFromISR_0
   \   00000004   0xB672             cpsid i
   \                     ??xQueueIsQueueEmptyFromISR_1: (+1)
   \   00000006   0xE7FE             B        ??xQueueIsQueueEmptyFromISR_1
   2021          	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
   \                     ??xQueueIsQueueEmptyFromISR_0: (+1)
   \   00000008   0x6B80             LDR      R0,[R0, #+56]
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C   0x4180             SBCS     R0,R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
   2022          	{
   2023          		xReturn = pdTRUE;
   2024          	}
   2025          	else
   2026          	{
   2027          		xReturn = pdFALSE;
   2028          	}
   2029          
   2030          	return xReturn;
   \   00000010   0x4770             BX       LR               ;; return
   2031          } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   2032          /*-----------------------------------------------------------*/
   2033          
   2034          static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
   2035          {
   2036          BaseType_t xReturn;
   2037          
   2038          	taskENTER_CRITICAL();
   2039          	{
   2040          		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   2041          		{
   2042          			xReturn = pdTRUE;
   2043          		}
   2044          		else
   2045          		{
   2046          			xReturn = pdFALSE;
   2047          		}
   2048          	}
   2049          	taskEXIT_CRITICAL();
   2050          
   2051          	return xReturn;
   2052          }
   2053          /*-----------------------------------------------------------*/
   2054          

   \                                 In section .text, align 4, keep-with-next
   2055          BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
   2056          {
   2057          BaseType_t xReturn;
   2058          
   2059          	configASSERT( xQueue );
   \                     xQueueIsQueueFullFromISR: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD101             BNE      ??xQueueIsQueueFullFromISR_0
   \   00000004   0xB672             cpsid i
   \                     ??xQueueIsQueueFullFromISR_1: (+1)
   \   00000006   0xE7FE             B        ??xQueueIsQueueFullFromISR_1
   2060          	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
   \                     ??xQueueIsQueueFullFromISR_0: (+1)
   \   00000008   0x6B81             LDR      R1,[R0, #+56]
   \   0000000A   0x6BC0             LDR      R0,[R0, #+60]
   \   0000000C   0x4281             CMP      R1,R0
   \   0000000E   0xD101             BNE      ??xQueueIsQueueFullFromISR_2
   2061          	{
   2062          		xReturn = pdTRUE;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4770             BX       LR
   2063          	}
   2064          	else
   2065          	{
   2066          		xReturn = pdFALSE;
   \                     ??xQueueIsQueueFullFromISR_2: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   2067          	}
   2068          
   2069          	return xReturn;
   \   00000016   0x4770             BX       LR               ;; return
   2070          } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   2071          /*-----------------------------------------------------------*/
   2072          
   2073          #if ( configUSE_CO_ROUTINES == 1 )
   2074          
   2075          	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
   2076          	{
   2077          	BaseType_t xReturn;
   2078          	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   2079          
   2080          		/* If the queue is already full we may have to block.  A critical section
   2081          		is required to prevent an interrupt removing something from the queue
   2082          		between the check to see if the queue is full and blocking on the queue. */
   2083          		portDISABLE_INTERRUPTS();
   2084          		{
   2085          			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   2086          			{
   2087          				/* The queue is full - do we want to block or just leave without
   2088          				posting? */
   2089          				if( xTicksToWait > ( TickType_t ) 0 )
   2090          				{
   2091          					/* As this is called from a coroutine we cannot block directly, but
   2092          					return indicating that we need to block. */
   2093          					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
   2094          					portENABLE_INTERRUPTS();
   2095          					return errQUEUE_BLOCKED;
   2096          				}
   2097          				else
   2098          				{
   2099          					portENABLE_INTERRUPTS();
   2100          					return errQUEUE_FULL;
   2101          				}
   2102          			}
   2103          		}
   2104          		portENABLE_INTERRUPTS();
   2105          
   2106          		portDISABLE_INTERRUPTS();
   2107          		{
   2108          			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   2109          			{
   2110          				/* There is room in the queue, copy the data into the queue. */
   2111          				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
   2112          				xReturn = pdPASS;
   2113          
   2114          				/* Were any co-routines waiting for data to become available? */
   2115          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2116          				{
   2117          					/* In this instance the co-routine could be placed directly
   2118          					into the ready list as we are within a critical section.
   2119          					Instead the same pending ready list mechanism is used as if
   2120          					the event were caused from within an interrupt. */
   2121          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2122          					{
   2123          						/* The co-routine waiting has a higher priority so record
   2124          						that a yield might be appropriate. */
   2125          						xReturn = errQUEUE_YIELD;
   2126          					}
   2127          					else
   2128          					{
   2129          						mtCOVERAGE_TEST_MARKER();
   2130          					}
   2131          				}
   2132          				else
   2133          				{
   2134          					mtCOVERAGE_TEST_MARKER();
   2135          				}
   2136          			}
   2137          			else
   2138          			{
   2139          				xReturn = errQUEUE_FULL;
   2140          			}
   2141          		}
   2142          		portENABLE_INTERRUPTS();
   2143          
   2144          		return xReturn;
   2145          	}
   2146          
   2147          #endif /* configUSE_CO_ROUTINES */
   2148          /*-----------------------------------------------------------*/
   2149          
   2150          #if ( configUSE_CO_ROUTINES == 1 )
   2151          
   2152          	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
   2153          	{
   2154          	BaseType_t xReturn;
   2155          	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   2156          
   2157          		/* If the queue is already empty we may have to block.  A critical section
   2158          		is required to prevent an interrupt adding something to the queue
   2159          		between the check to see if the queue is empty and blocking on the queue. */
   2160          		portDISABLE_INTERRUPTS();
   2161          		{
   2162          			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
   2163          			{
   2164          				/* There are no messages in the queue, do we want to block or just
   2165          				leave with nothing? */
   2166          				if( xTicksToWait > ( TickType_t ) 0 )
   2167          				{
   2168          					/* As this is a co-routine we cannot block directly, but return
   2169          					indicating that we need to block. */
   2170          					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
   2171          					portENABLE_INTERRUPTS();
   2172          					return errQUEUE_BLOCKED;
   2173          				}
   2174          				else
   2175          				{
   2176          					portENABLE_INTERRUPTS();
   2177          					return errQUEUE_FULL;
   2178          				}
   2179          			}
   2180          			else
   2181          			{
   2182          				mtCOVERAGE_TEST_MARKER();
   2183          			}
   2184          		}
   2185          		portENABLE_INTERRUPTS();
   2186          
   2187          		portDISABLE_INTERRUPTS();
   2188          		{
   2189          			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   2190          			{
   2191          				/* Data is available from the queue. */
   2192          				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   2193          				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
   2194          				{
   2195          					pxQueue->u.pcReadFrom = pxQueue->pcHead;
   2196          				}
   2197          				else
   2198          				{
   2199          					mtCOVERAGE_TEST_MARKER();
   2200          				}
   2201          				--( pxQueue->uxMessagesWaiting );
   2202          				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   2203          
   2204          				xReturn = pdPASS;
   2205          
   2206          				/* Were any co-routines waiting for space to become available? */
   2207          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2208          				{
   2209          					/* In this instance the co-routine could be placed directly
   2210          					into the ready list as we are within a critical section.
   2211          					Instead the same pending ready list mechanism is used as if
   2212          					the event were caused from within an interrupt. */
   2213          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2214          					{
   2215          						xReturn = errQUEUE_YIELD;
   2216          					}
   2217          					else
   2218          					{
   2219          						mtCOVERAGE_TEST_MARKER();
   2220          					}
   2221          				}
   2222          				else
   2223          				{
   2224          					mtCOVERAGE_TEST_MARKER();
   2225          				}
   2226          			}
   2227          			else
   2228          			{
   2229          				xReturn = pdFAIL;
   2230          			}
   2231          		}
   2232          		portENABLE_INTERRUPTS();
   2233          
   2234          		return xReturn;
   2235          	}
   2236          
   2237          #endif /* configUSE_CO_ROUTINES */
   2238          /*-----------------------------------------------------------*/
   2239          
   2240          #if ( configUSE_CO_ROUTINES == 1 )
   2241          
   2242          	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
   2243          	{
   2244          	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   2245          
   2246          		/* Cannot block within an ISR so if there is no space on the queue then
   2247          		exit without doing anything. */
   2248          		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
   2249          		{
   2250          			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
   2251          
   2252          			/* We only want to wake one co-routine per ISR, so check that a
   2253          			co-routine has not already been woken. */
   2254          			if( xCoRoutinePreviouslyWoken == pdFALSE )
   2255          			{
   2256          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   2257          				{
   2258          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   2259          					{
   2260          						return pdTRUE;
   2261          					}
   2262          					else
   2263          					{
   2264          						mtCOVERAGE_TEST_MARKER();
   2265          					}
   2266          				}
   2267          				else
   2268          				{
   2269          					mtCOVERAGE_TEST_MARKER();
   2270          				}
   2271          			}
   2272          			else
   2273          			{
   2274          				mtCOVERAGE_TEST_MARKER();
   2275          			}
   2276          		}
   2277          		else
   2278          		{
   2279          			mtCOVERAGE_TEST_MARKER();
   2280          		}
   2281          
   2282          		return xCoRoutinePreviouslyWoken;
   2283          	}
   2284          
   2285          #endif /* configUSE_CO_ROUTINES */
   2286          /*-----------------------------------------------------------*/
   2287          
   2288          #if ( configUSE_CO_ROUTINES == 1 )
   2289          
   2290          	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
   2291          	{
   2292          	BaseType_t xReturn;
   2293          	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   2294          
   2295          		/* We cannot block from an ISR, so check there is data available. If
   2296          		not then just leave without doing anything. */
   2297          		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   2298          		{
   2299          			/* Copy the data from the queue. */
   2300          			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   2301          			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
   2302          			{
   2303          				pxQueue->u.pcReadFrom = pxQueue->pcHead;
   2304          			}
   2305          			else
   2306          			{
   2307          				mtCOVERAGE_TEST_MARKER();
   2308          			}
   2309          			--( pxQueue->uxMessagesWaiting );
   2310          			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
   2311          
   2312          			if( ( *pxCoRoutineWoken ) == pdFALSE )
   2313          			{
   2314          				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   2315          				{
   2316          					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   2317          					{
   2318          						*pxCoRoutineWoken = pdTRUE;
   2319          					}
   2320          					else
   2321          					{
   2322          						mtCOVERAGE_TEST_MARKER();
   2323          					}
   2324          				}
   2325          				else
   2326          				{
   2327          					mtCOVERAGE_TEST_MARKER();
   2328          				}
   2329          			}
   2330          			else
   2331          			{
   2332          				mtCOVERAGE_TEST_MARKER();
   2333          			}
   2334          
   2335          			xReturn = pdPASS;
   2336          		}
   2337          		else
   2338          		{
   2339          			xReturn = pdFAIL;
   2340          		}
   2341          
   2342          		return xReturn;
   2343          	}
   2344          
   2345          #endif /* configUSE_CO_ROUTINES */
   2346          /*-----------------------------------------------------------*/
   2347          
   2348          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   2349          

   \                                 In section .text, align 2, keep-with-next
   2350          	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2351          	{
   \                     vQueueAddToRegistry: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   2352          	UBaseType_t ux;
   2353          
   2354          		/* See if there is an empty space in the registry.  A NULL name denotes
   2355          		a free slot. */
   2356          		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x....             LDR      R3,??DataTable2
   \   00000006   0x001C             MOVS     R4,R3
   2357          		{
   2358          			if( xQueueRegistry[ ux ].pcQueueName == NULL )
   \                     ??vQueueAddToRegistry_0: (+1)
   \   00000008   0x6825             LDR      R5,[R4, #+0]
   \   0000000A   0x2D00             CMP      R5,#+0
   \   0000000C   0xD104             BNE      ??vQueueAddToRegistry_1
   2359          			{
   2360          				/* Store the information on this queue. */
   2361          				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
   \   0000000E   0x00D2             LSLS     R2,R2,#+3
   \   00000010   0x189A             ADDS     R2,R3,R2
   \   00000012   0x6011             STR      R1,[R2, #+0]
   2362          				xQueueRegistry[ ux ].xHandle = xQueue;
   \   00000014   0x6050             STR      R0,[R2, #+4]
   2363          
   2364          				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
   2365          				break;
   \   00000016   0xE003             B        ??vQueueAddToRegistry_2
   2366          			}
   2367          			else
   2368          			{
   2369          				mtCOVERAGE_TEST_MARKER();
   2370          			}
   2371          		}
   \                     ??vQueueAddToRegistry_1: (+1)
   \   00000018   0x1C52             ADDS     R2,R2,#+1
   \   0000001A   0x3408             ADDS     R4,R4,#+8
   \   0000001C   0x2A0A             CMP      R2,#+10
   \   0000001E   0xD3F3             BCC      ??vQueueAddToRegistry_0
   2372          	}
   \                     ??vQueueAddToRegistry_2: (+1)
   \   00000020   0xBC30             POP      {R4,R5}
   \   00000022   0x4770             BX       LR               ;; return
   2373          
   2374          #endif /* configQUEUE_REGISTRY_SIZE */
   2375          /*-----------------------------------------------------------*/
   2376          
   2377          #if ( configQUEUE_REGISTRY_SIZE > 0 )
   2378          

   \                                 In section .text, align 2, keep-with-next
   2379          	void vQueueUnregisterQueue( QueueHandle_t xQueue )
   2380          	{
   \                     vQueueUnregisterQueue: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   2381          	UBaseType_t ux;
   2382          
   2383          		/* See if the handle of the queue being unregistered in actually in the
   2384          		registry. */
   2385          		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x....             LDR      R3,??DataTable2
   \   00000008   0x1D1C             ADDS     R4,R3,#+4
   2386          		{
   2387          			if( xQueueRegistry[ ux ].xHandle == xQueue )
   \                     ??vQueueUnregisterQueue_0: (+1)
   \   0000000A   0x6825             LDR      R5,[R4, #+0]
   \   0000000C   0x4285             CMP      R5,R0
   \   0000000E   0xD102             BNE      ??vQueueUnregisterQueue_1
   2388          			{
   2389          				/* Set the name to NULL to show that this slot if free again. */
   2390          				xQueueRegistry[ ux ].pcQueueName = NULL;
   \   00000010   0x00D0             LSLS     R0,R2,#+3
   \   00000012   0x5019             STR      R1,[R3, R0]
   2391          				break;
   \   00000014   0xE003             B        ??vQueueUnregisterQueue_2
   2392          			}
   2393          			else
   2394          			{
   2395          				mtCOVERAGE_TEST_MARKER();
   2396          			}
   2397          		}
   \                     ??vQueueUnregisterQueue_1: (+1)
   \   00000016   0x1C52             ADDS     R2,R2,#+1
   \   00000018   0x3408             ADDS     R4,R4,#+8
   \   0000001A   0x2A0A             CMP      R2,#+10
   \   0000001C   0xD3F5             BCC      ??vQueueUnregisterQueue_0
   2398          
   2399          	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
   \                     ??vQueueUnregisterQueue_2: (+1)
   \   0000001E   0xBC30             POP      {R4,R5}
   \   00000020   0x4770             BX       LR               ;; return
   2400          
   2401          #endif /* configQUEUE_REGISTRY_SIZE */
   2402          /*-----------------------------------------------------------*/
   2403          
   2404          #if ( configUSE_TIMERS == 1 )
   2405          

   \                                 In section .text, align 2, keep-with-next
   2406          	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
   2407          	{
   \                     vQueueWaitForMessageRestricted: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   2408          	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   2409          
   2410          		/* This function should not be called by application code hence the
   2411          		'Restricted' in its name.  It is not part of the public API.  It is
   2412          		designed for use by kernel code, and has special calling requirements.
   2413          		It can result in vListInsert() being called on a list that can only
   2414          		possibly ever have one item in it, so the list will be fast, but even
   2415          		so it should be called with the scheduler locked and not from a critical
   2416          		section. */
   2417          
   2418          		/* Only do anything if there are no messages in the queue.  This function
   2419          		will not actually cause the task to block, just place it on a blocked
   2420          		list.  It will not block until the scheduler is unlocked - at which
   2421          		time a yield will be performed.  If an item is added to the queue while
   2422          		the queue is locked, and the calling task blocks on the queue, then the
   2423          		calling task will be immediately unblocked when the queue is unlocked. */
   2424          		prvLockQueue( pxQueue );
   \   00000006   0x.... 0x....      BL       vPortEnterCritical
   \   0000000A   0x2500             MOVS     R5,#+0
   \   0000000C   0x43ED             MVNS     R5,R5            ;; #-1
   \   0000000E   0x6C60             LDR      R0,[R4, #+68]
   \   00000010   0x42A8             CMP      R0,R5
   \   00000012   0xD101             BNE      ??vQueueWaitForMessageRestricted_0
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6460             STR      R0,[R4, #+68]
   \                     ??vQueueWaitForMessageRestricted_0: (+1)
   \   00000018   0x6CA0             LDR      R0,[R4, #+72]
   \   0000001A   0x42A8             CMP      R0,R5
   \   0000001C   0xD101             BNE      ??vQueueWaitForMessageRestricted_1
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x64A0             STR      R0,[R4, #+72]
   \                     ??vQueueWaitForMessageRestricted_1: (+1)
   \   00000022   0x.... 0x....      BL       vPortExitCritical
   2425          		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
   \   00000026   0x6BA0             LDR      R0,[R4, #+56]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD104             BNE      ??vQueueWaitForMessageRestricted_2
   2426          		{
   2427          			/* There is nothing in the queue, block for the specified period. */
   2428          			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   \   0000002C   0x0031             MOVS     R1,R6
   \   0000002E   0x0020             MOVS     R0,R4
   \   00000030   0x3024             ADDS     R0,R0,#+36
   \   00000032   0x.... 0x....      BL       vTaskPlaceOnEventListRestricted
   2429          		}
   2430          		else
   2431          		{
   2432          			mtCOVERAGE_TEST_MARKER();
   2433          		}
   2434          		prvUnlockQueue( pxQueue );
   \                     ??vQueueWaitForMessageRestricted_2: (+1)
   \   00000036   0x.... 0x....      BL       vPortEnterCritical
   \   0000003A   0xE00A             B        ??vQueueWaitForMessageRestricted_3
   \                     ??vQueueWaitForMessageRestricted_4: (+1)
   \   0000003C   0x0020             MOVS     R0,R4
   \   0000003E   0x3024             ADDS     R0,R0,#+36
   \   00000040   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD001             BEQ      ??vQueueWaitForMessageRestricted_5
   \   00000048   0x.... 0x....      BL       vTaskMissedYield
   \                     ??vQueueWaitForMessageRestricted_5: (+1)
   \   0000004C   0x6CA0             LDR      R0,[R4, #+72]
   \   0000004E   0x1E40             SUBS     R0,R0,#+1
   \   00000050   0x64A0             STR      R0,[R4, #+72]
   \                     ??vQueueWaitForMessageRestricted_3: (+1)
   \   00000052   0x6CA0             LDR      R0,[R4, #+72]
   \   00000054   0x2801             CMP      R0,#+1
   \   00000056   0xDB02             BLT      ??vQueueWaitForMessageRestricted_6
   \   00000058   0x6A60             LDR      R0,[R4, #+36]
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD1EE             BNE      ??vQueueWaitForMessageRestricted_4
   \                     ??vQueueWaitForMessageRestricted_6: (+1)
   \   0000005E   0x64A5             STR      R5,[R4, #+72]
   \   00000060   0x.... 0x....      BL       vPortExitCritical
   \   00000064   0x.... 0x....      BL       vPortEnterCritical
   \   00000068   0xE00A             B        ??vQueueWaitForMessageRestricted_7
   \                     ??vQueueWaitForMessageRestricted_8: (+1)
   \   0000006A   0x0020             MOVS     R0,R4
   \   0000006C   0x3010             ADDS     R0,R0,#+16
   \   0000006E   0x.... 0x....      BL       xTaskRemoveFromEventList
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD001             BEQ      ??vQueueWaitForMessageRestricted_9
   \   00000076   0x.... 0x....      BL       vTaskMissedYield
   \                     ??vQueueWaitForMessageRestricted_9: (+1)
   \   0000007A   0x6C60             LDR      R0,[R4, #+68]
   \   0000007C   0x1E40             SUBS     R0,R0,#+1
   \   0000007E   0x6460             STR      R0,[R4, #+68]
   \                     ??vQueueWaitForMessageRestricted_7: (+1)
   \   00000080   0x6C60             LDR      R0,[R4, #+68]
   \   00000082   0x2801             CMP      R0,#+1
   \   00000084   0xDB02             BLT      ??vQueueWaitForMessageRestricted_10
   \   00000086   0x6920             LDR      R0,[R4, #+16]
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD1EE             BNE      ??vQueueWaitForMessageRestricted_8
   \                     ??vQueueWaitForMessageRestricted_10: (+1)
   \   0000008C   0x6465             STR      R5,[R4, #+68]
   \   0000008E   0x.... 0x....      BL       vPortExitCritical
   2435          	}
   \   00000092   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     xQueueRegistry
   2436          
   2437          #endif /* configUSE_TIMERS */
   2438          /*-----------------------------------------------------------*/
   2439          
   2440          #if ( configUSE_QUEUE_SETS == 1 )
   2441          
   2442          	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
   2443          	{
   2444          	QueueSetHandle_t pxQueue;
   2445          
   2446          		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
   2447          
   2448          		return pxQueue;
   2449          	}
   2450          
   2451          #endif /* configUSE_QUEUE_SETS */
   2452          /*-----------------------------------------------------------*/
   2453          
   2454          #if ( configUSE_QUEUE_SETS == 1 )
   2455          
   2456          	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
   2457          	{
   2458          	BaseType_t xReturn;
   2459          
   2460          		taskENTER_CRITICAL();
   2461          		{
   2462          			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
   2463          			{
   2464          				/* Cannot add a queue/semaphore to more than one queue set. */
   2465          				xReturn = pdFAIL;
   2466          			}
   2467          			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
   2468          			{
   2469          				/* Cannot add a queue/semaphore to a queue set if there are already
   2470          				items in the queue/semaphore. */
   2471          				xReturn = pdFAIL;
   2472          			}
   2473          			else
   2474          			{
   2475          				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
   2476          				xReturn = pdPASS;
   2477          			}
   2478          		}
   2479          		taskEXIT_CRITICAL();
   2480          
   2481          		return xReturn;
   2482          	}
   2483          
   2484          #endif /* configUSE_QUEUE_SETS */
   2485          /*-----------------------------------------------------------*/
   2486          
   2487          #if ( configUSE_QUEUE_SETS == 1 )
   2488          
   2489          	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
   2490          	{
   2491          	BaseType_t xReturn;
   2492          	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
   2493          
   2494          		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
   2495          		{
   2496          			/* The queue was not a member of the set. */
   2497          			xReturn = pdFAIL;
   2498          		}
   2499          		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
   2500          		{
   2501          			/* It is dangerous to remove a queue from a set when the queue is
   2502          			not empty because the queue set will still hold pending events for
   2503          			the queue. */
   2504          			xReturn = pdFAIL;
   2505          		}
   2506          		else
   2507          		{
   2508          			taskENTER_CRITICAL();
   2509          			{
   2510          				/* The queue is no longer contained in the set. */
   2511          				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
   2512          			}
   2513          			taskEXIT_CRITICAL();
   2514          			xReturn = pdPASS;
   2515          		}
   2516          
   2517          		return xReturn;
   2518          	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
   2519          
   2520          #endif /* configUSE_QUEUE_SETS */
   2521          /*-----------------------------------------------------------*/
   2522          
   2523          #if ( configUSE_QUEUE_SETS == 1 )
   2524          
   2525          	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
   2526          	{
   2527          	QueueSetMemberHandle_t xReturn = NULL;
   2528          
   2529          		( void ) xQueueGenericReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait, pdFALSE ); /*lint !e961 Casting from one typedef to another is not redundant. */
   2530          		return xReturn;
   2531          	}
   2532          
   2533          #endif /* configUSE_QUEUE_SETS */
   2534          /*-----------------------------------------------------------*/
   2535          
   2536          #if ( configUSE_QUEUE_SETS == 1 )
   2537          
   2538          	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
   2539          	{
   2540          	QueueSetMemberHandle_t xReturn = NULL;
   2541          
   2542          		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
   2543          		return xReturn;
   2544          	}
   2545          
   2546          #endif /* configUSE_QUEUE_SETS */
   2547          /*-----------------------------------------------------------*/
   2548          
   2549          #if ( configUSE_QUEUE_SETS == 1 )
   2550          
   2551          	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
   2552          	{
   2553          	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
   2554          	BaseType_t xReturn = pdFALSE;
   2555          
   2556          		/* This function must be called form a critical section. */
   2557          
   2558          		configASSERT( pxQueueSetContainer );
   2559          		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
   2560          
   2561          		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
   2562          		{
   2563          			traceQUEUE_SEND( pxQueueSetContainer );
   2564          
   2565          			/* The data copied is the handle of the queue that contains data. */
   2566          			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
   2567          
   2568          			if( pxQueueSetContainer->xTxLock == queueUNLOCKED )
   2569          			{
   2570          				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
   2571          				{
   2572          					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
   2573          					{
   2574          						/* The task waiting has a higher priority. */
   2575          						xReturn = pdTRUE;
   2576          					}
   2577          					else
   2578          					{
   2579          						mtCOVERAGE_TEST_MARKER();
   2580          					}
   2581          				}
   2582          				else
   2583          				{
   2584          					mtCOVERAGE_TEST_MARKER();
   2585          				}
   2586          			}
   2587          			else
   2588          			{
   2589          				( pxQueueSetContainer->xTxLock )++;
   2590          			}
   2591          		}
   2592          		else
   2593          		{
   2594          			mtCOVERAGE_TEST_MARKER();
   2595          		}
   2596          
   2597          		return xReturn;
   2598          	}
   2599          
   2600          #endif /* configUSE_QUEUE_SETS */
   2601          
   2602          
   2603          
   2604          
   2605          
   2606          
   2607          
   2608          
   2609          
   2610          
   2611          
   2612          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   uxQueueMessagesWaiting
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       0   uxQueueMessagesWaitingFromISR
       8   uxQueueSpacesAvailable
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   vQueueAddToRegistry
      16   vQueueDelete
        16   -> vPortFree
       8   vQueueUnregisterQueue
      16   vQueueWaitForMessageRestricted
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskMissedYield
        16   -> vTaskPlaceOnEventListRestricted
        16   -> xTaskRemoveFromEventList
      16   xQueueGenericCreate
        16   -> pvPortMalloc
        16   -> xQueueGenericReset
      40   xQueueGenericReceive
        40   -> __aeabi_memcpy
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vPortYield
        40   -> vTaskMissedYield
        40   -> vTaskPlaceOnEventList
        40   -> vTaskSetTimeOutState
        40   -> vTaskSuspendAll
        40   -> xTaskCheckForTimeOut
        40   -> xTaskGetSchedulerState
        40   -> xTaskRemoveFromEventList
        40   -> xTaskResumeAll
      16   xQueueGenericReset
        16   -> vListInitialise
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYield
        16   -> xTaskRemoveFromEventList
      40   xQueueGenericSend
        40   -> __aeabi_memcpy
        40   -> vPortEnterCritical
        40   -> vPortExitCritical
        40   -> vPortYield
        40   -> vTaskMissedYield
        40   -> vTaskPlaceOnEventList
        40   -> vTaskSetTimeOutState
        40   -> vTaskSuspendAll
        40   -> xTaskCheckForTimeOut
        40   -> xTaskGetSchedulerState
        40   -> xTaskRemoveFromEventList
        40   -> xTaskResumeAll
      24   xQueueGenericSendFromISR
        24   -> __aeabi_memcpy
        24   -> ulSetInterruptMaskFromISR
        24   -> vClearInterruptMaskFromISR
        24   -> xTaskRemoveFromEventList
      16   xQueueGiveFromISR
        16   -> ulSetInterruptMaskFromISR
        16   -> vClearInterruptMaskFromISR
        16   -> xTaskRemoveFromEventList
       0   xQueueIsQueueEmptyFromISR
       0   xQueueIsQueueFullFromISR
      24   xQueuePeekFromISR
        24   -> __aeabi_memcpy
        24   -> ulSetInterruptMaskFromISR
        24   -> vClearInterruptMaskFromISR
      24   xQueueReceiveFromISR
        20   -> __aeabi_memcpy
        24   -> ulSetInterruptMaskFromISR
        24   -> vClearInterruptMaskFromISR
        24   -> xTaskRemoveFromEventList


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
      26  uxQueueMessagesWaiting
      12  uxQueueMessagesWaitingFromISR
      30  uxQueueSpacesAvailable
      36  vQueueAddToRegistry
      48  vQueueDelete
      34  vQueueUnregisterQueue
     148  vQueueWaitForMessageRestricted
      68  xQueueGenericCreate
     568  xQueueGenericReceive
     116  xQueueGenericReset
     620  xQueueGenericSend
     212  xQueueGenericSendFromISR
     120  xQueueGiveFromISR
      18  xQueueIsQueueEmptyFromISR
      24  xQueueIsQueueFullFromISR
     104  xQueuePeekFromISR
     144  xQueueReceiveFromISR
      80  xQueueRegistry

 
    80 bytes in section .bss
 2 332 bytes in section .text
 
 2 332 bytes of CODE memory
    80 bytes of DATA memory

Errors: none
Warnings: none
