###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        07/Feb/2017  17:55:58
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Freescale\KM128SWDRV_R4_1_6\src\freertos\tasks.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freertos\tasks.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\freertos\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\freertos\iar\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\projects\gpioqueue_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\List\tasks.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\Obj\tasks.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\freertos\tasks.c
      1          /*
      2              FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          #include <string.h>
     73          
     74          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     75          all the API functions to use the MPU wrappers.  That should only be done when
     76          task.h is included from an application file. */
     77          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     78          
     79          /* FreeRTOS includes. */
     80          #include "freertos.h"
     81          #include "task.h"
     82          #include "timers.h"
     83          #include "stack_macros.h"
     84          
     85          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     86          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     87          header files above, but not in this file, in order to generate the correct
     88          privileged Vs unprivileged linkage and placement. */
     89          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     90          
     91          /* Set configUSE_STATS_FORMATTING_FUNCTIONS to 2 to include the stats formatting
     92          functions but without including stdio.h here. */
     93          #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
     94          	/* At the bottom of this file are two optional functions that can be used
     95          	to generate human readable text from the raw data generated by the
     96          	uxTaskGetSystemState() function.  Note the formatting functions are provided
     97          	for convenience only, and are NOT considered part of the kernel. */
     98          	#include <stdio.h>
     99          #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
    100          
    101          /* Sanity check the configuration. */
    102          #if configUSE_TICKLESS_IDLE != 0
    103          	#if INCLUDE_vTaskSuspend != 1
    104          		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
    105          	#endif /* INCLUDE_vTaskSuspend */
    106          #endif /* configUSE_TICKLESS_IDLE */
    107          
    108          /*
    109           * Defines the size, in words, of the stack allocated to the idle task.
    110           */
    111          #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
    112          
    113          #if( configUSE_PREEMPTION == 0 )
    114          	/* If the cooperative scheduler is being used then a yield should not be
    115          	performed just because a higher priority task has been woken. */
    116          	#define taskYIELD_IF_USING_PREEMPTION()
    117          #else
    118          	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
    119          #endif
    120          
    121          /* Value that can be assigned to the eNotifyState member of the TCB. */
    122          typedef enum
    123          {
    124          	eNotWaitingNotification = 0,
    125          	eWaitingNotification,
    126          	eNotified
    127          } eNotifyValue;
    128          
    129          /*
    130           * Task control block.  A task control block (TCB) is allocated for each task,
    131           * and stores task state information, including a pointer to the task's context
    132           * (the task's run time environment, including register values)
    133           */
    134          typedef struct tskTaskControlBlock
    135          {
    136          	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
    137          
    138          	#if ( portUSING_MPU_WRAPPERS == 1 )
    139          		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
    140          		BaseType_t		xUsingStaticallyAllocatedStack; /* Set to pdTRUE if the stack is a statically allocated array, and pdFALSE if the stack is dynamically allocated. */
    141          	#endif
    142          
    143          	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
    144          	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
    145          	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
    146          	StackType_t			*pxStack;			/*< Points to the start of the stack. */
    147          	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    148          
    149          	#if ( portSTACK_GROWTH > 0 )
    150          		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
    151          	#endif
    152          
    153          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
    154          		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
    155          	#endif
    156          
    157          	#if ( configUSE_TRACE_FACILITY == 1 )
    158          		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
    159          		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
    160          	#endif
    161          
    162          	#if ( configUSE_MUTEXES == 1 )
    163          		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
    164          		UBaseType_t 	uxMutexesHeld;
    165          	#endif
    166          
    167          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
    168          		TaskHookFunction_t pxTaskTag;
    169          	#endif
    170          
    171          	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
    172          		void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
    173          	#endif
    174          
    175          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
    176          		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
    177          	#endif
    178          
    179          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
    180          		/* Allocate a Newlib reent structure that is specific to this task.
    181          		Note Newlib support has been included by popular demand, but is not
    182          		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
    183          		responsible for resulting newlib operation.  User must be familiar with
    184          		newlib and must provide system-wide implementations of the necessary
    185          		stubs. Be warned that (at the time of writing) the current newlib design
    186          		implements a system-wide malloc() that must be provided with locks. */
    187          		struct 	_reent xNewLib_reent;
    188          	#endif
    189          
    190          	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
    191          		volatile uint32_t ulNotifiedValue;
    192          		volatile eNotifyValue eNotifyState;
    193          	#endif
    194          
    195          } tskTCB;
    196          
    197          /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
    198          below to enable the use of older kernel aware debuggers. */
    199          typedef tskTCB TCB_t;
    200          
    201          /*
    202           * Some kernel aware debuggers require the data the debugger needs access to to
    203           * be global, rather than file scope.
    204           */
    205          #ifdef portREMOVE_STATIC_QUALIFIER
    206          	#define static
    207          #endif
    208          
    209          /*lint -e956 A manual analysis and inspection has been used to determine which
    210          static variables must be declared volatile. */
    211          
    212          PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
    213          
    214          /* Lists for ready and blocked tasks. --------------------*/
    215          PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
    216          PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
    217          PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
    218          PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
    219          PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */

   \                                 In section .bss, align 4
    220          PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
   \                     xPendingReadyList:
   \   00000000                      DS8 20
   \   00000014                      DS8 20
   \   00000028                      DS8 4
   \   0000002C                      DS8 4
   \   00000030                      DS8 4
   \   00000034                      DS8 4
   \   00000038                      DS8 4

   \                                 In section .data, align 4
   \                     pxCurrentTCB:
   \   00000000   0x00000000         DC32 0H
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000034   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000054   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000068   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000006C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000070   0x00000000         DC32 0
   \   00000074   0x00000000         DC32 0
   \   00000078   0x00000000         DC32 0
   \   0000007C   0xFFFFFFFF         DC32 4294967295
   \   00000080   0x00000000         DC32 0
   \   00000084   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000098   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
    221          
    222          #if ( INCLUDE_vTaskDelete == 1 )
    223          
    224          	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
    225          	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
    226          
    227          #endif
    228          
    229          #if ( INCLUDE_vTaskSuspend == 1 )
    230          
    231          	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
    232          
    233          #endif
    234          
    235          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
    236          
    237          	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
    238          
    239          #endif
    240          
    241          /* Other file private variables. --------------------------------*/
    242          PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
    243          PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
    244          PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
    245          PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
    246          PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
    247          PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
    248          PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
    249          PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
    250          PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= portMAX_DELAY;
    251          
    252          /* Context switches are held pending while the scheduler is suspended.  Also,
    253          interrupts must not manipulate the xGenericListItem of a TCB, or any of the
    254          lists the xGenericListItem can be referenced from, if the scheduler is suspended.
    255          If an interrupt needs to unblock a task while the scheduler is suspended then it
    256          moves the task's event list item into the xPendingReadyList, ready for the
    257          kernel to move the task from the pending ready list into the real ready list
    258          when the scheduler is unsuspended.  The pending ready list itself can only be
    259          accessed from a critical section. */
    260          PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
    261          
    262          #if ( configGENERATE_RUN_TIME_STATS == 1 )
    263          
    264          	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
    265          	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
    266          
    267          #endif
    268          
    269          /*lint +e956 */
    270          
    271          /* Debugging and trace facilities private variables and macros. ------------*/
    272          
    273          /*
    274           * The value used to fill the stack of a task when the task is created.  This
    275           * is used purely for checking the high water mark for tasks.
    276           */
    277          #define tskSTACK_FILL_BYTE	( 0xa5U )
    278          
    279          /*
    280           * Macros used by vListTask to indicate which state a task is in.
    281           */
    282          #define tskBLOCKED_CHAR		( 'B' )
    283          #define tskREADY_CHAR		( 'R' )
    284          #define tskDELETED_CHAR		( 'D' )
    285          #define tskSUSPENDED_CHAR	( 'S' )
    286          
    287          /*-----------------------------------------------------------*/
    288          
    289          #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
    290          
    291          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
    292          	performed in a generic way that is not optimised to any particular
    293          	microcontroller architecture. */
    294          
    295          	/* uxTopReadyPriority holds the priority of the highest priority ready
    296          	state task. */
    297          	#define taskRECORD_READY_PRIORITY( uxPriority )														\
    298          	{																									\
    299          		if( ( uxPriority ) > uxTopReadyPriority )														\
    300          		{																								\
    301          			uxTopReadyPriority = ( uxPriority );														\
    302          		}																								\
    303          	} /* taskRECORD_READY_PRIORITY */
    304          
    305          	/*-----------------------------------------------------------*/
    306          
    307          	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
    308          	{																									\
    309          		/* Find the highest priority queue that contains ready tasks. */								\
    310          		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
    311          		{																								\
    312          			configASSERT( uxTopReadyPriority );															\
    313          			--uxTopReadyPriority;																		\
    314          		}																								\
    315          																										\
    316          		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
    317          		the	same priority get an equal share of the processor time. */									\
    318          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
    319          	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
    320          
    321          	/*-----------------------------------------------------------*/
    322          
    323          	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
    324          	they are only required when a port optimised method of task selection is
    325          	being used. */
    326          	#define taskRESET_READY_PRIORITY( uxPriority )
    327          	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    328          
    329          #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    330          
    331          	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
    332          	performed in a way that is tailored to the particular microcontroller
    333          	architecture being used. */
    334          
    335          	/* A port optimised version is provided.  Call the port defined macros. */
    336          	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
    337          
    338          	/*-----------------------------------------------------------*/
    339          
    340          	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
    341          	{																								\
    342          	UBaseType_t uxTopPriority;																		\
    343          																									\
    344          		/* Find the highest priority queue that contains ready tasks. */							\
    345          		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
    346          		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
    347          		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
    348          	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
    349          
    350          	/*-----------------------------------------------------------*/
    351          
    352          	/* A port optimised version is provided, call it only if the TCB being reset
    353          	is being referenced from a ready list.  If it is referenced from a delayed
    354          	or suspended list then it won't be in a ready list. */
    355          	#define taskRESET_READY_PRIORITY( uxPriority )														\
    356          	{																									\
    357          		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == ( UBaseType_t ) 0 )	\
    358          		{																								\
    359          			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );							\
    360          		}																								\
    361          	}
    362          
    363          #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
    364          
    365          /*-----------------------------------------------------------*/
    366          
    367          /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
    368          count overflows. */
    369          #define taskSWITCH_DELAYED_LISTS()																	\
    370          {																									\
    371          	List_t *pxTemp;																					\
    372          																									\
    373          	/* The delayed tasks list should be empty when the lists are switched. */						\
    374          	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
    375          																									\
    376          	pxTemp = pxDelayedTaskList;																		\
    377          	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
    378          	pxOverflowDelayedTaskList = pxTemp;																\
    379          	xNumOfOverflows++;																				\
    380          	prvResetNextTaskUnblockTime();																	\
    381          }
    382          
    383          /*-----------------------------------------------------------*/
    384          
    385          /*
    386           * Place the task represented by pxTCB into the appropriate ready list for
    387           * the task.  It is inserted at the end of the list.
    388           */
    389          #define prvAddTaskToReadyList( pxTCB )																\
    390          	traceMOVED_TASK_TO_READY_STATE( pxTCB );														\
    391          	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
    392          	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
    393          /*-----------------------------------------------------------*/
    394          
    395          /*
    396           * Several functions take an TaskHandle_t parameter that can optionally be NULL,
    397           * where NULL is used to indicate that the handle of the currently executing
    398           * task should be used in place of the parameter.  This macro simply checks to
    399           * see if the parameter is NULL and returns a pointer to the appropriate TCB.
    400           */
    401          #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
    402          
    403          /* The item value of the event list item is normally used to hold the priority
    404          of the task to which it belongs (coded to allow it to be held in reverse
    405          priority order).  However, it is occasionally borrowed for other purposes.  It
    406          is important its value is not updated due to a task priority change while it is
    407          being used for another purpose.  The following bit definition is used to inform
    408          the scheduler that the value should not be changed - in which case it is the
    409          responsibility of whichever module is using the value to ensure it gets set back
    410          to its original value when it is released. */
    411          #if configUSE_16_BIT_TICKS == 1
    412          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
    413          #else
    414          	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
    415          #endif
    416          
    417          /* Callback function prototypes. --------------------------*/
    418          #if configCHECK_FOR_STACK_OVERFLOW > 0
    419          	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
    420          #endif
    421          
    422          #if configUSE_TICK_HOOK > 0
    423          	extern void vApplicationTickHook( void );
    424          #endif
    425          
    426          /* File private functions. --------------------------------*/
    427          
    428          /*
    429           * Utility to ready a TCB for a given task.  Mainly just copies the parameters
    430           * into the TCB structure.
    431           */
    432          static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    433          
    434          /**
    435           * Utility task that simply returns pdTRUE if the task referenced by xTask is
    436           * currently in the Suspended state, or pdFALSE if the task referenced by xTask
    437           * is in any other state.
    438           */
    439          #if ( INCLUDE_vTaskSuspend == 1 )
    440          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
    441          #endif /* INCLUDE_vTaskSuspend */
    442          
    443          /*
    444           * Utility to ready all the lists used by the scheduler.  This is called
    445           * automatically upon the creation of the first task.
    446           */
    447          static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
    448          
    449          /*
    450           * The idle task, which as all tasks is implemented as a never ending loop.
    451           * The idle task is automatically created and added to the ready lists upon
    452           * creation of the first user task.
    453           *
    454           * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
    455           * language extensions.  The equivalent prototype for this function is:
    456           *
    457           * void prvIdleTask( void *pvParameters );
    458           *
    459           */
    460          static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
    461          
    462          /*
    463           * Utility to free all memory allocated by the scheduler to hold a TCB,
    464           * including the stack pointed to by the TCB.
    465           *
    466           * This does not free memory allocated by the task itself (i.e. memory
    467           * allocated by calls to pvPortMalloc from within the tasks application code).
    468           */
    469          #if ( INCLUDE_vTaskDelete == 1 )
    470          
    471          	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
    472          
    473          #endif
    474          
    475          /*
    476           * Used only by the idle task.  This checks to see if anything has been placed
    477           * in the list of tasks waiting to be deleted.  If so the task is cleaned up
    478           * and its TCB deleted.
    479           */
    480          static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
    481          
    482          /*
    483           * The currently executing task is entering the Blocked state.  Add the task to
    484           * either the current or the overflow delayed task list.
    485           */
    486          static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
    487          
    488          /*
    489           * Allocates memory from the heap for a TCB and associated stack.  Checks the
    490           * allocation was successful.
    491           */
    492          static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer ) PRIVILEGED_FUNCTION;
    493          
    494          /*
    495           * Fills an TaskStatus_t structure with information on each task that is
    496           * referenced from the pxList list (which may be a ready list, a delayed list,
    497           * a suspended list, etc.).
    498           *
    499           * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
    500           * NORMAL APPLICATION CODE.
    501           */
    502          #if ( configUSE_TRACE_FACILITY == 1 )
    503          
    504          	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
    505          
    506          #endif
    507          
    508          /*
    509           * When a task is created, the stack of the task is filled with a known value.
    510           * This function determines the 'high water mark' of the task stack by
    511           * determining how much of the stack remains at the original preset value.
    512           */
    513          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
    514          
    515          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
    516          
    517          #endif
    518          
    519          /*
    520           * Return the amount of time, in ticks, that will pass before the kernel will
    521           * next move a task from the Blocked state to the Running state.
    522           *
    523           * This conditional compilation should use inequality to 0, not equality to 1.
    524           * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
    525           * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
    526           * set to a value other than 1.
    527           */
    528          #if ( configUSE_TICKLESS_IDLE != 0 )
    529          
    530          	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
    531          
    532          #endif
    533          
    534          /*
    535           * Set xNextTaskUnblockTime to the time at which the next Blocked state task
    536           * will exit the Blocked state.
    537           */
    538          static void prvResetNextTaskUnblockTime( void );
    539          
    540          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
    541          
    542          	/*
    543          	 * Helper function used to pad task names with spaces when printing out
    544          	 * human readable tables of task information.
    545          	 */
    546          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName );
    547          
    548          #endif
    549          /*-----------------------------------------------------------*/
    550          

   \                                 In section .text, align 4, keep-with-next
    551          BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    552          {
   \                     xTaskGenericCreate: (+1)
   \   00000000   0xB5F9             PUSH     {R0,R3-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x0015             MOVS     R5,R2
    553          BaseType_t xReturn;
    554          TCB_t * pxNewTCB;
    555          StackType_t *pxTopOfStack;
    556          
    557          	configASSERT( pxTaskCode );
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD101             BNE      ??xTaskGenericCreate_0
   \   0000000C   0xB672             cpsid i
   \                     ??xTaskGenericCreate_1: (+1)
   \   0000000E   0xE7FE             B        ??xTaskGenericCreate_1
    558          	configASSERT( ( ( uxPriority & ( UBaseType_t ) ( ~portPRIVILEGE_BIT ) ) < ( UBaseType_t ) configMAX_PRIORITIES ) );
   \                     ??xTaskGenericCreate_0: (+1)
   \   00000010   0x9808             LDR      R0,[SP, #+32]
   \   00000012   0x2805             CMP      R0,#+5
   \   00000014   0xD301             BCC      ??xTaskGenericCreate_2
   \   00000016   0xB672             cpsid i
   \                     ??xTaskGenericCreate_3: (+1)
   \   00000018   0xE7FE             B        ??xTaskGenericCreate_3
   \                     ??xTaskGenericCreate_2: (+1)
   \   0000001A   0x9E0A             LDR      R6,[SP, #+40]
    559          
    560          	/* Allocate the memory required by the TCB and stack for the new task,
    561          	checking that the allocation was successful. */
    562          	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD103             BNE      ??xTaskGenericCreate_4
   \   00000020   0x00A8             LSLS     R0,R5,#+2
   \   00000022   0x.... 0x....      BL       pvPortMalloc
   \   00000026   0x0006             MOVS     R6,R0
   \                     ??xTaskGenericCreate_4: (+1)
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD068             BEQ      ??xTaskGenericCreate_5
   \   0000002C   0x2060             MOVS     R0,#+96
   \   0000002E   0x.... 0x....      BL       pvPortMalloc
   \   00000032   0x0004             MOVS     R4,R0
   \   00000034   0xD060             BEQ      ??xTaskGenericCreate_6
   \   00000036   0x6326             STR      R6,[R4, #+48]
    563          
    564          	if( pxNewTCB != NULL )
    565          	{
    566          		#if( portUSING_MPU_WRAPPERS == 1 )
    567          			/* Should the task be created in privileged mode? */
    568          			BaseType_t xRunPrivileged;
    569          			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
    570          			{
    571          				xRunPrivileged = pdTRUE;
    572          			}
    573          			else
    574          			{
    575          				xRunPrivileged = pdFALSE;
    576          			}
    577          			uxPriority &= ~portPRIVILEGE_BIT;
    578          
    579          			if( puxStackBuffer != NULL )
    580          			{
    581          				/* The application provided its own stack.  Note this so no
    582          				attempt is made to delete the stack should that task be
    583          				deleted. */
    584          				pxNewTCB->xUsingStaticallyAllocatedStack = pdTRUE;
    585          			}
    586          			else
    587          			{
    588          				/* The stack was allocated dynamically.  Note this so it can be
    589          				deleted again if the task is deleted. */
    590          				pxNewTCB->xUsingStaticallyAllocatedStack = pdFALSE;
    591          			}
    592          		#endif /* portUSING_MPU_WRAPPERS == 1 */
    593          
    594          		/* Calculate the top of stack address.  This depends on whether the
    595          		stack grows from high memory to low (as per the 80x86) or vice versa.
    596          		portSTACK_GROWTH is used to make the result positive or negative as
    597          		required by the port. */
    598          		#if( portSTACK_GROWTH < 0 )
    599          		{
    600          			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
    601          			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   \   00000038   0x00A9             LSLS     R1,R5,#+2
   \   0000003A   0x1875             ADDS     R5,R6,R1
   \   0000003C   0x1F2D             SUBS     R5,R5,#+4
   \   0000003E   0x2007             MOVS     R0,#+7
   \   00000040   0x4385             BICS     R5,R5,R0
    602          
    603          			/* Check the alignment of the calculated top of stack is correct. */
    604          			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    605          		}
    606          		#else /* portSTACK_GROWTH */
    607          		{
    608          			pxTopOfStack = pxNewTCB->pxStack;
    609          
    610          			/* Check the alignment of the stack buffer is correct. */
    611          			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
    612          
    613          			/* If we want to use stack checking on architectures that use
    614          			a positive stack growth direction then we also need to store the
    615          			other extreme of the stack space. */
    616          			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
    617          		}
    618          		#endif /* portSTACK_GROWTH */
    619          
    620          		/* Setup the newly allocated TCB with the initial state of the task. */
    621          		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
   \   00000042   0x9808             LDR      R0,[SP, #+32]
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0x0020             MOVS     R0,R4
   \   00000048   0x3034             ADDS     R0,R0,#+52
   \   0000004A   0x2110             MOVS     R1,#+16
   \                     ??xTaskGenericCreate_7: (+1)
   \   0000004C   0x783A             LDRB     R2,[R7, #+0]
   \   0000004E   0x7002             STRB     R2,[R0, #+0]
   \   00000050   0x783A             LDRB     R2,[R7, #+0]
   \   00000052   0x2A00             CMP      R2,#+0
   \   00000054   0xD156             BNE      ??xTaskGenericCreate_8
   \                     ??xTaskGenericCreate_9: (+1)
   \   00000056   0x2600             MOVS     R6,#+0
   \   00000058   0x2143             MOVS     R1,#+67
   \   0000005A   0x5466             STRB     R6,[R4, R1]
   \   0000005C   0x9800             LDR      R0,[SP, #+0]
   \   0000005E   0x62E0             STR      R0,[R4, #+44]
   \   00000060   0x1D20             ADDS     R0,R4,#+4
   \   00000062   0x.... 0x....      BL       vListInitialiseItem
   \   00000066   0x0020             MOVS     R0,R4
   \   00000068   0x3018             ADDS     R0,R0,#+24
   \   0000006A   0x.... 0x....      BL       vListInitialiseItem
   \   0000006E   0x6124             STR      R4,[R4, #+16]
   \   00000070   0x2005             MOVS     R0,#+5
   \   00000072   0x9900             LDR      R1,[SP, #+0]
   \   00000074   0x1A40             SUBS     R0,R0,R1
   \   00000076   0x61A0             STR      R0,[R4, #+24]
   \   00000078   0x6264             STR      R4,[R4, #+36]
   \   0000007A   0x0020             MOVS     R0,R4
   \   0000007C   0x3044             ADDS     R0,R0,#+68
   \   0000007E   0x2705             MOVS     R7,#+5
   \   00000080   0x2105             MOVS     R1,#+5
   \                     ??xTaskGenericCreate_10: (+1)
   \   00000082   0x6006             STR      R6,[R0, #+0]
   \   00000084   0x1D00             ADDS     R0,R0,#+4
   \   00000086   0x1E49             SUBS     R1,R1,#+1
   \   00000088   0xD1FB             BNE      ??xTaskGenericCreate_10
   \   0000008A   0x0020             MOVS     R0,R4
   \   0000008C   0x3058             ADDS     R0,R0,#+88
   \   0000008E   0x6006             STR      R6,[R0, #+0]
   \   00000090   0x7106             STRB     R6,[R0, #+4]
    622          
    623          		/* Initialize the TCB stack to look as if the task was already running,
    624          		but had been interrupted by the scheduler.  The return address is set
    625          		to the start of the task function. Once the stack has been initialised
    626          		the	top of stack variable is updated. */
    627          		#if( portUSING_MPU_WRAPPERS == 1 )
    628          		{
    629          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
    630          		}
    631          		#else /* portUSING_MPU_WRAPPERS */
    632          		{
    633          			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   \   00000092   0x9A02             LDR      R2,[SP, #+8]
   \   00000094   0x9901             LDR      R1,[SP, #+4]
   \   00000096   0x0028             MOVS     R0,R5
   \   00000098   0x.... 0x....      BL       pxPortInitialiseStack
   \   0000009C   0x6020             STR      R0,[R4, #+0]
   \   0000009E   0x9809             LDR      R0,[SP, #+36]
    634          		}
    635          		#endif /* portUSING_MPU_WRAPPERS */
    636          
    637          		if( ( void * ) pxCreatedTask != NULL )
   \   000000A0   0x2800             CMP      R0,#+0
   \   000000A2   0xD000             BEQ      ??xTaskGenericCreate_11
    638          		{
    639          			/* Pass the TCB out - in an anonymous way.  The calling function/
    640          			task can use this as a handle to delete the task later if
    641          			required.*/
    642          			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   \   000000A4   0x6004             STR      R4,[R0, #+0]
    643          		}
    644          		else
    645          		{
    646          			mtCOVERAGE_TEST_MARKER();
    647          		}
    648          
    649          		/* Ensure interrupts don't access the task lists while they are being
    650          		updated. */
    651          		taskENTER_CRITICAL();
   \                     ??xTaskGenericCreate_11: (+1)
   \   000000A6   0x.... 0x....      BL       vPortEnterCritical
   \   000000AA   0x....             LDR      R0,??DataTable6
   \   000000AC   0x6A80             LDR      R0,[R0, #+40]
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \   000000B0   0x....             LDR      R1,??DataTable6
   \   000000B2   0x6288             STR      R0,[R1, #+40]
    652          		{
    653          			uxCurrentNumberOfTasks++;
    654          			if( pxCurrentTCB == NULL )
   \   000000B4   0x....             LDR      R5,??DataTable6_1
   \   000000B6   0x6828             LDR      R0,[R5, #+0]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD128             BNE      ??xTaskGenericCreate_12
    655          			{
    656          				/* There are no other tasks, or all the other tasks are in
    657          				the suspended state - make this the current task. */
    658          				pxCurrentTCB =  pxNewTCB;
   \   000000BC   0x602C             STR      R4,[R5, #+0]
    659          
    660          				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   \   000000BE   0x6A88             LDR      R0,[R1, #+40]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD12D             BNE      ??xTaskGenericCreate_13
    661          				{
    662          					/* This is the first task to be created so do the preliminary
    663          					initialisation required.  We will not recover if this call
    664          					fails, but we will report the failure. */
    665          					prvInitialiseTaskLists();
   \   000000C4   0x1D2E             ADDS     R6,R5,#+4
   \                     ??xTaskGenericCreate_14: (+1)
   \   000000C6   0x0030             MOVS     R0,R6
   \   000000C8   0x.... 0x....      BL       vListInitialise
   \   000000CC   0x3614             ADDS     R6,R6,#+20
   \   000000CE   0x1E7F             SUBS     R7,R7,#+1
   \   000000D0   0xD1F9             BNE      ??xTaskGenericCreate_14
   \   000000D2   0x002F             MOVS     R7,R5
   \   000000D4   0x3784             ADDS     R7,R7,#+132
   \   000000D6   0x0038             MOVS     R0,R7
   \   000000D8   0x.... 0x....      BL       vListInitialise
   \   000000DC   0x002E             MOVS     R6,R5
   \   000000DE   0x3698             ADDS     R6,R6,#+152
   \   000000E0   0x0030             MOVS     R0,R6
   \   000000E2   0x.... 0x....      BL       vListInitialise
   \   000000E6   0x....             LDR      R0,??DataTable6
   \   000000E8   0x.... 0x....      BL       vListInitialise
   \   000000EC   0x....             LDR      R0,??DataTable7
   \   000000EE   0x.... 0x....      BL       vListInitialise
   \   000000F2   0x66AF             STR      R7,[R5, #+104]
   \   000000F4   0x66EE             STR      R6,[R5, #+108]
    666          				}
    667          				else
    668          				{
    669          					mtCOVERAGE_TEST_MARKER();
    670          				}
    671          			}
   \   000000F6   0xE013             B        ??xTaskGenericCreate_13
   \                     ??xTaskGenericCreate_6: (+1)
   \   000000F8   0x0030             MOVS     R0,R6
   \   000000FA   0x.... 0x....      BL       vPortFree
    672          			else
    673          			{
    674          				/* If the scheduler is not already running, make this task the
    675          				current task if it is the highest priority task to be created
    676          				so far. */
    677          				if( xSchedulerRunning == pdFALSE )
    678          				{
    679          					if( pxCurrentTCB->uxPriority <= uxPriority )
    680          					{
    681          						pxCurrentTCB = pxNewTCB;
    682          					}
    683          					else
    684          					{
    685          						mtCOVERAGE_TEST_MARKER();
    686          					}
    687          				}
    688          				else
    689          				{
    690          					mtCOVERAGE_TEST_MARKER();
    691          				}
    692          			}
    693          
    694          			uxTaskNumber++;
    695          
    696          			#if ( configUSE_TRACE_FACILITY == 1 )
    697          			{
    698          				/* Add a counter into the TCB for tracing only. */
    699          				pxNewTCB->uxTCBNumber = uxTaskNumber;
    700          			}
    701          			#endif /* configUSE_TRACE_FACILITY */
    702          			traceTASK_CREATE( pxNewTCB );
    703          
    704          			prvAddTaskToReadyList( pxNewTCB );
    705          
    706          			xReturn = pdPASS;
    707          			portSETUP_TCB( pxNewTCB );
    708          		}
    709          		taskEXIT_CRITICAL();
    710          	}
    711          	else
    712          	{
    713          		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   \                     ??xTaskGenericCreate_5: (+1)
   \   000000FE   0x2400             MOVS     R4,#+0
   \   00000100   0x43E4             MVNS     R4,R4            ;; #-1
   \   00000102   0xE02C             B        ??xTaskGenericCreate_15
   \                     ??xTaskGenericCreate_8: (+1)
   \   00000104   0x1C7F             ADDS     R7,R7,#+1
   \   00000106   0x1C40             ADDS     R0,R0,#+1
   \   00000108   0x1E49             SUBS     R1,R1,#+1
   \   0000010A   0xD0A4             BEQ      ??xTaskGenericCreate_9
   \   0000010C   0xE79E             B        ??xTaskGenericCreate_7
    714          		traceTASK_CREATE_FAILED();
    715          	}
   \                     ??xTaskGenericCreate_12: (+1)
   \   0000010E   0x6B08             LDR      R0,[R1, #+48]
   \   00000110   0x2800             CMP      R0,#+0
   \   00000112   0xD105             BNE      ??xTaskGenericCreate_13
   \   00000114   0x9808             LDR      R0,[SP, #+32]
   \   00000116   0x6829             LDR      R1,[R5, #+0]
   \   00000118   0x6AC9             LDR      R1,[R1, #+44]
   \   0000011A   0x4288             CMP      R0,R1
   \   0000011C   0xD300             BCC      ??xTaskGenericCreate_13
   \   0000011E   0x602C             STR      R4,[R5, #+0]
   \                     ??xTaskGenericCreate_13: (+1)
   \   00000120   0x6FA8             LDR      R0,[R5, #+120]
   \   00000122   0x1C40             ADDS     R0,R0,#+1
   \   00000124   0x67A8             STR      R0,[R5, #+120]
   \   00000126   0x6AE0             LDR      R0,[R4, #+44]
   \   00000128   0x6F29             LDR      R1,[R5, #+112]
   \   0000012A   0x4281             CMP      R1,R0
   \   0000012C   0xD200             BCS      ??xTaskGenericCreate_16
   \   0000012E   0x6728             STR      R0,[R5, #+112]
   \                     ??xTaskGenericCreate_16: (+1)
   \   00000130   0x1D21             ADDS     R1,R4,#+4
   \   00000132   0x6AE0             LDR      R0,[R4, #+44]
   \   00000134   0x0082             LSLS     R2,R0,#+2
   \   00000136   0x1810             ADDS     R0,R2,R0
   \   00000138   0x0080             LSLS     R0,R0,#+2
   \   0000013A   0x1828             ADDS     R0,R5,R0
   \   0000013C   0x1D00             ADDS     R0,R0,#+4
   \   0000013E   0x.... 0x....      BL       vListInsertEnd
   \   00000142   0x2401             MOVS     R4,#+1
   \   00000144   0x.... 0x....      BL       vPortExitCritical
    716          
    717          	if( xReturn == pdPASS )
    718          	{
    719          		if( xSchedulerRunning != pdFALSE )
   \   00000148   0x....             LDR      R0,??DataTable6
   \   0000014A   0x6B00             LDR      R0,[R0, #+48]
   \   0000014C   0x2800             CMP      R0,#+0
   \   0000014E   0xD006             BEQ      ??xTaskGenericCreate_15
    720          		{
    721          			/* If the created task is of a higher priority than the current task
    722          			then it should run now. */
    723          			if( pxCurrentTCB->uxPriority < uxPriority )
   \   00000150   0x6828             LDR      R0,[R5, #+0]
   \   00000152   0x6AC0             LDR      R0,[R0, #+44]
   \   00000154   0x9908             LDR      R1,[SP, #+32]
   \   00000156   0x4288             CMP      R0,R1
   \   00000158   0xD201             BCS      ??xTaskGenericCreate_15
    724          			{
    725          				taskYIELD_IF_USING_PREEMPTION();
   \   0000015A   0x.... 0x....      BL       vPortYield
    726          			}
    727          			else
    728          			{
    729          				mtCOVERAGE_TEST_MARKER();
    730          			}
    731          		}
    732          		else
    733          		{
    734          			mtCOVERAGE_TEST_MARKER();
    735          		}
    736          	}
    737          
    738          	return xReturn;
   \                     ??xTaskGenericCreate_15: (+1)
   \   0000015E   0x0020             MOVS     R0,R4
   \   00000160   0xB003             ADD      SP,SP,#+12
   \   00000162   0xBDF0             POP      {R4-R7,PC}       ;; return
    739          }
    740          /*-----------------------------------------------------------*/
    741          
    742          #if ( INCLUDE_vTaskDelete == 1 )
    743          
    744          	void vTaskDelete( TaskHandle_t xTaskToDelete )
    745          	{
    746          	TCB_t *pxTCB;
    747          
    748          		taskENTER_CRITICAL();
    749          		{
    750          			/* If null is passed in here then it is the calling task that is
    751          			being deleted. */
    752          			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    753          
    754          			/* Remove task from the ready list and place in the	termination list.
    755          			This will stop the task from be scheduled.  The idle task will check
    756          			the termination list and free up any memory allocated by the
    757          			scheduler for the TCB and stack. */
    758          			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    759          			{
    760          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
    761          			}
    762          			else
    763          			{
    764          				mtCOVERAGE_TEST_MARKER();
    765          			}
    766          
    767          			/* Is the task waiting on an event also? */
    768          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    769          			{
    770          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    771          			}
    772          			else
    773          			{
    774          				mtCOVERAGE_TEST_MARKER();
    775          			}
    776          
    777          			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    778          
    779          			/* Increment the ucTasksDeleted variable so the idle task knows
    780          			there is a task that has been deleted and that it should therefore
    781          			check the xTasksWaitingTermination list. */
    782          			++uxTasksDeleted;
    783          
    784          			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
    785          			can detect that the task lists need re-generating. */
    786          			uxTaskNumber++;
    787          
    788          			traceTASK_DELETE( pxTCB );
    789          		}
    790          		taskEXIT_CRITICAL();
    791          
    792          		/* Force a reschedule if it is the currently running task that has just
    793          		been deleted. */
    794          		if( xSchedulerRunning != pdFALSE )
    795          		{
    796          			if( pxTCB == pxCurrentTCB )
    797          			{
    798          				configASSERT( uxSchedulerSuspended == 0 );
    799          
    800          				/* The pre-delete hook is primarily for the Windows simulator,
    801          				in which Windows specific clean up operations are performed,
    802          				after which it is not possible to yield away from this task -
    803          				hence xYieldPending is used to latch that a context switch is
    804          				required. */
    805          				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
    806          				portYIELD_WITHIN_API();
    807          			}
    808          			else
    809          			{
    810          				/* Reset the next expected unblock time in case it referred to
    811          				the task that has just been deleted. */
    812          				taskENTER_CRITICAL();
    813          				{
    814          					prvResetNextTaskUnblockTime();
    815          				}
    816          				taskEXIT_CRITICAL();
    817          			}
    818          		}
    819          	}
    820          
    821          #endif /* INCLUDE_vTaskDelete */
    822          /*-----------------------------------------------------------*/
    823          
    824          #if ( INCLUDE_vTaskDelayUntil == 1 )
    825          

   \                                 In section .text, align 4, keep-with-next
    826          	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
    827          	{
   \                     vTaskDelayUntil: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    828          	TickType_t xTimeToWake;
    829          	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    830          
    831          		configASSERT( pxPreviousWakeTime );
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD101             BNE      ??vTaskDelayUntil_0
   \   00000006   0xB672             cpsid i
   \                     ??vTaskDelayUntil_1: (+1)
   \   00000008   0xE7FE             B        ??vTaskDelayUntil_1
    832          		configASSERT( ( xTimeIncrement > 0U ) );
   \                     ??vTaskDelayUntil_0: (+1)
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD101             BNE      ??vTaskDelayUntil_2
   \   0000000E   0xB672             cpsid i
   \                     ??vTaskDelayUntil_3: (+1)
   \   00000010   0xE7FE             B        ??vTaskDelayUntil_3
    833          		configASSERT( uxSchedulerSuspended == 0 );
   \                     ??vTaskDelayUntil_2: (+1)
   \   00000012   0x....             LDR      R4,??DataTable6_1
   \   00000014   0x0022             MOVS     R2,R4
   \   00000016   0x3280             ADDS     R2,R2,#+128
   \   00000018   0x6813             LDR      R3,[R2, #+0]
   \   0000001A   0x2B00             CMP      R3,#+0
   \   0000001C   0xD001             BEQ      ??vTaskDelayUntil_4
   \   0000001E   0xB672             cpsid i
   \                     ??vTaskDelayUntil_5: (+1)
   \   00000020   0xE7FE             B        ??vTaskDelayUntil_5
    834          
    835          		vTaskSuspendAll();
   \                     ??vTaskDelayUntil_4: (+1)
   \   00000022   0x6813             LDR      R3,[R2, #+0]
   \   00000024   0x1C5B             ADDS     R3,R3,#+1
   \   00000026   0x6013             STR      R3,[R2, #+0]
    836          		{
    837          			/* Minor optimisation.  The tick count cannot change in this
    838          			block. */
    839          			const TickType_t xConstTickCount = xTickCount;
   \   00000028   0x....             LDR      R6,??DataTable6
   \   0000002A   0x6AF2             LDR      R2,[R6, #+44]
    840          
    841          			/* Generate the tick time at which the task wants to wake. */
    842          			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   \   0000002C   0x6803             LDR      R3,[R0, #+0]
   \   0000002E   0x185D             ADDS     R5,R3,R1
    843          
    844          			if( xConstTickCount < *pxPreviousWakeTime )
   \   00000030   0x429A             CMP      R2,R3
   \   00000032   0xD203             BCS      ??vTaskDelayUntil_6
    845          			{
    846          				/* The tick count has overflowed since this function was
    847          				lasted called.  In this case the only time we should ever
    848          				actually delay is if the wake time has also	overflowed,
    849          				and the wake time is greater than the tick time.  When this
    850          				is the case it is as if neither time had overflowed. */
    851          				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
   \   00000034   0x429D             CMP      R5,R3
   \   00000036   0xD303             BCC      ??vTaskDelayUntil_7
   \                     ??vTaskDelayUntil_8: (+1)
   \   00000038   0x6005             STR      R5,[R0, #+0]
   \   0000003A   0xE01B             B        ??vTaskDelayUntil_9
    852          				{
    853          					xShouldDelay = pdTRUE;
    854          				}
    855          				else
    856          				{
    857          					mtCOVERAGE_TEST_MARKER();
    858          				}
    859          			}
    860          			else
    861          			{
    862          				/* The tick time has not overflowed.  In this case we will
    863          				delay if either the wake time has overflowed, and/or the
    864          				tick time is less than the wake time. */
    865          				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
   \                     ??vTaskDelayUntil_6: (+1)
   \   0000003C   0x429D             CMP      R5,R3
   \   0000003E   0xD301             BCC      ??vTaskDelayUntil_10
   \                     ??vTaskDelayUntil_7: (+1)
   \   00000040   0x42AA             CMP      R2,R5
   \   00000042   0xD2F9             BCS      ??vTaskDelayUntil_8
    866          				{
    867          					xShouldDelay = pdTRUE;
   \                     ??vTaskDelayUntil_10: (+1)
   \   00000044   0x6005             STR      R5,[R0, #+0]
    868          				}
    869          				else
    870          				{
    871          					mtCOVERAGE_TEST_MARKER();
    872          				}
    873          			}
    874          
    875          			/* Update the wake time ready for the next call. */
    876          			*pxPreviousWakeTime = xTimeToWake;
    877          
    878          			if( xShouldDelay != pdFALSE )
    879          			{
    880          				traceTASK_DELAY_UNTIL();
    881          
    882          				/* Remove the task from the ready list before adding it to the
    883          				blocked list as the same list item is used for both lists. */
    884          				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x1D00             ADDS     R0,R0,#+4
   \   0000004A   0x.... 0x....      BL       uxListRemove
    885          				{
    886          					/* The current task must be in a ready list, so there is
    887          					no need to check, and the port reset macro can be called
    888          					directly. */
    889          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    890          				}
    891          				else
    892          				{
    893          					mtCOVERAGE_TEST_MARKER();
    894          				}
    895          
    896          				prvAddCurrentTaskToDelayedList( xTimeToWake );
   \   0000004E   0x6820             LDR      R0,[R4, #+0]
   \   00000050   0x6045             STR      R5,[R0, #+4]
   \   00000052   0x6AF0             LDR      R0,[R6, #+44]
   \   00000054   0x4285             CMP      R5,R0
   \   00000056   0x6821             LDR      R1,[R4, #+0]
   \   00000058   0xD204             BCS      ??vTaskDelayUntil_11
   \   0000005A   0x1D09             ADDS     R1,R1,#+4
   \   0000005C   0x6EE0             LDR      R0,[R4, #+108]
   \   0000005E   0x.... 0x....      BL       vListInsert
   \   00000062   0xE007             B        ??vTaskDelayUntil_9
   \                     ??vTaskDelayUntil_11: (+1)
   \   00000064   0x1D09             ADDS     R1,R1,#+4
   \   00000066   0x6EA0             LDR      R0,[R4, #+104]
   \   00000068   0x.... 0x....      BL       vListInsert
   \   0000006C   0x6FE0             LDR      R0,[R4, #+124]
   \   0000006E   0x4285             CMP      R5,R0
   \   00000070   0xD200             BCS      ??vTaskDelayUntil_9
   \   00000072   0x67E5             STR      R5,[R4, #+124]
    897          			}
    898          			else
    899          			{
    900          				mtCOVERAGE_TEST_MARKER();
    901          			}
    902          		}
    903          		xAlreadyYielded = xTaskResumeAll();
    904          
    905          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    906          		have put ourselves to sleep. */
    907          		if( xAlreadyYielded == pdFALSE )
   \                     ??vTaskDelayUntil_9: (+1)
   \   00000074   0x.... 0x....      BL       xTaskResumeAll
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD101             BNE      ??vTaskDelayUntil_12
    908          		{
    909          			portYIELD_WITHIN_API();
   \   0000007C   0x.... 0x....      BL       vPortYield
    910          		}
    911          		else
    912          		{
    913          			mtCOVERAGE_TEST_MARKER();
    914          		}
    915          	}
   \                     ??vTaskDelayUntil_12: (+1)
   \   00000080   0xBD70             POP      {R4-R6,PC}       ;; return
    916          
    917          #endif /* INCLUDE_vTaskDelayUntil */
    918          /*-----------------------------------------------------------*/
    919          
    920          #if ( INCLUDE_vTaskDelay == 1 )
    921          

   \                                 In section .text, align 4, keep-with-next
    922          	void vTaskDelay( const TickType_t xTicksToDelay )
    923          	{
   \                     vTaskDelay: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0005             MOVS     R5,R0
    924          	TickType_t xTimeToWake;
    925          	BaseType_t xAlreadyYielded = pdFALSE;
    926          
    927          
    928          		/* A delay time of zero just forces a reschedule. */
    929          		if( xTicksToDelay > ( TickType_t ) 0U )
   \   00000006   0xD028             BEQ      ??vTaskDelay_0
    930          		{
    931          			configASSERT( uxSchedulerSuspended == 0 );
   \   00000008   0x....             LDR      R4,??DataTable6_1
   \   0000000A   0x0020             MOVS     R0,R4
   \   0000000C   0x3080             ADDS     R0,R0,#+128
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD001             BEQ      ??vTaskDelay_1
   \   00000014   0xB672             cpsid i
   \                     ??vTaskDelay_2: (+1)
   \   00000016   0xE7FE             B        ??vTaskDelay_2
    932          			vTaskSuspendAll();
   \                     ??vTaskDelay_1: (+1)
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    933          			{
    934          				traceTASK_DELAY();
    935          
    936          				/* A task that is removed from the event list while the
    937          				scheduler is suspended will not get placed in the ready
    938          				list or removed from the blocked list until the scheduler
    939          				is resumed.
    940          
    941          				This task cannot be in an event list as it is the currently
    942          				executing task. */
    943          
    944          				/* Calculate the time to wake - this may overflow but this is
    945          				not a problem. */
    946          				xTimeToWake = xTickCount + xTicksToDelay;
   \   0000001E   0x....             LDR      R6,??DataTable6
   \   00000020   0x6AF7             LDR      R7,[R6, #+44]
    947          
    948          				/* We must remove ourselves from the ready list before adding
    949          				ourselves to the blocked list as the same list item is used for
    950          				both lists. */
    951          				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   \   00000022   0x6820             LDR      R0,[R4, #+0]
   \   00000024   0x1D00             ADDS     R0,R0,#+4
   \   00000026   0x.... 0x....      BL       uxListRemove
    952          				{
    953          					/* The current task must be in a ready list, so there is
    954          					no need to check, and the port reset macro can be called
    955          					directly. */
    956          					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
    957          				}
    958          				else
    959          				{
    960          					mtCOVERAGE_TEST_MARKER();
    961          				}
    962          				prvAddCurrentTaskToDelayedList( xTimeToWake );
   \   0000002A   0x197D             ADDS     R5,R7,R5
   \   0000002C   0x6820             LDR      R0,[R4, #+0]
   \   0000002E   0x6045             STR      R5,[R0, #+4]
   \   00000030   0x6AF0             LDR      R0,[R6, #+44]
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0x6821             LDR      R1,[R4, #+0]
   \   00000036   0xD204             BCS      ??vTaskDelay_3
   \   00000038   0x1D09             ADDS     R1,R1,#+4
   \   0000003A   0x6EE0             LDR      R0,[R4, #+108]
   \   0000003C   0x.... 0x....      BL       vListInsert
   \   00000040   0xE007             B        ??vTaskDelay_4
   \                     ??vTaskDelay_3: (+1)
   \   00000042   0x1D09             ADDS     R1,R1,#+4
   \   00000044   0x6EA0             LDR      R0,[R4, #+104]
   \   00000046   0x.... 0x....      BL       vListInsert
   \   0000004A   0x6FE0             LDR      R0,[R4, #+124]
   \   0000004C   0x4285             CMP      R5,R0
   \   0000004E   0xD200             BCS      ??vTaskDelay_4
   \   00000050   0x67E5             STR      R5,[R4, #+124]
    963          			}
    964          			xAlreadyYielded = xTaskResumeAll();
    965          		}
    966          		else
    967          		{
    968          			mtCOVERAGE_TEST_MARKER();
    969          		}
    970          
    971          		/* Force a reschedule if xTaskResumeAll has not already done so, we may
    972          		have put ourselves to sleep. */
    973          		if( xAlreadyYielded == pdFALSE )
   \                     ??vTaskDelay_4: (+1)
   \   00000052   0x.... 0x....      BL       xTaskResumeAll
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD101             BNE      ??vTaskDelay_5
    974          		{
    975          			portYIELD_WITHIN_API();
   \                     ??vTaskDelay_0: (+1)
   \   0000005A   0x.... 0x....      BL       vPortYield
    976          		}
    977          		else
    978          		{
    979          			mtCOVERAGE_TEST_MARKER();
    980          		}
    981          	}
   \                     ??vTaskDelay_5: (+1)
   \   0000005E   0xB001             ADD      SP,SP,#+4
   \   00000060   0xBDF0             POP      {R4-R7,PC}       ;; return
    982          
    983          #endif /* INCLUDE_vTaskDelay */
    984          /*-----------------------------------------------------------*/
    985          
    986          #if ( INCLUDE_eTaskGetState == 1 )
    987          
    988          	eTaskState eTaskGetState( TaskHandle_t xTask )
    989          	{
    990          	eTaskState eReturn;
    991          	List_t *pxStateList;
    992          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
    993          
    994          		configASSERT( pxTCB );
    995          
    996          		if( pxTCB == pxCurrentTCB )
    997          		{
    998          			/* The task calling this function is querying its own state. */
    999          			eReturn = eRunning;
   1000          		}
   1001          		else
   1002          		{
   1003          			taskENTER_CRITICAL();
   1004          			{
   1005          				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
   1006          			}
   1007          			taskEXIT_CRITICAL();
   1008          
   1009          			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
   1010          			{
   1011          				/* The task being queried is referenced from one of the Blocked
   1012          				lists. */
   1013          				eReturn = eBlocked;
   1014          			}
   1015          
   1016          			#if ( INCLUDE_vTaskSuspend == 1 )
   1017          				else if( pxStateList == &xSuspendedTaskList )
   1018          				{
   1019          					/* The task being queried is referenced from the suspended
   1020          					list.  Is it genuinely suspended or is it block
   1021          					indefinitely? */
   1022          					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
   1023          					{
   1024          						eReturn = eSuspended;
   1025          					}
   1026          					else
   1027          					{
   1028          						eReturn = eBlocked;
   1029          					}
   1030          				}
   1031          			#endif
   1032          
   1033          			#if ( INCLUDE_vTaskDelete == 1 )
   1034          				else if( pxStateList == &xTasksWaitingTermination )
   1035          				{
   1036          					/* The task being queried is referenced from the deleted
   1037          					tasks list. */
   1038          					eReturn = eDeleted;
   1039          				}
   1040          			#endif
   1041          
   1042          			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
   1043          			{
   1044          				/* If the task is not in any other state, it must be in the
   1045          				Ready (including pending ready) state. */
   1046          				eReturn = eReady;
   1047          			}
   1048          		}
   1049          
   1050          		return eReturn;
   1051          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1052          
   1053          #endif /* INCLUDE_eTaskGetState */
   1054          /*-----------------------------------------------------------*/
   1055          
   1056          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1057          

   \                                 In section .text, align 2, keep-with-next
   1058          	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
   1059          	{
   \                     uxTaskPriorityGet: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1060          	TCB_t *pxTCB;
   1061          	UBaseType_t uxReturn;
   1062          
   1063          		taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
   1064          		{
   1065          			/* If null is passed in here then we are changing the
   1066          			priority of the calling function. */
   1067          			pxTCB = prvGetTCBFromHandle( xTask );
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE      ??uxTaskPriorityGet_0
   \   0000000C   0x....             LDR      R0,??DataTable6_1
   \   0000000E   0x6804             LDR      R4,[R0, #+0]
   1068          			uxReturn = pxTCB->uxPriority;
   \                     ??uxTaskPriorityGet_0: (+1)
   \   00000010   0x6AE4             LDR      R4,[R4, #+44]
   1069          		}
   1070          		taskEXIT_CRITICAL();
   \   00000012   0x.... 0x....      BL       vPortExitCritical
   1071          
   1072          		return uxReturn;
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1073          	}
   1074          
   1075          #endif /* INCLUDE_uxTaskPriorityGet */
   1076          /*-----------------------------------------------------------*/
   1077          
   1078          #if ( INCLUDE_uxTaskPriorityGet == 1 )
   1079          

   \                                 In section .text, align 2, keep-with-next
   1080          	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
   1081          	{
   \                     uxTaskPriorityGetFromISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
   1082          	TCB_t *pxTCB;
   1083          	UBaseType_t uxReturn, uxSavedInterruptState;
   1084          
   1085          		/* RTOS ports that support interrupt nesting have the concept of a
   1086          		maximum	system call (or maximum API call) interrupt priority.
   1087          		Interrupts that are	above the maximum system call priority are keep
   1088          		permanently enabled, even when the RTOS kernel is in a critical section,
   1089          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1090          		is defined in freertos_cfg.h then
   1091          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1092          		failure if a FreeRTOS API function is called from an interrupt that has
   1093          		been assigned a priority above the configured maximum system call
   1094          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1095          		from interrupts	that have been assigned a priority at or (logically)
   1096          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1097          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1098          		simple as possible.  More information (albeit Cortex-M specific) is
   1099          		provided on the following link:
   1100          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1101          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1102          
   1103          		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
   \   00000004   0x.... 0x....      BL       ulSetInterruptMaskFromISR
   1104          		{
   1105          			/* If null is passed in here then it is the priority of the calling
   1106          			task that is being queried. */
   1107          			pxTCB = prvGetTCBFromHandle( xTask );
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE      ??uxTaskPriorityGetFromISR_0
   \   0000000C   0x....             LDR      R1,??DataTable6_1
   \   0000000E   0x680C             LDR      R4,[R1, #+0]
   1108          			uxReturn = pxTCB->uxPriority;
   \                     ??uxTaskPriorityGetFromISR_0: (+1)
   \   00000010   0x6AE4             LDR      R4,[R4, #+44]
   1109          		}
   1110          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
   \   00000012   0x.... 0x....      BL       vClearInterruptMaskFromISR
   1111          
   1112          		return uxReturn;
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   1113          	}
   1114          
   1115          #endif /* INCLUDE_uxTaskPriorityGet */
   1116          /*-----------------------------------------------------------*/
   1117          
   1118          #if ( INCLUDE_vTaskPrioritySet == 1 )
   1119          

   \                                 In section .text, align 4, keep-with-next
   1120          	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
   1121          	{
   \                     vTaskPrioritySet: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000F             MOVS     R7,R1
   1122          	TCB_t *pxTCB;
   1123          	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
   1124          	BaseType_t xYieldRequired = pdFALSE;
   \   00000008   0x2400             MOVS     R4,#+0
   1125          
   1126          		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
   \   0000000A   0x2F05             CMP      R7,#+5
   \   0000000C   0xD301             BCC      ??vTaskPrioritySet_0
   \   0000000E   0xB672             cpsid i
   \                     ??vTaskPrioritySet_1: (+1)
   \   00000010   0xE7FE             B        ??vTaskPrioritySet_1
   1127          
   1128          		/* Ensure the new priority is valid. */
   1129          		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   1130          		{
   1131          			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   1132          		}
   1133          		else
   1134          		{
   1135          			mtCOVERAGE_TEST_MARKER();
   1136          		}
   1137          
   1138          		taskENTER_CRITICAL();
   \                     ??vTaskPrioritySet_0: (+1)
   \   00000012   0x.... 0x....      BL       vPortEnterCritical
   1139          		{
   1140          			/* If null is passed in here then it is the priority of the calling
   1141          			task that is being changed. */
   1142          			pxTCB = prvGetTCBFromHandle( xTask );
   \   00000016   0x....             LDR      R6,??DataTable6_1
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD100             BNE      ??vTaskPrioritySet_2
   \   0000001C   0x6835             LDR      R5,[R6, #+0]
   1143          
   1144          			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
   1145          
   1146          			#if ( configUSE_MUTEXES == 1 )
   1147          			{
   1148          				uxCurrentBasePriority = pxTCB->uxBasePriority;
   1149          			}
   1150          			#else
   1151          			{
   1152          				uxCurrentBasePriority = pxTCB->uxPriority;
   \                     ??vTaskPrioritySet_2: (+1)
   \   0000001E   0x6AE8             LDR      R0,[R5, #+44]
   1153          			}
   1154          			#endif
   1155          
   1156          			if( uxCurrentBasePriority != uxNewPriority )
   \   00000020   0x42B8             CMP      R0,R7
   \   00000022   0xD02F             BEQ      ??vTaskPrioritySet_3
   1157          			{
   1158          				/* The priority change may have readied a task of higher
   1159          				priority than the calling task. */
   1160          				if( uxNewPriority > uxCurrentBasePriority )
   \   00000024   0x6831             LDR      R1,[R6, #+0]
   \   00000026   0xD206             BCS      ??vTaskPrioritySet_4
   1161          				{
   1162          					if( pxTCB != pxCurrentTCB )
   \   00000028   0x428D             CMP      R5,R1
   \   0000002A   0xD007             BEQ      ??vTaskPrioritySet_5
   1163          					{
   1164          						/* The priority of a task other than the currently
   1165          						running task is being raised.  Is the priority being
   1166          						raised above that of the running task? */
   1167          						if( uxNewPriority >= pxCurrentTCB->uxPriority )
   \   0000002C   0x6831             LDR      R1,[R6, #+0]
   \   0000002E   0x6AC9             LDR      R1,[R1, #+44]
   \   00000030   0x428F             CMP      R7,R1
   \   00000032   0xD303             BCC      ??vTaskPrioritySet_5
   1168          						{
   1169          							xYieldRequired = pdTRUE;
   \   00000034   0xE001             B        ??vTaskPrioritySet_6
   1170          						}
   1171          						else
   1172          						{
   1173          							mtCOVERAGE_TEST_MARKER();
   1174          						}
   1175          					}
   1176          					else
   1177          					{
   1178          						/* The priority of the running task is being raised,
   1179          						but the running task must already be the highest
   1180          						priority task able to run so no yield is required. */
   1181          					}
   1182          				}
   1183          				else if( pxTCB == pxCurrentTCB )
   \                     ??vTaskPrioritySet_4: (+1)
   \   00000036   0x428D             CMP      R5,R1
   \   00000038   0xD100             BNE      ??vTaskPrioritySet_5
   1184          				{
   1185          					/* Setting the priority of the running task down means
   1186          					there may now be another task of higher priority that
   1187          					is ready to execute. */
   1188          					xYieldRequired = pdTRUE;
   \                     ??vTaskPrioritySet_6: (+1)
   \   0000003A   0x2401             MOVS     R4,#+1
   1189          				}
   1190          				else
   1191          				{
   1192          					/* Setting the priority of any other task down does not
   1193          					require a yield as the running task must be above the
   1194          					new priority of the task being modified. */
   1195          				}
   1196          
   1197          				/* Remember the ready list the task might be referenced from
   1198          				before its uxPriority member is changed so the
   1199          				taskRESET_READY_PRIORITY() macro can function correctly. */
   1200          				uxPriorityUsedOnEntry = pxTCB->uxPriority;
   1201          
   1202          				#if ( configUSE_MUTEXES == 1 )
   1203          				{
   1204          					/* Only change the priority being used if the task is not
   1205          					currently using an inherited priority. */
   1206          					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
   1207          					{
   1208          						pxTCB->uxPriority = uxNewPriority;
   1209          					}
   1210          					else
   1211          					{
   1212          						mtCOVERAGE_TEST_MARKER();
   1213          					}
   1214          
   1215          					/* The base priority gets set whatever. */
   1216          					pxTCB->uxBasePriority = uxNewPriority;
   1217          				}
   1218          				#else
   1219          				{
   1220          					pxTCB->uxPriority = uxNewPriority;
   \                     ??vTaskPrioritySet_5: (+1)
   \   0000003C   0x62EF             STR      R7,[R5, #+44]
   1221          				}
   1222          				#endif
   1223          
   1224          				/* Only reset the event list item value if the value is not
   1225          				being used for anything else. */
   1226          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   \   0000003E   0x69A9             LDR      R1,[R5, #+24]
   \   00000040   0x2900             CMP      R1,#+0
   \   00000042   0xD402             BMI      ??vTaskPrioritySet_7
   1227          				{
   1228          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \   00000044   0x2105             MOVS     R1,#+5
   \   00000046   0x1BC9             SUBS     R1,R1,R7
   \   00000048   0x61A9             STR      R1,[R5, #+24]
   1229          				}
   1230          				else
   1231          				{
   1232          					mtCOVERAGE_TEST_MARKER();
   1233          				}
   1234          
   1235          				/* If the task is in the blocked or suspended list we need do
   1236          				nothing more than change it's priority variable. However, if
   1237          				the task is in a ready list it needs to be removed and placed
   1238          				in the list appropriate to its new priority. */
   1239          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   \                     ??vTaskPrioritySet_7: (+1)
   \   0000004A   0x6969             LDR      R1,[R5, #+20]
   \   0000004C   0x0082             LSLS     R2,R0,#+2
   \   0000004E   0x1810             ADDS     R0,R2,R0
   \   00000050   0x0080             LSLS     R0,R0,#+2
   \   00000052   0x1830             ADDS     R0,R6,R0
   \   00000054   0x1D00             ADDS     R0,R0,#+4
   \   00000056   0x4281             CMP      R1,R0
   \   00000058   0xD110             BNE      ??vTaskPrioritySet_8
   1240          				{
   1241          					/* The task is currently in its ready list - remove before adding
   1242          					it to it's new ready list.  As we are in a critical section we
   1243          					can do this even if the scheduler is suspended. */
   1244          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   \   0000005A   0x1D28             ADDS     R0,R5,#+4
   \   0000005C   0x.... 0x....      BL       uxListRemove
   1245          					{
   1246          						/* It is known that the task is in its ready list so
   1247          						there is no need to check again and the port level
   1248          						reset macro can be called directly. */
   1249          						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
   1250          					}
   1251          					else
   1252          					{
   1253          						mtCOVERAGE_TEST_MARKER();
   1254          					}
   1255          					prvAddTaskToReadyList( pxTCB );
   \   00000060   0x6AE8             LDR      R0,[R5, #+44]
   \   00000062   0x6F31             LDR      R1,[R6, #+112]
   \   00000064   0x4281             CMP      R1,R0
   \   00000066   0xD200             BCS      ??vTaskPrioritySet_9
   \   00000068   0x6730             STR      R0,[R6, #+112]
   \                     ??vTaskPrioritySet_9: (+1)
   \   0000006A   0x1D29             ADDS     R1,R5,#+4
   \   0000006C   0x6AE8             LDR      R0,[R5, #+44]
   \   0000006E   0x0082             LSLS     R2,R0,#+2
   \   00000070   0x1810             ADDS     R0,R2,R0
   \   00000072   0x0080             LSLS     R0,R0,#+2
   \   00000074   0x1830             ADDS     R0,R6,R0
   \   00000076   0x1D00             ADDS     R0,R0,#+4
   \   00000078   0x.... 0x....      BL       vListInsertEnd
   1256          				}
   1257          				else
   1258          				{
   1259          					mtCOVERAGE_TEST_MARKER();
   1260          				}
   1261          
   1262          				if( xYieldRequired == pdTRUE )
   \                     ??vTaskPrioritySet_8: (+1)
   \   0000007C   0x2C00             CMP      R4,#+0
   \   0000007E   0xD001             BEQ      ??vTaskPrioritySet_3
   1263          				{
   1264          					taskYIELD_IF_USING_PREEMPTION();
   \   00000080   0x.... 0x....      BL       vPortYield
   1265          				}
   1266          				else
   1267          				{
   1268          					mtCOVERAGE_TEST_MARKER();
   1269          				}
   1270          
   1271          				/* Remove compiler warning about unused variables when the port
   1272          				optimised task selection is not being used. */
   1273          				( void ) uxPriorityUsedOnEntry;
   1274          			}
   1275          		}
   1276          		taskEXIT_CRITICAL();
   \                     ??vTaskPrioritySet_3: (+1)
   \   00000084   0x.... 0x....      BL       vPortExitCritical
   1277          	}
   \   00000088   0xB001             ADD      SP,SP,#+4
   \   0000008A   0xBDF0             POP      {R4-R7,PC}       ;; return
   1278          
   1279          #endif /* INCLUDE_vTaskPrioritySet */
   1280          /*-----------------------------------------------------------*/
   1281          
   1282          #if ( INCLUDE_vTaskSuspend == 1 )
   1283          

   \                                 In section .text, align 4, keep-with-next
   1284          	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
   1285          	{
   \                     vTaskSuspend: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   1286          	TCB_t *pxTCB;
   1287          
   1288          		taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
   1289          		{
   1290          			/* If null is passed in here then it is the running task that is
   1291          			being suspended. */
   1292          			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
   \   00000008   0x....             LDR      R4,??DataTable17
   \   0000000A   0x2E00             CMP      R6,#+0
   \   0000000C   0xD100             BNE      ??vTaskSuspend_0
   \   0000000E   0x6826             LDR      R6,[R4, #+0]
   1293          
   1294          			traceTASK_SUSPEND( pxTCB );
   1295          
   1296          			/* Remove task from the ready/delayed list and place in the
   1297          			suspended list. */
   1298          			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   \                     ??vTaskSuspend_0: (+1)
   \   00000010   0x1D30             ADDS     R0,R6,#+4
   \   00000012   0x.... 0x....      BL       uxListRemove
   1299          			{
   1300          				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   1301          			}
   1302          			else
   1303          			{
   1304          				mtCOVERAGE_TEST_MARKER();
   1305          			}
   1306          
   1307          			/* Is the task waiting on an event also? */
   1308          			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \   00000016   0x6AB0             LDR      R0,[R6, #+40]
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD003             BEQ      ??vTaskSuspend_1
   1309          			{
   1310          				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \   0000001C   0x0030             MOVS     R0,R6
   \   0000001E   0x3018             ADDS     R0,R0,#+24
   \   00000020   0x.... 0x....      BL       uxListRemove
   1311          			}
   1312          			else
   1313          			{
   1314          				mtCOVERAGE_TEST_MARKER();
   1315          			}
   1316          
   1317          			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
   \                     ??vTaskSuspend_1: (+1)
   \   00000024   0x....             LDR      R5,??DataTable17_1
   \   00000026   0x1D31             ADDS     R1,R6,#+4
   \   00000028   0x0028             MOVS     R0,R5
   \   0000002A   0x3014             ADDS     R0,R0,#+20
   \   0000002C   0x.... 0x....      BL       vListInsertEnd
   1318          		}
   1319          		taskEXIT_CRITICAL();
   \   00000030   0x.... 0x....      BL       vPortExitCritical
   1320          
   1321          		if( pxTCB == pxCurrentTCB )
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x4286             CMP      R6,R0
   \   00000038   0x6B28             LDR      R0,[R5, #+48]
   \   0000003A   0xD114             BNE      ??vTaskSuspend_2
   1322          		{
   1323          			if( xSchedulerRunning != pdFALSE )
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD008             BEQ      ??vTaskSuspend_3
   1324          			{
   1325          				/* The current task has just been suspended. */
   1326          				configASSERT( uxSchedulerSuspended == 0 );
   \   00000040   0x3480             ADDS     R4,R4,#+128
   \   00000042   0x6820             LDR      R0,[R4, #+0]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xD001             BEQ      ??vTaskSuspend_4
   \   00000048   0xB672             cpsid i
   \                     ??vTaskSuspend_5: (+1)
   \   0000004A   0xE7FE             B        ??vTaskSuspend_5
   1327          				portYIELD_WITHIN_API();
   \                     ??vTaskSuspend_4: (+1)
   \   0000004C   0x.... 0x....      BL       vPortYield
   \   00000050   0xBD70             POP      {R4-R6,PC}
   1328          			}
   1329          			else
   1330          			{
   1331          				/* The scheduler is not running, but the task that was pointed
   1332          				to by pxCurrentTCB has just been suspended and pxCurrentTCB
   1333          				must be adjusted to point to a different task. */
   1334          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
   \                     ??vTaskSuspend_3: (+1)
   \   00000052   0x6968             LDR      R0,[R5, #+20]
   \   00000054   0x6AA9             LDR      R1,[R5, #+40]
   \   00000056   0x4288             CMP      R0,R1
   \   00000058   0xD102             BNE      ??vTaskSuspend_6
   1335          				{
   1336          					/* No other tasks are ready, so set pxCurrentTCB back to
   1337          					NULL so when the next task is created pxCurrentTCB will
   1338          					be set to point to it no matter what its relative priority
   1339          					is. */
   1340          					pxCurrentTCB = NULL;
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0x6020             STR      R0,[R4, #+0]
   \   0000005E   0xBD70             POP      {R4-R6,PC}
   1341          				}
   1342          				else
   1343          				{
   1344          					vTaskSwitchContext();
   \                     ??vTaskSuspend_6: (+1)
   \   00000060   0x.... 0x....      BL       vTaskSwitchContext
   \   00000064   0xBD70             POP      {R4-R6,PC}
   1345          				}
   1346          			}
   1347          		}
   1348          		else
   1349          		{
   1350          			if( xSchedulerRunning != pdFALSE )
   \                     ??vTaskSuspend_2: (+1)
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD00F             BEQ      ??vTaskSuspend_7
   1351          			{
   1352          				/* A task other than the currently running task was suspended,
   1353          				reset the next expected unblock time in case it referred to the
   1354          				task that is now in the Suspended state. */
   1355          				taskENTER_CRITICAL();
   \   0000006A   0x.... 0x....      BL       vPortEnterCritical
   1356          				{
   1357          					prvResetNextTaskUnblockTime();
   \   0000006E   0x6EA0             LDR      R0,[R4, #+104]
   \   00000070   0x6800             LDR      R0,[R0, #+0]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD102             BNE      ??vTaskSuspend_8
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x43C0             MVNS     R0,R0            ;; #-1
   \   0000007A   0xE003             B        ??vTaskSuspend_9
   \                     ??vTaskSuspend_8: (+1)
   \   0000007C   0x6EA0             LDR      R0,[R4, #+104]
   \   0000007E   0x68C0             LDR      R0,[R0, #+12]
   \   00000080   0x68C0             LDR      R0,[R0, #+12]
   \   00000082   0x6840             LDR      R0,[R0, #+4]
   \                     ??vTaskSuspend_9: (+1)
   \   00000084   0x67E0             STR      R0,[R4, #+124]
   1358          				}
   1359          				taskEXIT_CRITICAL();
   \   00000086   0x.... 0x....      BL       vPortExitCritical
   1360          			}
   1361          			else
   1362          			{
   1363          				mtCOVERAGE_TEST_MARKER();
   1364          			}
   1365          		}
   1366          	}
   \                     ??vTaskSuspend_7: (+1)
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
   1367          
   1368          #endif /* INCLUDE_vTaskSuspend */
   1369          /*-----------------------------------------------------------*/
   1370          
   1371          #if ( INCLUDE_vTaskSuspend == 1 )
   1372          

   \                                 In section .text, align 4, keep-with-next
   1373          	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
   1374          	{
   \                     prvTaskIsTaskSuspended: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0002             MOVS     R2,R0
   1375          	BaseType_t xReturn = pdFALSE;
   \   00000004   0x2100             MOVS     R1,#+0
   1376          	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
   1377          
   1378          		/* Accesses xPendingReadyList so must be called from a critical
   1379          		section. */
   1380          
   1381          		/* It does not make sense to check if the calling task is suspended. */
   1382          		configASSERT( xTask );
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD101             BNE      ??prvTaskIsTaskSuspended_0
   \   0000000A   0xB672             cpsid i
   \                     ??prvTaskIsTaskSuspended_1: (+1)
   \   0000000C   0xE7FE             B        ??prvTaskIsTaskSuspended_1
   1383          
   1384          		/* Is the task being resumed actually in the suspended list? */
   1385          		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
   \                     ??prvTaskIsTaskSuspended_0: (+1)
   \   0000000E   0x....             LDR      R3,??DataTable17_1
   \   00000010   0x6954             LDR      R4,[R2, #+20]
   \   00000012   0x0018             MOVS     R0,R3
   \   00000014   0x3014             ADDS     R0,R0,#+20
   \   00000016   0x4284             CMP      R4,R0
   \   00000018   0xD105             BNE      ??prvTaskIsTaskSuspended_2
   1386          		{
   1387          			/* Has the task already been resumed from within an ISR? */
   1388          			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
   \   0000001A   0x6A90             LDR      R0,[R2, #+40]
   \   0000001C   0x4298             CMP      R0,R3
   \   0000001E   0xD002             BEQ      ??prvTaskIsTaskSuspended_2
   1389          			{
   1390          				/* Is it in the suspended list because it is in the	Suspended
   1391          				state, or because is is blocked with no timeout? */
   1392          				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD100             BNE      ??prvTaskIsTaskSuspended_2
   1393          				{
   1394          					xReturn = pdTRUE;
   \   00000024   0x2101             MOVS     R1,#+1
   1395          				}
   1396          				else
   1397          				{
   1398          					mtCOVERAGE_TEST_MARKER();
   1399          				}
   1400          			}
   1401          			else
   1402          			{
   1403          				mtCOVERAGE_TEST_MARKER();
   1404          			}
   1405          		}
   1406          		else
   1407          		{
   1408          			mtCOVERAGE_TEST_MARKER();
   1409          		}
   1410          
   1411          		return xReturn;
   \                     ??prvTaskIsTaskSuspended_2: (+1)
   \   00000026   0x0008             MOVS     R0,R1
   \   00000028   0xBC10             POP      {R4}
   \   0000002A   0x4770             BX       LR               ;; return
   1412          	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
   1413          
   1414          #endif /* INCLUDE_vTaskSuspend */
   1415          /*-----------------------------------------------------------*/
   1416          
   1417          #if ( INCLUDE_vTaskSuspend == 1 )
   1418          

   \                                 In section .text, align 4, keep-with-next
   1419          	void vTaskResume( TaskHandle_t xTaskToResume )
   1420          	{
   \                     vTaskResume: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0004             MOVS     R4,R0
   1421          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1422          
   1423          		/* It does not make sense to resume the calling task. */
   1424          		configASSERT( xTaskToResume );
   \   00000006   0x2C00             CMP      R4,#+0
   \   00000008   0xD101             BNE      ??vTaskResume_0
   \   0000000A   0xB672             cpsid i
   \                     ??vTaskResume_1: (+1)
   \   0000000C   0xE7FE             B        ??vTaskResume_1
   1425          
   1426          		/* The parameter cannot be NULL as it is impossible to resume the
   1427          		currently executing task. */
   1428          		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
   \                     ??vTaskResume_0: (+1)
   \   0000000E   0x....             LDR      R5,??DataTable17
   \   00000010   0x6828             LDR      R0,[R5, #+0]
   \   00000012   0x4284             CMP      R4,R0
   \   00000014   0xD01F             BEQ      ??vTaskResume_2
   1429          		{
   1430          			taskENTER_CRITICAL();
   \   00000016   0x.... 0x....      BL       vPortEnterCritical
   1431          			{
   1432          				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       prvTaskIsTaskSuspended
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD116             BNE      ??vTaskResume_3
   1433          				{
   1434          					traceTASK_RESUME( pxTCB );
   1435          
   1436          					/* As we are in a critical section we can access the ready
   1437          					lists even if the scheduler is suspended. */
   1438          					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
   \   00000024   0x1D20             ADDS     R0,R4,#+4
   \   00000026   0x.... 0x....      BL       uxListRemove
   1439          					prvAddTaskToReadyList( pxTCB );
   \   0000002A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002C   0x6F29             LDR      R1,[R5, #+112]
   \   0000002E   0x4281             CMP      R1,R0
   \   00000030   0xD200             BCS      ??vTaskResume_4
   \   00000032   0x6728             STR      R0,[R5, #+112]
   \                     ??vTaskResume_4: (+1)
   \   00000034   0x1D21             ADDS     R1,R4,#+4
   \   00000036   0x0082             LSLS     R2,R0,#+2
   \   00000038   0x1810             ADDS     R0,R2,R0
   \   0000003A   0x0080             LSLS     R0,R0,#+2
   \   0000003C   0x1828             ADDS     R0,R5,R0
   \   0000003E   0x1D00             ADDS     R0,R0,#+4
   \   00000040   0x.... 0x....      BL       vListInsertEnd
   1440          
   1441          					/* We may have just resumed a higher priority task. */
   1442          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \   00000044   0x6AE0             LDR      R0,[R4, #+44]
   \   00000046   0x6829             LDR      R1,[R5, #+0]
   \   00000048   0x6AC9             LDR      R1,[R1, #+44]
   \   0000004A   0x4288             CMP      R0,R1
   \   0000004C   0xD301             BCC      ??vTaskResume_3
   1443          					{
   1444          						/* This yield may not cause the task just resumed to run,
   1445          						but will leave the lists in the correct state for the
   1446          						next yield. */
   1447          						taskYIELD_IF_USING_PREEMPTION();
   \   0000004E   0x.... 0x....      BL       vPortYield
   1448          					}
   1449          					else
   1450          					{
   1451          						mtCOVERAGE_TEST_MARKER();
   1452          					}
   1453          				}
   1454          				else
   1455          				{
   1456          					mtCOVERAGE_TEST_MARKER();
   1457          				}
   1458          			}
   1459          			taskEXIT_CRITICAL();
   \                     ??vTaskResume_3: (+1)
   \   00000052   0x.... 0x....      BL       vPortExitCritical
   1460          		}
   1461          		else
   1462          		{
   1463          			mtCOVERAGE_TEST_MARKER();
   1464          		}
   1465          	}
   \                     ??vTaskResume_2: (+1)
   \   00000056   0xB001             ADD      SP,SP,#+4
   \   00000058   0xBD30             POP      {R4,R5,PC}       ;; return
   1466          
   1467          #endif /* INCLUDE_vTaskSuspend */
   1468          
   1469          /*-----------------------------------------------------------*/
   1470          
   1471          #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
   1472          

   \                                 In section .text, align 4, keep-with-next
   1473          	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
   1474          	{
   \                     xTaskResumeFromISR: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0006             MOVS     R6,R0
   1475          	BaseType_t xYieldRequired = pdFALSE;
   \   00000006   0x2400             MOVS     R4,#+0
   1476          	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
   1477          	UBaseType_t uxSavedInterruptStatus;
   1478          
   1479          		configASSERT( xTaskToResume );
   \   00000008   0x2E00             CMP      R6,#+0
   \   0000000A   0xD101             BNE      ??xTaskResumeFromISR_0
   \   0000000C   0xB672             cpsid i
   \                     ??xTaskResumeFromISR_1: (+1)
   \   0000000E   0xE7FE             B        ??xTaskResumeFromISR_1
   1480          
   1481          		/* RTOS ports that support interrupt nesting have the concept of a
   1482          		maximum	system call (or maximum API call) interrupt priority.
   1483          		Interrupts that are	above the maximum system call priority are keep
   1484          		permanently enabled, even when the RTOS kernel is in a critical section,
   1485          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   1486          		is defined in freertos_cfg.h then
   1487          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1488          		failure if a FreeRTOS API function is called from an interrupt that has
   1489          		been assigned a priority above the configured maximum system call
   1490          		priority.  Only FreeRTOS functions that end in FromISR can be called
   1491          		from interrupts	that have been assigned a priority at or (logically)
   1492          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   1493          		separate interrupt safe API to ensure interrupt entry is as fast and as
   1494          		simple as possible.  More information (albeit Cortex-M specific) is
   1495          		provided on the following link:
   1496          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1497          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1498          
   1499          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??xTaskResumeFromISR_0: (+1)
   \   00000010   0x.... 0x....      BL       ulSetInterruptMaskFromISR
   \   00000014   0x0007             MOVS     R7,R0
   1500          		{
   1501          			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
   \   00000016   0x0030             MOVS     R0,R6
   \   00000018   0x.... 0x....      BL       prvTaskIsTaskSuspended
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD11E             BNE      ??xTaskResumeFromISR_2
   1502          			{
   1503          				traceTASK_RESUME_FROM_ISR( pxTCB );
   1504          
   1505          				/* Check the ready lists can be accessed. */
   1506          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \   00000020   0x....             LDR      R5,??DataTable17
   \   00000022   0x2080             MOVS     R0,#+128
   \   00000024   0x5828             LDR      R0,[R5, R0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD114             BNE      ??xTaskResumeFromISR_3
   1507          				{
   1508          					/* Ready lists can be accessed so move the task from the
   1509          					suspended list to the ready list directly. */
   1510          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \   0000002A   0x6AF0             LDR      R0,[R6, #+44]
   \   0000002C   0x6829             LDR      R1,[R5, #+0]
   \   0000002E   0x6AC9             LDR      R1,[R1, #+44]
   \   00000030   0x4288             CMP      R0,R1
   \   00000032   0xD300             BCC      ??xTaskResumeFromISR_4
   1511          					{
   1512          						xYieldRequired = pdTRUE;
   \   00000034   0x2401             MOVS     R4,#+1
   1513          					}
   1514          					else
   1515          					{
   1516          						mtCOVERAGE_TEST_MARKER();
   1517          					}
   1518          
   1519          					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
   \                     ??xTaskResumeFromISR_4: (+1)
   \   00000036   0x1D30             ADDS     R0,R6,#+4
   \   00000038   0x.... 0x....      BL       uxListRemove
   1520          					prvAddTaskToReadyList( pxTCB );
   \   0000003C   0x6AF0             LDR      R0,[R6, #+44]
   \   0000003E   0x6F29             LDR      R1,[R5, #+112]
   \   00000040   0x4281             CMP      R1,R0
   \   00000042   0xD200             BCS      ??xTaskResumeFromISR_5
   \   00000044   0x6728             STR      R0,[R5, #+112]
   \                     ??xTaskResumeFromISR_5: (+1)
   \   00000046   0x1D31             ADDS     R1,R6,#+4
   \   00000048   0x0082             LSLS     R2,R0,#+2
   \   0000004A   0x1810             ADDS     R0,R2,R0
   \   0000004C   0x0080             LSLS     R0,R0,#+2
   \   0000004E   0x1828             ADDS     R0,R5,R0
   \   00000050   0x1D00             ADDS     R0,R0,#+4
   \   00000052   0xE002             B        ??xTaskResumeFromISR_6
   1521          				}
   1522          				else
   1523          				{
   1524          					/* The delayed or ready lists cannot be accessed so the task
   1525          					is held in the pending ready list until the scheduler is
   1526          					unsuspended. */
   1527          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   \                     ??xTaskResumeFromISR_3: (+1)
   \   00000054   0x3618             ADDS     R6,R6,#+24
   \   00000056   0x0031             MOVS     R1,R6
   \   00000058   0x....             LDR      R0,??DataTable17_1
   \                     ??xTaskResumeFromISR_6: (+1)
   \   0000005A   0x.... 0x....      BL       vListInsertEnd
   1528          				}
   1529          			}
   1530          			else
   1531          			{
   1532          				mtCOVERAGE_TEST_MARKER();
   1533          			}
   1534          		}
   1535          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xTaskResumeFromISR_2: (+1)
   \   0000005E   0x0038             MOVS     R0,R7
   \   00000060   0x.... 0x....      BL       vClearInterruptMaskFromISR
   1536          
   1537          		return xYieldRequired;
   \   00000064   0x0020             MOVS     R0,R4
   \   00000066   0xB001             ADD      SP,SP,#+4
   \   00000068   0xBDF0             POP      {R4-R7,PC}       ;; return
   1538          	}
   1539          
   1540          #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
   1541          /*-----------------------------------------------------------*/
   1542          

   \                                 In section .text, align 4, keep-with-next
   1543          void vTaskStartScheduler( void )
   1544          {
   \                     vTaskStartScheduler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   1545          BaseType_t xReturn;
   1546          
   1547          	/* Add the idle task at the lowest priority. */
   1548          	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1549          	{
   1550          		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
   1551          		be returned by the xTaskGetIdleTaskHandle() function. */
   1552          		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   1553          	}
   1554          	#else
   1555          	{
   1556          		/* Create the idle task without storing its handle. */
   1557          		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x9003             STR      R0,[SP, #+12]
   \   00000008   0x9002             STR      R0,[SP, #+8]
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x2280             MOVS     R2,#+128
   \   00000012   0xBF00             Nop      
   \   00000014   0x....             ADR.N    R1,?_0
   \   00000016   0x....             LDR      R0,??DataTable20
   \   00000018   0x.... 0x....      BL       xTaskGenericCreate
   1558          	}
   1559          	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
   1560          
   1561          	#if ( configUSE_TIMERS == 1 )
   1562          	{
   1563          		if( xReturn == pdPASS )
   \   0000001C   0x2801             CMP      R0,#+1
   \   0000001E   0xD101             BNE      ??vTaskStartScheduler_0
   1564          		{
   1565          			xReturn = xTimerCreateTimerTask();
   \   00000020   0x.... 0x....      BL       xTimerCreateTimerTask
   1566          		}
   1567          		else
   1568          		{
   1569          			mtCOVERAGE_TEST_MARKER();
   1570          		}
   1571          	}
   1572          	#endif /* configUSE_TIMERS */
   1573          
   1574          	if( xReturn == pdPASS )
   \                     ??vTaskStartScheduler_0: (+1)
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD109             BNE      ??vTaskStartScheduler_1
   1575          	{
   1576          		/* Interrupts are turned off here, to ensure a tick does not occur
   1577          		before or during the call to xPortStartScheduler().  The stacks of
   1578          		the created tasks contain a status word with interrupts switched on
   1579          		so interrupts will automatically get re-enabled when the first task
   1580          		starts to run. */
   1581          		portDISABLE_INTERRUPTS();
   \   00000028   0xB672             cpsid i
   1582          
   1583          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   1584          		{
   1585          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   1586          			structure specific to the task that will run first. */
   1587          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   1588          		}
   1589          		#endif /* configUSE_NEWLIB_REENTRANT */
   1590          
   1591          		xSchedulerRunning = pdTRUE;
   \   0000002A   0x....             LDR      R0,??DataTable17_1
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x6301             STR      R1,[R0, #+48]
   1592          		xTickCount = ( TickType_t ) 0U;
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x62C1             STR      R1,[R0, #+44]
   1593          
   1594          		/* If configGENERATE_RUN_TIME_STATS is defined then the following
   1595          		macro must be defined to configure the timer/counter used to generate
   1596          		the run time counter time base. */
   1597          		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
   1598          
   1599          		/* Setting up the timer tick is hardware specific and thus in the
   1600          		portable interface. */
   1601          		if( xPortStartScheduler() != pdFALSE )
   \   00000034   0x.... 0x....      BL       xPortStartScheduler
   1602          		{
   1603          			/* Should not reach here as if the scheduler is running the
   1604          			function will not return. */
   1605          		}
   1606          		else
   1607          		{
   1608          			/* Should only reach here if a task calls xTaskEndScheduler(). */
   1609          		}
   1610          	}
   1611          	else
   1612          	{
   1613          		/* This line will only be reached if the kernel could not be started,
   1614          		because there was not enough FreeRTOS heap to create the idle task
   1615          		or the timer task. */
   1616          		configASSERT( xReturn );
   1617          	}
   1618          }
   \                     ??vTaskStartScheduler_2: (+1)
   \   00000038   0xB005             ADD      SP,SP,#+20
   \   0000003A   0xBD00             POP      {PC}             ;; return
   \                     ??vTaskStartScheduler_1: (+1)
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD1FB             BNE      ??vTaskStartScheduler_2
   \   00000040   0xB672             cpsid i
   \                     ??vTaskStartScheduler_3: (+1)
   \   00000042   0xE7FE             B        ??vTaskStartScheduler_3
   1619          /*-----------------------------------------------------------*/
   1620          

   \                                 In section .text, align 4, keep-with-next
   1621          void vTaskEndScheduler( void )
   1622          {
   \                     vTaskEndScheduler: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1623          	/* Stop the scheduler interrupts and call the portable scheduler end
   1624          	routine so the original ISRs can be restored if necessary.  The port
   1625          	layer must ensure interrupts enable	bit is left in the correct state. */
   1626          	portDISABLE_INTERRUPTS();
   \   00000004   0xB672             cpsid i
   1627          	xSchedulerRunning = pdFALSE;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x....             LDR      R1,??DataTable17_1
   \   0000000A   0x6308             STR      R0,[R1, #+48]
   1628          	vPortEndScheduler();
   \   0000000C   0x.... 0x....      BL       vPortEndScheduler
   1629          }
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBD00             POP      {PC}             ;; return
   1630          /*----------------------------------------------------------*/
   1631          

   \                                 In section .text, align 2, keep-with-next
   1632          void vTaskSuspendAll( void )
   1633          {
   1634          	/* A critical section is not required as the variable is of type
   1635          	BaseType_t.  Please read Richard Barry's reply in the following link to a
   1636          	post in the FreeRTOS support forum before reporting this as a bug! -
   1637          	http://goo.gl/wu4acr */
   1638          	++uxSchedulerSuspended;
   \                     vTaskSuspendAll: (+1)
   \   00000000   0x....             LDR      R0,??DataTable21
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \   00000006   0x6001             STR      R1,[R0, #+0]
   1639          }
   \   00000008   0x4770             BX       LR               ;; return
   1640          /*----------------------------------------------------------*/
   1641          
   1642          #if ( configUSE_TICKLESS_IDLE != 0 )
   1643          
   1644          	static TickType_t prvGetExpectedIdleTime( void )
   1645          	{
   1646          	TickType_t xReturn;
   1647          
   1648          		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
   1649          		{
   1650          			xReturn = 0;
   1651          		}
   1652          		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
   1653          		{
   1654          			/* There are other idle priority tasks in the ready state.  If
   1655          			time slicing is used then the very next tick interrupt must be
   1656          			processed. */
   1657          			xReturn = 0;
   1658          		}
   1659          		else
   1660          		{
   1661          			xReturn = xNextTaskUnblockTime - xTickCount;
   1662          		}
   1663          
   1664          		return xReturn;
   1665          	}
   1666          
   1667          #endif /* configUSE_TICKLESS_IDLE */
   1668          /*----------------------------------------------------------*/
   1669          

   \                                 In section .text, align 4, keep-with-next
   1670          BaseType_t xTaskResumeAll( void )
   1671          {
   \                     xTaskResumeAll: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1672          TCB_t *pxTCB;
   1673          BaseType_t xAlreadyYielded = pdFALSE;
   \   00000004   0x2700             MOVS     R7,#+0
   1674          
   1675          	/* If uxSchedulerSuspended is zero then this function does not match a
   1676          	previous call to vTaskSuspendAll(). */
   1677          	configASSERT( uxSchedulerSuspended );
   \   00000006   0x....             LDR      R4,??DataTable17
   \   00000008   0x0025             MOVS     R5,R4
   \   0000000A   0x3580             ADDS     R5,R5,#+128
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD101             BNE      ??xTaskResumeAll_0
   \   00000012   0xB672             cpsid i
   \                     ??xTaskResumeAll_1: (+1)
   \   00000014   0xE7FE             B        ??xTaskResumeAll_1
   1678          
   1679          	/* It is possible that an ISR caused a task to be removed from an event
   1680          	list while the scheduler was suspended.  If this was the case then the
   1681          	removed task will have been added to the xPendingReadyList.  Once the
   1682          	scheduler has been resumed it is safe to move all the pending ready
   1683          	tasks from this list into their appropriate ready list. */
   1684          	taskENTER_CRITICAL();
   \                     ??xTaskResumeAll_0: (+1)
   \   00000016   0x.... 0x....      BL       vPortEnterCritical
   1685          	{
   1686          		--uxSchedulerSuspended;
   \   0000001A   0x6828             LDR      R0,[R5, #+0]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x6028             STR      R0,[R5, #+0]
   1687          
   1688          		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \   00000020   0x6828             LDR      R0,[R5, #+0]
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD13B             BNE      ??xTaskResumeAll_2
   1689          		{
   1690          			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   \   00000026   0x....             LDR      R6,??DataTable17_1
   \   00000028   0x6AB0             LDR      R0,[R6, #+40]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD11E             BNE      ??xTaskResumeAll_3
   \   0000002E   0xE036             B        ??xTaskResumeAll_2
   1691          			{
   1692          				/* Move any readied tasks from the pending list into the
   1693          				appropriate ready list. */
   1694          				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   1695          				{
   1696          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   \                     ??xTaskResumeAll_4: (+1)
   \   00000030   0x68F0             LDR      R0,[R6, #+12]
   \   00000032   0x68C5             LDR      R5,[R0, #+12]
   1697          					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \   00000034   0x0028             MOVS     R0,R5
   \   00000036   0x3018             ADDS     R0,R0,#+24
   \   00000038   0x.... 0x....      BL       uxListRemove
   1698          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   \   0000003C   0x1D28             ADDS     R0,R5,#+4
   \   0000003E   0x.... 0x....      BL       uxListRemove
   1699          					prvAddTaskToReadyList( pxTCB );
   \   00000042   0x6AE8             LDR      R0,[R5, #+44]
   \   00000044   0x6F21             LDR      R1,[R4, #+112]
   \   00000046   0x4281             CMP      R1,R0
   \   00000048   0xD200             BCS      ??xTaskResumeAll_5
   \   0000004A   0x6720             STR      R0,[R4, #+112]
   \                     ??xTaskResumeAll_5: (+1)
   \   0000004C   0x1D29             ADDS     R1,R5,#+4
   \   0000004E   0x6AE8             LDR      R0,[R5, #+44]
   \   00000050   0x0082             LSLS     R2,R0,#+2
   \   00000052   0x1810             ADDS     R0,R2,R0
   \   00000054   0x0080             LSLS     R0,R0,#+2
   \   00000056   0x1820             ADDS     R0,R4,R0
   \   00000058   0x1D00             ADDS     R0,R0,#+4
   \   0000005A   0x.... 0x....      BL       vListInsertEnd
   1700          
   1701          					/* If the moved task has a priority higher than the current
   1702          					task then a yield must be performed. */
   1703          					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \   0000005E   0x6AE8             LDR      R0,[R5, #+44]
   \   00000060   0x6821             LDR      R1,[R4, #+0]
   \   00000062   0x6AC9             LDR      R1,[R1, #+44]
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xD301             BCC      ??xTaskResumeAll_3
   1704          					{
   1705          						xYieldPending = pdTRUE;
   \   00000068   0x2001             MOVS     R0,#+1
   \   0000006A   0x6760             STR      R0,[R4, #+116]
   1706          					}
   1707          					else
   1708          					{
   1709          						mtCOVERAGE_TEST_MARKER();
   1710          					}
   1711          				}
   \                     ??xTaskResumeAll_3: (+1)
   \   0000006C   0x6830             LDR      R0,[R6, #+0]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD1DE             BNE      ??xTaskResumeAll_4
   1712          
   1713          				/* If any ticks occurred while the scheduler was suspended then
   1714          				they should be processed now.  This ensures the tick count does
   1715          				not	slip, and that any delayed tasks are resumed at the correct
   1716          				time. */
   1717          				if( uxPendedTicks > ( UBaseType_t ) 0U )
   \   00000072   0x6B70             LDR      R0,[R6, #+52]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD109             BNE      ??xTaskResumeAll_6
   \   00000078   0xE00B             B        ??xTaskResumeAll_7
   1718          				{
   1719          					while( uxPendedTicks > ( UBaseType_t ) 0U )
   1720          					{
   1721          						if( xTaskIncrementTick() != pdFALSE )
   \                     ??xTaskResumeAll_8: (+1)
   \   0000007A   0x.... 0x....      BL       xTaskIncrementTick
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD001             BEQ      ??xTaskResumeAll_9
   1722          						{
   1723          							xYieldPending = pdTRUE;
   \   00000082   0x2001             MOVS     R0,#+1
   \   00000084   0x6760             STR      R0,[R4, #+116]
   1724          						}
   1725          						else
   1726          						{
   1727          							mtCOVERAGE_TEST_MARKER();
   1728          						}
   1729          						--uxPendedTicks;
   \                     ??xTaskResumeAll_9: (+1)
   \   00000086   0x6B70             LDR      R0,[R6, #+52]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0x6370             STR      R0,[R6, #+52]
   1730          					}
   \                     ??xTaskResumeAll_6: (+1)
   \   0000008C   0x6B70             LDR      R0,[R6, #+52]
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD1F3             BNE      ??xTaskResumeAll_8
   1731          				}
   1732          				else
   1733          				{
   1734          					mtCOVERAGE_TEST_MARKER();
   1735          				}
   1736          
   1737          				if( xYieldPending == pdTRUE )
   \                     ??xTaskResumeAll_7: (+1)
   \   00000092   0x6F60             LDR      R0,[R4, #+116]
   \   00000094   0x2801             CMP      R0,#+1
   \   00000096   0xD102             BNE      ??xTaskResumeAll_2
   1738          				{
   1739          					#if( configUSE_PREEMPTION != 0 )
   1740          					{
   1741          						xAlreadyYielded = pdTRUE;
   \   00000098   0x2701             MOVS     R7,#+1
   1742          					}
   1743          					#endif
   1744          					taskYIELD_IF_USING_PREEMPTION();
   \   0000009A   0x.... 0x....      BL       vPortYield
   1745          				}
   1746          				else
   1747          				{
   1748          					mtCOVERAGE_TEST_MARKER();
   1749          				}
   1750          			}
   1751          		}
   1752          		else
   1753          		{
   1754          			mtCOVERAGE_TEST_MARKER();
   1755          		}
   1756          	}
   1757          	taskEXIT_CRITICAL();
   \                     ??xTaskResumeAll_2: (+1)
   \   0000009E   0x.... 0x....      BL       vPortExitCritical
   1758          
   1759          	return xAlreadyYielded;
   \   000000A2   0x0038             MOVS     R0,R7
   \   000000A4   0xB001             ADD      SP,SP,#+4
   \   000000A6   0xBDF0             POP      {R4-R7,PC}       ;; return
   1760          }
   1761          /*-----------------------------------------------------------*/
   1762          

   \                                 In section .text, align 2, keep-with-next
   1763          TickType_t xTaskGetTickCount( void )
   1764          {
   1765          TickType_t xTicks;
   1766          
   1767          	/* Critical section required if running on a 16 bit processor. */
   1768          	portTICK_TYPE_ENTER_CRITICAL();
   1769          	{
   1770          		xTicks = xTickCount;
   1771          	}
   1772          	portTICK_TYPE_EXIT_CRITICAL();
   1773          
   1774          	return xTicks;
   \                     xTaskGetTickCount: (+1)
   \   00000000   0x....             LDR      R0,??DataTable23
   \   00000002   0x6AC0             LDR      R0,[R0, #+44]
   \   00000004   0x4770             BX       LR               ;; return
   1775          }
   1776          /*-----------------------------------------------------------*/
   1777          

   \                                 In section .text, align 2, keep-with-next
   1778          TickType_t xTaskGetTickCountFromISR( void )
   1779          {
   1780          TickType_t xReturn;
   1781          UBaseType_t uxSavedInterruptStatus;
   1782          
   1783          	/* RTOS ports that support interrupt nesting have the concept of a maximum
   1784          	system call (or maximum API call) interrupt priority.  Interrupts that are
   1785          	above the maximum system call priority are kept permanently enabled, even
   1786          	when the RTOS kernel is in a critical section, but cannot make any calls to
   1787          	FreeRTOS API functions.  If configASSERT() is defined in freertos_cfg.h
   1788          	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   1789          	failure if a FreeRTOS API function is called from an interrupt that has been
   1790          	assigned a priority above the configured maximum system call priority.
   1791          	Only FreeRTOS functions that end in FromISR can be called from interrupts
   1792          	that have been assigned a priority at or (logically) below the maximum
   1793          	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
   1794          	safe API to ensure interrupt entry is as fast and as simple as possible.
   1795          	More information (albeit Cortex-M specific) is provided on the following
   1796          	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   1797          	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   1798          
   1799          	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
   1800          	{
   1801          		xReturn = xTickCount;
   1802          	}
   1803          	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   1804          
   1805          	return xReturn;
   \                     xTaskGetTickCountFromISR: (+1)
   \   00000000   0x....             LDR      R0,??DataTable23
   \   00000002   0x6AC0             LDR      R0,[R0, #+44]
   \   00000004   0x4770             BX       LR               ;; return
   1806          }
   1807          /*-----------------------------------------------------------*/
   1808          

   \                                 In section .text, align 2, keep-with-next
   1809          UBaseType_t uxTaskGetNumberOfTasks( void )
   1810          {
   1811          	/* A critical section is not required because the variables are of type
   1812          	BaseType_t. */
   1813          	return uxCurrentNumberOfTasks;
   \                     uxTaskGetNumberOfTasks: (+1)
   \   00000000   0x....             LDR      R0,??DataTable23
   \   00000002   0x6A80             LDR      R0,[R0, #+40]
   \   00000004   0x4770             BX       LR               ;; return
   1814          }
   1815          /*-----------------------------------------------------------*/
   1816          
   1817          #if ( INCLUDE_pcTaskGetTaskName == 1 )
   1818          
   1819          	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   1820          	{
   1821          	TCB_t *pxTCB;
   1822          
   1823          		/* If null is passed in here then the name of the calling task is being queried. */
   1824          		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   1825          		configASSERT( pxTCB );
   1826          		return &( pxTCB->pcTaskName[ 0 ] );
   1827          	}
   1828          
   1829          #endif /* INCLUDE_pcTaskGetTaskName */
   1830          /*-----------------------------------------------------------*/
   1831          
   1832          #if ( configUSE_TRACE_FACILITY == 1 )
   1833          
   1834          	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
   1835          	{
   1836          	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
   1837          
   1838          		vTaskSuspendAll();
   1839          		{
   1840          			/* Is there a space in the array for each task in the system? */
   1841          			if( uxArraySize >= uxCurrentNumberOfTasks )
   1842          			{
   1843          				/* Fill in an TaskStatus_t structure with information on each
   1844          				task in the Ready state. */
   1845          				do
   1846          				{
   1847          					uxQueue--;
   1848          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
   1849          
   1850          				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   1851          
   1852          				/* Fill in an TaskStatus_t structure with information on each
   1853          				task in the Blocked state. */
   1854          				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
   1855          				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
   1856          
   1857          				#if( INCLUDE_vTaskDelete == 1 )
   1858          				{
   1859          					/* Fill in an TaskStatus_t structure with information on
   1860          					each task that has been deleted but not yet cleaned up. */
   1861          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
   1862          				}
   1863          				#endif
   1864          
   1865          				#if ( INCLUDE_vTaskSuspend == 1 )
   1866          				{
   1867          					/* Fill in an TaskStatus_t structure with information on
   1868          					each task in the Suspended state. */
   1869          					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
   1870          				}
   1871          				#endif
   1872          
   1873          				#if ( configGENERATE_RUN_TIME_STATS == 1)
   1874          				{
   1875          					if( pulTotalRunTime != NULL )
   1876          					{
   1877          						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   1878          							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
   1879          						#else
   1880          							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   1881          						#endif
   1882          					}
   1883          				}
   1884          				#else
   1885          				{
   1886          					if( pulTotalRunTime != NULL )
   1887          					{
   1888          						*pulTotalRunTime = 0;
   1889          					}
   1890          				}
   1891          				#endif
   1892          			}
   1893          			else
   1894          			{
   1895          				mtCOVERAGE_TEST_MARKER();
   1896          			}
   1897          		}
   1898          		( void ) xTaskResumeAll();
   1899          
   1900          		return uxTask;
   1901          	}
   1902          
   1903          #endif /* configUSE_TRACE_FACILITY */
   1904          /*----------------------------------------------------------*/
   1905          
   1906          #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
   1907          
   1908          	TaskHandle_t xTaskGetIdleTaskHandle( void )
   1909          	{
   1910          		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
   1911          		started, then xIdleTaskHandle will be NULL. */
   1912          		configASSERT( ( xIdleTaskHandle != NULL ) );
   1913          		return xIdleTaskHandle;
   1914          	}
   1915          
   1916          #endif /* INCLUDE_xTaskGetIdleTaskHandle */
   1917          /*----------------------------------------------------------*/
   1918          
   1919          /* This conditional compilation should use inequality to 0, not equality to 1.
   1920          This is to ensure vTaskStepTick() is available when user defined low power mode
   1921          implementations require configUSE_TICKLESS_IDLE to be set to a value other than
   1922          1. */
   1923          #if ( configUSE_TICKLESS_IDLE != 0 )
   1924          
   1925          	void vTaskStepTick( const TickType_t xTicksToJump )
   1926          	{
   1927          		/* Correct the tick count value after a period during which the tick
   1928          		was suppressed.  Note this does *not* call the tick hook function for
   1929          		each stepped tick. */
   1930          		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
   1931          		xTickCount += xTicksToJump;
   1932          		traceINCREASE_TICK_COUNT( xTicksToJump );
   1933          	}
   1934          
   1935          #endif /* configUSE_TICKLESS_IDLE */
   1936          /*----------------------------------------------------------*/
   1937          

   \                                 In section .text, align 4, keep-with-next
   1938          BaseType_t xTaskIncrementTick( void )
   1939          {
   \                     xTaskIncrementTick: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   1940          TCB_t * pxTCB;
   1941          TickType_t xItemValue;
   1942          BaseType_t xSwitchRequired = pdFALSE;
   \   00000004   0x2600             MOVS     R6,#+0
   1943          
   1944          	/* Called by the portable layer each time a tick interrupt occurs.
   1945          	Increments the tick then checks to see if the new tick value will cause any
   1946          	tasks to be unblocked. */
   1947          	traceTASK_INCREMENT_TICK( xTickCount );
   1948          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \   00000006   0x....             LDR      R0,??DataTable23
   \   00000008   0x....             LDR      R4,??DataTable23_1
   \   0000000A   0x2180             MOVS     R1,#+128
   \   0000000C   0x5861             LDR      R1,[R4, R1]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD14F             BNE      ??xTaskIncrementTick_0
   1949          	{
   1950          		/* Increment the RTOS tick, switching the delayed and overflowed
   1951          		delayed lists if it wraps to 0. */
   1952          		++xTickCount;
   \   00000012   0x6AC1             LDR      R1,[R0, #+44]
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0x62C1             STR      R1,[R0, #+44]
   1953          
   1954          		{
   1955          			/* Minor optimisation.  The tick count cannot change in this
   1956          			block. */
   1957          			const TickType_t xConstTickCount = xTickCount;
   \   00000018   0x6AC7             LDR      R7,[R0, #+44]
   1958          
   1959          			if( xConstTickCount == ( TickType_t ) 0U )
   \   0000001A   0x2F00             CMP      R7,#+0
   \   0000001C   0xD118             BNE      ??xTaskIncrementTick_1
   1960          			{
   1961          				taskSWITCH_DELAYED_LISTS();
   \   0000001E   0x6EA1             LDR      R1,[R4, #+104]
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0x2900             CMP      R1,#+0
   \   00000024   0xD001             BEQ      ??xTaskIncrementTick_2
   \   00000026   0xB672             cpsid i
   \                     ??xTaskIncrementTick_3: (+1)
   \   00000028   0xE7FE             B        ??xTaskIncrementTick_3
   \                     ??xTaskIncrementTick_2: (+1)
   \   0000002A   0x6EA1             LDR      R1,[R4, #+104]
   \   0000002C   0x6EE2             LDR      R2,[R4, #+108]
   \   0000002E   0x66A2             STR      R2,[R4, #+104]
   \   00000030   0x66E1             STR      R1,[R4, #+108]
   \   00000032   0x6B81             LDR      R1,[R0, #+56]
   \   00000034   0x1C49             ADDS     R1,R1,#+1
   \   00000036   0x6381             STR      R1,[R0, #+56]
   \   00000038   0x6EA0             LDR      R0,[R4, #+104]
   \   0000003A   0x6800             LDR      R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD102             BNE      ??xTaskIncrementTick_4
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x43C0             MVNS     R0,R0            ;; #-1
   \   00000044   0xE003             B        ??xTaskIncrementTick_5
   \                     ??xTaskIncrementTick_4: (+1)
   \   00000046   0x6EA0             LDR      R0,[R4, #+104]
   \   00000048   0x68C0             LDR      R0,[R0, #+12]
   \   0000004A   0x68C0             LDR      R0,[R0, #+12]
   \   0000004C   0x6840             LDR      R0,[R0, #+4]
   \                     ??xTaskIncrementTick_5: (+1)
   \   0000004E   0x67E0             STR      R0,[R4, #+124]
   1962          			}
   1963          			else
   1964          			{
   1965          				mtCOVERAGE_TEST_MARKER();
   1966          			}
   1967          
   1968          			/* See if this tick has made a timeout expire.  Tasks are stored in
   1969          			the	queue in the order of their wake time - meaning once one task
   1970          			has been found whose block time has not expired there is no need to
   1971          			look any further down the list. */
   1972          			if( xConstTickCount >= xNextTaskUnblockTime )
   \                     ??xTaskIncrementTick_1: (+1)
   \   00000050   0x6FE0             LDR      R0,[R4, #+124]
   \   00000052   0x4287             CMP      R7,R0
   \   00000054   0xD330             BCC      ??xTaskIncrementTick_6
   \   00000056   0xE01D             B        ??xTaskIncrementTick_7
   1973          			{
   1974          				for( ;; )
   1975          				{
   1976          					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   1977          					{
   1978          						/* The delayed list is empty.  Set xNextTaskUnblockTime
   1979          						to the maximum possible value so it is extremely
   1980          						unlikely that the
   1981          						if( xTickCount >= xNextTaskUnblockTime ) test will pass
   1982          						next time through. */
   1983          						xNextTaskUnblockTime = portMAX_DELAY;
   1984          						break;
   1985          					}
   1986          					else
   1987          					{
   1988          						/* The delayed list is not empty, get the value of the
   1989          						item at the head of the delayed list.  This is the time
   1990          						at which the task at the head of the delayed list must
   1991          						be removed from the Blocked state. */
   1992          						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   1993          						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   1994          
   1995          						if( xConstTickCount < xItemValue )
   1996          						{
   1997          							/* It is not time to unblock this item yet, but the
   1998          							item value is the time at which the task at the head
   1999          							of the blocked list must be removed from the Blocked
   2000          							state -	so record the item value in
   2001          							xNextTaskUnblockTime. */
   2002          							xNextTaskUnblockTime = xItemValue;
   2003          							break;
   2004          						}
   2005          						else
   2006          						{
   2007          							mtCOVERAGE_TEST_MARKER();
   2008          						}
   2009          
   2010          						/* It is time to remove the item from the Blocked state. */
   2011          						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   \                     ??xTaskIncrementTick_8: (+1)
   \   00000058   0x1D28             ADDS     R0,R5,#+4
   \   0000005A   0x.... 0x....      BL       uxListRemove
   2012          
   2013          						/* Is the task waiting on an event also?  If so remove
   2014          						it from the event list. */
   2015          						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   \   0000005E   0x6AA8             LDR      R0,[R5, #+40]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD003             BEQ      ??xTaskIncrementTick_9
   2016          						{
   2017          							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   \   00000064   0x0028             MOVS     R0,R5
   \   00000066   0x3018             ADDS     R0,R0,#+24
   \   00000068   0x.... 0x....      BL       uxListRemove
   2018          						}
   2019          						else
   2020          						{
   2021          							mtCOVERAGE_TEST_MARKER();
   2022          						}
   2023          
   2024          						/* Place the unblocked task into the appropriate ready
   2025          						list. */
   2026          						prvAddTaskToReadyList( pxTCB );
   \                     ??xTaskIncrementTick_9: (+1)
   \   0000006C   0x6AE8             LDR      R0,[R5, #+44]
   \   0000006E   0x6F21             LDR      R1,[R4, #+112]
   \   00000070   0x4281             CMP      R1,R0
   \   00000072   0xD200             BCS      ??xTaskIncrementTick_10
   \   00000074   0x6720             STR      R0,[R4, #+112]
   \                     ??xTaskIncrementTick_10: (+1)
   \   00000076   0x1D29             ADDS     R1,R5,#+4
   \   00000078   0x6AE8             LDR      R0,[R5, #+44]
   \   0000007A   0x0082             LSLS     R2,R0,#+2
   \   0000007C   0x1810             ADDS     R0,R2,R0
   \   0000007E   0x0080             LSLS     R0,R0,#+2
   \   00000080   0x1820             ADDS     R0,R4,R0
   \   00000082   0x1D00             ADDS     R0,R0,#+4
   \   00000084   0x.... 0x....      BL       vListInsertEnd
   2027          
   2028          						/* A task being unblocked cannot cause an immediate
   2029          						context switch if preemption is turned off. */
   2030          						#if (  configUSE_PREEMPTION == 1 )
   2031          						{
   2032          							/* Preemption is on, but a context switch should
   2033          							only be performed if the unblocked task has a
   2034          							priority that is equal to or higher than the
   2035          							currently executing task. */
   2036          							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   \   00000088   0x6AE8             LDR      R0,[R5, #+44]
   \   0000008A   0x6821             LDR      R1,[R4, #+0]
   \   0000008C   0x6AC9             LDR      R1,[R1, #+44]
   \   0000008E   0x4288             CMP      R0,R1
   \   00000090   0xD300             BCC      ??xTaskIncrementTick_7
   2037          							{
   2038          								xSwitchRequired = pdTRUE;
   \   00000092   0x2601             MOVS     R6,#+1
   2039          							}
   2040          							else
   2041          							{
   2042          								mtCOVERAGE_TEST_MARKER();
   2043          							}
   2044          						}
   \                     ??xTaskIncrementTick_7: (+1)
   \   00000094   0x6EA0             LDR      R0,[R4, #+104]
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x2800             CMP      R0,#+0
   \   0000009A   0xD102             BNE      ??xTaskIncrementTick_11
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0x43C0             MVNS     R0,R0            ;; #-1
   \   000000A0   0xE005             B.N      ??xTaskIncrementTick_12
   \                     ??xTaskIncrementTick_11: (+1)
   \   000000A2   0x6EA0             LDR      R0,[R4, #+104]
   \   000000A4   0x68C0             LDR      R0,[R0, #+12]
   \   000000A6   0x68C5             LDR      R5,[R0, #+12]
   \   000000A8   0x6868             LDR      R0,[R5, #+4]
   \   000000AA   0x4287             CMP      R7,R0
   \   000000AC   0xD2D4             BCS      ??xTaskIncrementTick_8
   \                     ??xTaskIncrementTick_12: (+1)
   \   000000AE   0x67E0             STR      R0,[R4, #+124]
   \   000000B0   0xE002             B        ??xTaskIncrementTick_6
   2045          						#endif /* configUSE_PREEMPTION */
   2046          					}
   2047          				}
   2048          			}
   2049          		}
   2050          
   2051          		/* Tasks of equal priority to the currently running task will share
   2052          		processing time (time slice) if preemption is on, and the application
   2053          		writer has not explicitly turned time slicing off. */
   2054          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
   2055          		{
   2056          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   2057          			{
   2058          				xSwitchRequired = pdTRUE;
   2059          			}
   2060          			else
   2061          			{
   2062          				mtCOVERAGE_TEST_MARKER();
   2063          			}
   2064          		}
   2065          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
   2066          
   2067          		#if ( configUSE_TICK_HOOK == 1 )
   2068          		{
   2069          			/* Guard against the tick hook being called when the pended tick
   2070          			count is being unwound (when the scheduler is being unlocked). */
   2071          			if( uxPendedTicks == ( UBaseType_t ) 0U )
   2072          			{
   2073          				vApplicationTickHook();
   2074          			}
   2075          			else
   2076          			{
   2077          				mtCOVERAGE_TEST_MARKER();
   2078          			}
   2079          		}
   2080          		#endif /* configUSE_TICK_HOOK */
   2081          	}
   2082          	else
   2083          	{
   2084          		++uxPendedTicks;
   \                     ??xTaskIncrementTick_0: (+1)
   \   000000B2   0x6B41             LDR      R1,[R0, #+52]
   \   000000B4   0x1C49             ADDS     R1,R1,#+1
   \   000000B6   0x6341             STR      R1,[R0, #+52]
   2085          
   2086          		/* The tick hook gets called at regular intervals, even if the
   2087          		scheduler is locked. */
   2088          		#if ( configUSE_TICK_HOOK == 1 )
   2089          		{
   2090          			vApplicationTickHook();
   2091          		}
   2092          		#endif
   2093          	}
   2094          
   2095          	#if ( configUSE_PREEMPTION == 1 )
   2096          	{
   2097          		if( xYieldPending != pdFALSE )
   \                     ??xTaskIncrementTick_6: (+1)
   \   000000B8   0x6F60             LDR      R0,[R4, #+116]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD000             BEQ      ??xTaskIncrementTick_13
   2098          		{
   2099          			xSwitchRequired = pdTRUE;
   \   000000BE   0x2601             MOVS     R6,#+1
   2100          		}
   2101          		else
   2102          		{
   2103          			mtCOVERAGE_TEST_MARKER();
   2104          		}
   2105          	}
   2106          	#endif /* configUSE_PREEMPTION */
   2107          
   2108          	return xSwitchRequired;
   \                     ??xTaskIncrementTick_13: (+1)
   \   000000C0   0x0030             MOVS     R0,R6
   \   000000C2   0xB001             ADD      SP,SP,#+4
   \   000000C4   0xBDF0             POP      {R4-R7,PC}       ;; return
   2109          }
   2110          /*-----------------------------------------------------------*/
   2111          
   2112          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2113          
   2114          	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
   2115          	{
   2116          	TCB_t *xTCB;
   2117          
   2118          		/* If xTask is NULL then it is the task hook of the calling task that is
   2119          		getting set. */
   2120          		if( xTask == NULL )
   2121          		{
   2122          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2123          		}
   2124          		else
   2125          		{
   2126          			xTCB = ( TCB_t * ) xTask;
   2127          		}
   2128          
   2129          		/* Save the hook function in the TCB.  A critical section is required as
   2130          		the value can be accessed from an interrupt. */
   2131          		taskENTER_CRITICAL();
   2132          			xTCB->pxTaskTag = pxHookFunction;
   2133          		taskEXIT_CRITICAL();
   2134          	}
   2135          
   2136          #endif /* configUSE_APPLICATION_TASK_TAG */
   2137          /*-----------------------------------------------------------*/
   2138          
   2139          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2140          
   2141          	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
   2142          	{
   2143          	TCB_t *xTCB;
   2144          	TaskHookFunction_t xReturn;
   2145          
   2146          		/* If xTask is NULL then we are setting our own task hook. */
   2147          		if( xTask == NULL )
   2148          		{
   2149          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2150          		}
   2151          		else
   2152          		{
   2153          			xTCB = ( TCB_t * ) xTask;
   2154          		}
   2155          
   2156          		/* Save the hook function in the TCB.  A critical section is required as
   2157          		the value can be accessed from an interrupt. */
   2158          		taskENTER_CRITICAL();
   2159          		{
   2160          			xReturn = xTCB->pxTaskTag;
   2161          		}
   2162          		taskEXIT_CRITICAL();
   2163          
   2164          		return xReturn;
   2165          	}
   2166          
   2167          #endif /* configUSE_APPLICATION_TASK_TAG */
   2168          /*-----------------------------------------------------------*/
   2169          
   2170          #if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2171          
   2172          	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
   2173          	{
   2174          	TCB_t *xTCB;
   2175          	BaseType_t xReturn;
   2176          
   2177          		/* If xTask is NULL then we are calling our own task hook. */
   2178          		if( xTask == NULL )
   2179          		{
   2180          			xTCB = ( TCB_t * ) pxCurrentTCB;
   2181          		}
   2182          		else
   2183          		{
   2184          			xTCB = ( TCB_t * ) xTask;
   2185          		}
   2186          
   2187          		if( xTCB->pxTaskTag != NULL )
   2188          		{
   2189          			xReturn = xTCB->pxTaskTag( pvParameter );
   2190          		}
   2191          		else
   2192          		{
   2193          			xReturn = pdFAIL;
   2194          		}
   2195          
   2196          		return xReturn;
   2197          	}
   2198          
   2199          #endif /* configUSE_APPLICATION_TASK_TAG */
   2200          /*-----------------------------------------------------------*/
   2201          

   \                                 In section .text, align 4, keep-with-next
   2202          void vTaskSwitchContext( void )
   2203          {
   2204          	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   \                     vTaskSwitchContext: (+1)
   \   00000000   0x....             LDR      R1,??DataTable23_1
   \   00000002   0x2080             MOVS     R0,#+128
   \   00000004   0x5808             LDR      R0,[R1, R0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD002             BEQ      ??vTaskSwitchContext_0
   2205          	{
   2206          		/* The scheduler is currently suspended - do not allow a context
   2207          		switch. */
   2208          		xYieldPending = pdTRUE;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x6748             STR      R0,[R1, #+116]
   \   0000000E   0x4770             BX       LR
   2209          	}
   2210          	else
   2211          	{
   2212          		xYieldPending = pdFALSE;
   \                     ??vTaskSwitchContext_0: (+1)
   \   00000010   0x6748             STR      R0,[R1, #+116]
   \   00000012   0xE002             B        ??vTaskSwitchContext_1
   2213          		traceTASK_SWITCHED_OUT();
   2214          
   2215          		#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2216          		{
   2217          				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
   2218          					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
   2219          				#else
   2220          					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
   2221          				#endif
   2222          
   2223          				/* Add the amount of time the task has been running to the
   2224          				accumulated	time so far.  The time the task started running was
   2225          				stored in ulTaskSwitchedInTime.  Note that there is no overflow
   2226          				protection here	so count values are only valid until the timer
   2227          				overflows.  The guard against negative values is to protect
   2228          				against suspect run time stat counter implementations - which
   2229          				are provided by the application, not the kernel. */
   2230          				if( ulTotalRunTime > ulTaskSwitchedInTime )
   2231          				{
   2232          					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
   2233          				}
   2234          				else
   2235          				{
   2236          					mtCOVERAGE_TEST_MARKER();
   2237          				}
   2238          				ulTaskSwitchedInTime = ulTotalRunTime;
   2239          		}
   2240          		#endif /* configGENERATE_RUN_TIME_STATS */
   2241          
   2242          		/* Check for stack overflow, if configured. */
   2243          		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
   2244          		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
   2245          
   2246          		/* Select a new task to run using either the generic C or port
   2247          		optimised asm code. */
   2248          		taskSELECT_HIGHEST_PRIORITY_TASK();
   \                     ??vTaskSwitchContext_2: (+1)
   \   00000014   0x6F08             LDR      R0,[R1, #+112]
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x6708             STR      R0,[R1, #+112]
   \                     ??vTaskSwitchContext_1: (+1)
   \   0000001A   0x6F08             LDR      R0,[R1, #+112]
   \   0000001C   0x0082             LSLS     R2,R0,#+2
   \   0000001E   0x1810             ADDS     R0,R2,R0
   \   00000020   0x0080             LSLS     R0,R0,#+2
   \   00000022   0x1808             ADDS     R0,R1,R0
   \   00000024   0x6840             LDR      R0,[R0, #+4]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0x6F08             LDR      R0,[R1, #+112]
   \   0000002A   0xD103             BNE      ??vTaskSwitchContext_3
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD1F1             BNE      ??vTaskSwitchContext_2
   \   00000030   0xB672             cpsid i
   \                     ??vTaskSwitchContext_4: (+1)
   \   00000032   0xE7FE             B        ??vTaskSwitchContext_4
   \                     ??vTaskSwitchContext_3: (+1)
   \   00000034   0x0082             LSLS     R2,R0,#+2
   \   00000036   0x1810             ADDS     R0,R2,R0
   \   00000038   0x0080             LSLS     R0,R0,#+2
   \   0000003A   0x180A             ADDS     R2,R1,R0
   \   0000003C   0x1D12             ADDS     R2,R2,#+4
   \   0000003E   0x6850             LDR      R0,[R2, #+4]
   \   00000040   0x6843             LDR      R3,[R0, #+4]
   \   00000042   0x6053             STR      R3,[R2, #+4]
   \   00000044   0x0010             MOVS     R0,R2
   \   00000046   0x3008             ADDS     R0,R0,#+8
   \   00000048   0x4283             CMP      R3,R0
   \   0000004A   0xD101             BNE      ??vTaskSwitchContext_5
   \   0000004C   0x6858             LDR      R0,[R3, #+4]
   \   0000004E   0x6050             STR      R0,[R2, #+4]
   \                     ??vTaskSwitchContext_5: (+1)
   \   00000050   0x6850             LDR      R0,[R2, #+4]
   \   00000052   0x68C0             LDR      R0,[R0, #+12]
   \   00000054   0x6008             STR      R0,[R1, #+0]
   2249          		traceTASK_SWITCHED_IN();
   2250          
   2251          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2252          		{
   2253          			/* Switch Newlib's _impure_ptr variable to point to the _reent
   2254          			structure specific to this task. */
   2255          			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
   2256          		}
   2257          		#endif /* configUSE_NEWLIB_REENTRANT */
   2258          	}
   2259          }
   \   00000056   0x4770             BX       LR               ;; return
   2260          /*-----------------------------------------------------------*/
   2261          

   \                                 In section .text, align 4, keep-with-next
   2262          void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
   2263          {
   \                     vTaskPlaceOnEventList: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x000D             MOVS     R5,R1
   2264          TickType_t xTimeToWake;
   2265          
   2266          	configASSERT( pxEventList );
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE      ??vTaskPlaceOnEventList_0
   \   0000000A   0xB672             cpsid i
   \                     ??vTaskPlaceOnEventList_1: (+1)
   \   0000000C   0xE7FE             B        ??vTaskPlaceOnEventList_1
   2267          
   2268          	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
   2269          	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
   2270          
   2271          	/* Place the event list item of the TCB in the appropriate event list.
   2272          	This is placed in the list in priority order so the highest priority task
   2273          	is the first to be woken by the event.  The queue that contains the event
   2274          	list is locked, preventing simultaneous access from interrupts. */
   2275          	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   \                     ??vTaskPlaceOnEventList_0: (+1)
   \   0000000E   0x....             LDR      R4,??DataTable23_1
   \   00000010   0x6821             LDR      R1,[R4, #+0]
   \   00000012   0x3118             ADDS     R1,R1,#+24
   \   00000014   0x.... 0x....      BL       vListInsert
   2276          
   2277          	/* The task must be removed from from the ready list before it is added to
   2278          	the blocked list as the same list item is used for both lists.  Exclusive
   2279          	access to the ready lists guaranteed because the scheduler is locked. */
   2280          	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x1D00             ADDS     R0,R0,#+4
   \   0000001C   0x.... 0x....      BL       uxListRemove
   2281          	{
   2282          		/* The current task must be in a ready list, so there is no need to
   2283          		check, and the port reset macro can be called directly. */
   2284          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2285          	}
   2286          	else
   2287          	{
   2288          		mtCOVERAGE_TEST_MARKER();
   2289          	}
   2290          
   2291          	#if ( INCLUDE_vTaskSuspend == 1 )
   2292          	{
   2293          		if( xTicksToWait == portMAX_DELAY )
   \   00000020   0x....             LDR      R0,??DataTable23
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000026   0x428D             CMP      R5,R1
   \   00000028   0xD105             BNE      ??vTaskPlaceOnEventList_2
   2294          		{
   2295          			/* Add the task to the suspended task list instead of a delayed task
   2296          			list to ensure the task is not woken by a timing event.  It will
   2297          			block indefinitely. */
   2298          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0x1D09             ADDS     R1,R1,#+4
   \   0000002E   0x3014             ADDS     R0,R0,#+20
   \   00000030   0x.... 0x....      BL       vListInsertEnd
   \   00000034   0xE014             B        ??vTaskPlaceOnEventList_3
   2299          		}
   2300          		else
   2301          		{
   2302          			/* Calculate the time at which the task should be woken if the event
   2303          			does not occur.  This may overflow but this doesn't matter, the
   2304          			scheduler will handle it. */
   2305          			xTimeToWake = xTickCount + xTicksToWait;
   2306          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   \                     ??vTaskPlaceOnEventList_2: (+1)
   \   00000036   0x6AC1             LDR      R1,[R0, #+44]
   \   00000038   0x194D             ADDS     R5,R1,R5
   \   0000003A   0x6821             LDR      R1,[R4, #+0]
   \   0000003C   0x604D             STR      R5,[R1, #+4]
   \   0000003E   0x6AC0             LDR      R0,[R0, #+44]
   \   00000040   0x4285             CMP      R5,R0
   \   00000042   0x6821             LDR      R1,[R4, #+0]
   \   00000044   0xD204             BCS      ??vTaskPlaceOnEventList_4
   \   00000046   0x1D09             ADDS     R1,R1,#+4
   \   00000048   0x6EE0             LDR      R0,[R4, #+108]
   \   0000004A   0x.... 0x....      BL       vListInsert
   \   0000004E   0xE007             B        ??vTaskPlaceOnEventList_3
   \                     ??vTaskPlaceOnEventList_4: (+1)
   \   00000050   0x1D09             ADDS     R1,R1,#+4
   \   00000052   0x6EA0             LDR      R0,[R4, #+104]
   \   00000054   0x.... 0x....      BL       vListInsert
   \   00000058   0x6FE0             LDR      R0,[R4, #+124]
   \   0000005A   0x4285             CMP      R5,R0
   \   0000005C   0xD200             BCS      ??vTaskPlaceOnEventList_3
   \   0000005E   0x67E5             STR      R5,[R4, #+124]
   2307          		}
   2308          	}
   2309          	#else /* INCLUDE_vTaskSuspend */
   2310          	{
   2311          			/* Calculate the time at which the task should be woken if the event does
   2312          			not occur.  This may overflow but this doesn't matter, the scheduler
   2313          			will handle it. */
   2314          			xTimeToWake = xTickCount + xTicksToWait;
   2315          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2316          	}
   2317          	#endif /* INCLUDE_vTaskSuspend */
   2318          }
   \                     ??vTaskPlaceOnEventList_3: (+1)
   \   00000060   0xB001             ADD      SP,SP,#+4
   \   00000062   0xBD30             POP      {R4,R5,PC}       ;; return
   2319          /*-----------------------------------------------------------*/
   2320          

   \                                 In section .text, align 4, keep-with-next
   2321          void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
   2322          {
   \                     vTaskPlaceOnUnorderedEventList: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0014             MOVS     R4,R2
   2323          TickType_t xTimeToWake;
   2324          
   2325          	configASSERT( pxEventList );
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE      ??vTaskPlaceOnUnorderedEventList_0
   \   0000000A   0xB672             cpsid i
   \                     ??vTaskPlaceOnUnorderedEventList_1: (+1)
   \   0000000C   0xE7FE             B        ??vTaskPlaceOnUnorderedEventList_1
   2326          
   2327          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   2328          	the event groups implementation. */
   2329          	configASSERT( uxSchedulerSuspended != 0 );
   \                     ??vTaskPlaceOnUnorderedEventList_0: (+1)
   \   0000000E   0x....             LDR      R5,??DataTable23_1
   \   00000010   0x2280             MOVS     R2,#+128
   \   00000012   0x58AA             LDR      R2,[R5, R2]
   \   00000014   0x2A00             CMP      R2,#+0
   \   00000016   0xD101             BNE      ??vTaskPlaceOnUnorderedEventList_2
   \   00000018   0xB672             cpsid i
   \                     ??vTaskPlaceOnUnorderedEventList_3: (+1)
   \   0000001A   0xE7FE             B        ??vTaskPlaceOnUnorderedEventList_3
   2330          
   2331          	/* Store the item value in the event list item.  It is safe to access the
   2332          	event list item here as interrupts won't access the event list item of a
   2333          	task that is not in the Blocked state. */
   2334          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   \                     ??vTaskPlaceOnUnorderedEventList_2: (+1)
   \   0000001C   0x2280             MOVS     R2,#+128
   \   0000001E   0x0612             LSLS     R2,R2,#+24       ;; #-2147483648
   \   00000020   0x430A             ORRS     R2,R2,R1
   \   00000022   0x6829             LDR      R1,[R5, #+0]
   \   00000024   0x618A             STR      R2,[R1, #+24]
   2335          
   2336          	/* Place the event list item of the TCB at the end of the appropriate event
   2337          	list.  It is safe to access the event list here because it is part of an
   2338          	event group implementation - and interrupts don't access event groups
   2339          	directly (instead they access them indirectly by pending function calls to
   2340          	the task level). */
   2341          	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   \   00000026   0x6829             LDR      R1,[R5, #+0]
   \   00000028   0x3118             ADDS     R1,R1,#+24
   \   0000002A   0x.... 0x....      BL       vListInsertEnd
   2342          
   2343          	/* The task must be removed from the ready list before it is added to the
   2344          	blocked list.  Exclusive access can be assured to the ready list as the
   2345          	scheduler is locked. */
   2346          	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   \   0000002E   0x6828             LDR      R0,[R5, #+0]
   \   00000030   0x1D00             ADDS     R0,R0,#+4
   \   00000032   0x.... 0x....      BL       uxListRemove
   2347          	{
   2348          		/* The current task must be in a ready list, so there is no need to
   2349          		check, and the port reset macro can be called directly. */
   2350          		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2351          	}
   2352          	else
   2353          	{
   2354          		mtCOVERAGE_TEST_MARKER();
   2355          	}
   2356          
   2357          	#if ( INCLUDE_vTaskSuspend == 1 )
   2358          	{
   2359          		if( xTicksToWait == portMAX_DELAY )
   \   00000036   0x....             LDR      R0,??DataTable23
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000003C   0x428C             CMP      R4,R1
   \   0000003E   0xD105             BNE      ??vTaskPlaceOnUnorderedEventList_4
   2360          		{
   2361          			/* Add the task to the suspended task list instead of a delayed task
   2362          			list to ensure it is not woken by a timing event.  It will block
   2363          			indefinitely. */
   2364          			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   \   00000040   0x6829             LDR      R1,[R5, #+0]
   \   00000042   0x1D09             ADDS     R1,R1,#+4
   \   00000044   0x3014             ADDS     R0,R0,#+20
   \   00000046   0x.... 0x....      BL       vListInsertEnd
   \   0000004A   0xE014             B        ??vTaskPlaceOnUnorderedEventList_5
   2365          		}
   2366          		else
   2367          		{
   2368          			/* Calculate the time at which the task should be woken if the event
   2369          			does not occur.  This may overflow but this doesn't matter, the
   2370          			kernel will manage it correctly. */
   2371          			xTimeToWake = xTickCount + xTicksToWait;
   2372          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   \                     ??vTaskPlaceOnUnorderedEventList_4: (+1)
   \   0000004C   0x6AC1             LDR      R1,[R0, #+44]
   \   0000004E   0x190C             ADDS     R4,R1,R4
   \   00000050   0x6829             LDR      R1,[R5, #+0]
   \   00000052   0x604C             STR      R4,[R1, #+4]
   \   00000054   0x6AC0             LDR      R0,[R0, #+44]
   \   00000056   0x4284             CMP      R4,R0
   \   00000058   0x6829             LDR      R1,[R5, #+0]
   \   0000005A   0xD204             BCS      ??vTaskPlaceOnUnorderedEventList_6
   \   0000005C   0x1D09             ADDS     R1,R1,#+4
   \   0000005E   0x6EE8             LDR      R0,[R5, #+108]
   \   00000060   0x.... 0x....      BL       vListInsert
   \   00000064   0xE007             B        ??vTaskPlaceOnUnorderedEventList_5
   \                     ??vTaskPlaceOnUnorderedEventList_6: (+1)
   \   00000066   0x1D09             ADDS     R1,R1,#+4
   \   00000068   0x6EA8             LDR      R0,[R5, #+104]
   \   0000006A   0x.... 0x....      BL       vListInsert
   \   0000006E   0x6FE8             LDR      R0,[R5, #+124]
   \   00000070   0x4284             CMP      R4,R0
   \   00000072   0xD200             BCS      ??vTaskPlaceOnUnorderedEventList_5
   \   00000074   0x67EC             STR      R4,[R5, #+124]
   2373          		}
   2374          	}
   2375          	#else /* INCLUDE_vTaskSuspend */
   2376          	{
   2377          			/* Calculate the time at which the task should be woken if the event does
   2378          			not occur.  This may overflow but this doesn't matter, the kernel
   2379          			will manage it correctly. */
   2380          			xTimeToWake = xTickCount + xTicksToWait;
   2381          			prvAddCurrentTaskToDelayedList( xTimeToWake );
   2382          	}
   2383          	#endif /* INCLUDE_vTaskSuspend */
   2384          }
   \                     ??vTaskPlaceOnUnorderedEventList_5: (+1)
   \   00000076   0xB001             ADD      SP,SP,#+4
   \   00000078   0xBD30             POP      {R4,R5,PC}       ;; return
   2385          /*-----------------------------------------------------------*/
   2386          
   2387          #if configUSE_TIMERS == 1
   2388          

   \                                 In section .text, align 4, keep-with-next
   2389          	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
   2390          	{
   \                     vTaskPlaceOnEventListRestricted: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x000D             MOVS     R5,R1
   2391          	TickType_t xTimeToWake;
   2392          
   2393          		configASSERT( pxEventList );
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD101             BNE      ??vTaskPlaceOnEventListRestricted_0
   \   0000000A   0xB672             cpsid i
   \                     ??vTaskPlaceOnEventListRestricted_1: (+1)
   \   0000000C   0xE7FE             B        ??vTaskPlaceOnEventListRestricted_1
   2394          
   2395          		/* This function should not be called by application code hence the
   2396          		'Restricted' in its name.  It is not part of the public API.  It is
   2397          		designed for use by kernel code, and has special calling requirements -
   2398          		it should be called with the scheduler suspended. */
   2399          
   2400          
   2401          		/* Place the event list item of the TCB in the appropriate event list.
   2402          		In this case it is assume that this is the only task that is going to
   2403          		be waiting on this event list, so the faster vListInsertEnd() function
   2404          		can be used in place of vListInsert. */
   2405          		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   \                     ??vTaskPlaceOnEventListRestricted_0: (+1)
   \   0000000E   0x....             LDR      R4,??DataTable23_1
   \   00000010   0x6821             LDR      R1,[R4, #+0]
   \   00000012   0x3118             ADDS     R1,R1,#+24
   \   00000014   0x.... 0x....      BL       vListInsertEnd
   2406          
   2407          		/* We must remove this task from the ready list before adding it to the
   2408          		blocked list as the same list item is used for both lists.  This
   2409          		function is called with the scheduler locked so interrupts will not
   2410          		access the lists at the same time. */
   2411          		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   \   00000018   0x6820             LDR      R0,[R4, #+0]
   \   0000001A   0x1D00             ADDS     R0,R0,#+4
   \   0000001C   0x.... 0x....      BL       uxListRemove
   2412          		{
   2413          			/* The current task must be in a ready list, so there is no need to
   2414          			check, and the port reset macro can be called directly. */
   2415          			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   2416          		}
   2417          		else
   2418          		{
   2419          			mtCOVERAGE_TEST_MARKER();
   2420          		}
   2421          
   2422          		/* Calculate the time at which the task should be woken if the event does
   2423          		not occur.  This may overflow but this doesn't matter. */
   2424          		xTimeToWake = xTickCount + xTicksToWait;
   2425          
   2426          		traceTASK_DELAY_UNTIL();
   2427          		prvAddCurrentTaskToDelayedList( xTimeToWake );
   \   00000020   0x....             LDR      R0,??DataTable23
   \   00000022   0x6AC1             LDR      R1,[R0, #+44]
   \   00000024   0x194D             ADDS     R5,R1,R5
   \   00000026   0x6821             LDR      R1,[R4, #+0]
   \   00000028   0x604D             STR      R5,[R1, #+4]
   \   0000002A   0x6AC0             LDR      R0,[R0, #+44]
   \   0000002C   0x4285             CMP      R5,R0
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0xD204             BCS      ??vTaskPlaceOnEventListRestricted_2
   \   00000032   0x1D09             ADDS     R1,R1,#+4
   \   00000034   0x6EE0             LDR      R0,[R4, #+108]
   \   00000036   0x.... 0x....      BL       vListInsert
   \   0000003A   0xE007             B        ??vTaskPlaceOnEventListRestricted_3
   \                     ??vTaskPlaceOnEventListRestricted_2: (+1)
   \   0000003C   0x1D09             ADDS     R1,R1,#+4
   \   0000003E   0x6EA0             LDR      R0,[R4, #+104]
   \   00000040   0x.... 0x....      BL       vListInsert
   \   00000044   0x6FE0             LDR      R0,[R4, #+124]
   \   00000046   0x4285             CMP      R5,R0
   \   00000048   0xD200             BCS      ??vTaskPlaceOnEventListRestricted_3
   \   0000004A   0x67E5             STR      R5,[R4, #+124]
   2428          	}
   \                     ??vTaskPlaceOnEventListRestricted_3: (+1)
   \   0000004C   0xB001             ADD      SP,SP,#+4
   \   0000004E   0xBD30             POP      {R4,R5,PC}       ;; return
   2429          
   2430          #endif /* configUSE_TIMERS */
   2431          /*-----------------------------------------------------------*/
   2432          

   \                                 In section .text, align 4, keep-with-next
   2433          BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
   2434          {
   \                     xTaskRemoveFromEventList: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2435          TCB_t *pxUnblockedTCB;
   2436          BaseType_t xReturn;
   2437          
   2438          	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
   2439          	called from a critical section within an ISR. */
   2440          
   2441          	/* The event list is sorted in priority order, so the first in the list can
   2442          	be removed as it is known to be the highest priority.  Remove the TCB from
   2443          	the delayed list, and add it to the ready list.
   2444          
   2445          	If an event is for a queue that is locked then this function will never
   2446          	get called - the lock count on the queue will get modified instead.  This
   2447          	means exclusive access to the event list is guaranteed here.
   2448          
   2449          	This function assumes that a check has already been made to ensure that
   2450          	pxEventList is not empty. */
   2451          	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x68C4             LDR      R4,[R0, #+12]
   2452          	configASSERT( pxUnblockedTCB );
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE      ??xTaskRemoveFromEventList_0
   \   0000000C   0xB672             cpsid i
   \                     ??xTaskRemoveFromEventList_1: (+1)
   \   0000000E   0xE7FE             B        ??xTaskRemoveFromEventList_1
   2453          	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   \                     ??xTaskRemoveFromEventList_0: (+1)
   \   00000010   0x0020             MOVS     R0,R4
   \   00000012   0x3018             ADDS     R0,R0,#+24
   \   00000014   0x.... 0x....      BL       uxListRemove
   2454          
   2455          	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \   00000018   0x....             LDR      R5,??DataTable23_1
   \   0000001A   0x2080             MOVS     R0,#+128
   \   0000001C   0x5828             LDR      R0,[R5, R0]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD10F             BNE      ??xTaskRemoveFromEventList_2
   2456          	{
   2457          		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   \   00000022   0x1D20             ADDS     R0,R4,#+4
   \   00000024   0x.... 0x....      BL       uxListRemove
   2458          		prvAddTaskToReadyList( pxUnblockedTCB );
   \   00000028   0x6AE0             LDR      R0,[R4, #+44]
   \   0000002A   0x6F29             LDR      R1,[R5, #+112]
   \   0000002C   0x4281             CMP      R1,R0
   \   0000002E   0xD200             BCS      ??xTaskRemoveFromEventList_3
   \   00000030   0x6728             STR      R0,[R5, #+112]
   \                     ??xTaskRemoveFromEventList_3: (+1)
   \   00000032   0x1D21             ADDS     R1,R4,#+4
   \   00000034   0x6AE0             LDR      R0,[R4, #+44]
   \   00000036   0x0082             LSLS     R2,R0,#+2
   \   00000038   0x1810             ADDS     R0,R2,R0
   \   0000003A   0x0080             LSLS     R0,R0,#+2
   \   0000003C   0x1828             ADDS     R0,R5,R0
   \   0000003E   0x1D00             ADDS     R0,R0,#+4
   \   00000040   0xE002             B        ??xTaskRemoveFromEventList_4
   2459          	}
   2460          	else
   2461          	{
   2462          		/* The delayed and ready lists cannot be accessed, so hold this task
   2463          		pending until the scheduler is resumed. */
   2464          		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   \                     ??xTaskRemoveFromEventList_2: (+1)
   \   00000042   0x0021             MOVS     R1,R4
   \   00000044   0x3118             ADDS     R1,R1,#+24
   \   00000046   0x....             LDR      R0,??DataTable23
   \                     ??xTaskRemoveFromEventList_4: (+1)
   \   00000048   0x.... 0x....      BL       vListInsertEnd
   2465          	}
   2466          
   2467          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   \   0000004C   0x6828             LDR      R0,[R5, #+0]
   \   0000004E   0x6AC0             LDR      R0,[R0, #+44]
   \   00000050   0x6AE1             LDR      R1,[R4, #+44]
   \   00000052   0x4288             CMP      R0,R1
   \   00000054   0xD202             BCS      ??xTaskRemoveFromEventList_5
   2468          	{
   2469          		/* Return true if the task removed from the event list has a higher
   2470          		priority than the calling task.  This allows the calling task to know if
   2471          		it should force a context switch now. */
   2472          		xReturn = pdTRUE;
   \   00000056   0x2001             MOVS     R0,#+1
   2473          
   2474          		/* Mark that a yield is pending in case the user is not using the
   2475          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   2476          		xYieldPending = pdTRUE;
   \   00000058   0x6768             STR      R0,[R5, #+116]
   \   0000005A   0xE000             B        ??xTaskRemoveFromEventList_6
   2477          	}
   2478          	else
   2479          	{
   2480          		xReturn = pdFALSE;
   \                     ??xTaskRemoveFromEventList_5: (+1)
   \   0000005C   0x2000             MOVS     R0,#+0
   2481          	}
   2482          
   2483          	#if( configUSE_TICKLESS_IDLE == 1 )
   2484          	{
   2485          		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
   2486          		might be set to the blocked task's time out time.  If the task is
   2487          		unblocked for a reason other than a timeout xNextTaskUnblockTime is
   2488          		normally left unchanged, because it is automatically get reset to a new
   2489          		value when the tick count equals xNextTaskUnblockTime.  However if
   2490          		tickless idling is used it might be more important to enter sleep mode
   2491          		at the earliest possible time - so reset xNextTaskUnblockTime here to
   2492          		ensure it is updated at the earliest possible time. */
   2493          		prvResetNextTaskUnblockTime();
   2494          	}
   2495          	#endif
   2496          
   2497          	return xReturn;
   \                     ??xTaskRemoveFromEventList_6: (+1)
   \   0000005E   0xB001             ADD      SP,SP,#+4
   \   00000060   0xBD30             POP      {R4,R5,PC}       ;; return
   2498          }
   2499          /*-----------------------------------------------------------*/
   2500          

   \                                 In section .text, align 4, keep-with-next
   2501          BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
   2502          {
   \                     xTaskRemoveFromUnorderedEventList: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   2503          TCB_t *pxUnblockedTCB;
   2504          BaseType_t xReturn;
   2505          
   2506          	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
   2507          	the event flags implementation. */
   2508          	configASSERT( uxSchedulerSuspended != pdFALSE );
   \   00000004   0x....             LDR      R4,??DataTable31
   \   00000006   0x2280             MOVS     R2,#+128
   \   00000008   0x58A2             LDR      R2,[R4, R2]
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD101             BNE      ??xTaskRemoveFromUnorderedEventList_0
   \   0000000E   0xB672             cpsid i
   \                     ??xTaskRemoveFromUnorderedEventList_1: (+1)
   \   00000010   0xE7FE             B        ??xTaskRemoveFromUnorderedEventList_1
   2509          
   2510          	/* Store the new item value in the event list. */
   2511          	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
   \                     ??xTaskRemoveFromUnorderedEventList_0: (+1)
   \   00000012   0x2280             MOVS     R2,#+128
   \   00000014   0x0612             LSLS     R2,R2,#+24       ;; #-2147483648
   \   00000016   0x430A             ORRS     R2,R2,R1
   \   00000018   0x6002             STR      R2,[R0, #+0]
   2512          
   2513          	/* Remove the event list form the event flag.  Interrupts do not access
   2514          	event flags. */
   2515          	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
   \   0000001A   0x68C5             LDR      R5,[R0, #+12]
   2516          	configASSERT( pxUnblockedTCB );
   \   0000001C   0x2D00             CMP      R5,#+0
   \   0000001E   0xD101             BNE      ??xTaskRemoveFromUnorderedEventList_2
   \   00000020   0xB672             cpsid i
   \                     ??xTaskRemoveFromUnorderedEventList_3: (+1)
   \   00000022   0xE7FE             B        ??xTaskRemoveFromUnorderedEventList_3
   2517          	( void ) uxListRemove( pxEventListItem );
   \                     ??xTaskRemoveFromUnorderedEventList_2: (+1)
   \   00000024   0x.... 0x....      BL       uxListRemove
   2518          
   2519          	/* Remove the task from the delayed list and add it to the ready list.  The
   2520          	scheduler is suspended so interrupts will not be accessing the ready
   2521          	lists. */
   2522          	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   \   00000028   0x1D28             ADDS     R0,R5,#+4
   \   0000002A   0x.... 0x....      BL       uxListRemove
   2523          	prvAddTaskToReadyList( pxUnblockedTCB );
   \   0000002E   0x6AE8             LDR      R0,[R5, #+44]
   \   00000030   0x6F21             LDR      R1,[R4, #+112]
   \   00000032   0x4281             CMP      R1,R0
   \   00000034   0xD200             BCS      ??xTaskRemoveFromUnorderedEventList_4
   \   00000036   0x6720             STR      R0,[R4, #+112]
   \                     ??xTaskRemoveFromUnorderedEventList_4: (+1)
   \   00000038   0x1D29             ADDS     R1,R5,#+4
   \   0000003A   0x6AE8             LDR      R0,[R5, #+44]
   \   0000003C   0x0082             LSLS     R2,R0,#+2
   \   0000003E   0x1810             ADDS     R0,R2,R0
   \   00000040   0x0080             LSLS     R0,R0,#+2
   \   00000042   0x1820             ADDS     R0,R4,R0
   \   00000044   0x1D00             ADDS     R0,R0,#+4
   \   00000046   0x.... 0x....      BL       vListInsertEnd
   2524          
   2525          	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   \   0000004A   0x6820             LDR      R0,[R4, #+0]
   \   0000004C   0x6AC0             LDR      R0,[R0, #+44]
   \   0000004E   0x6AE9             LDR      R1,[R5, #+44]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD202             BCS      ??xTaskRemoveFromUnorderedEventList_5
   2526          	{
   2527          		/* Return true if the task removed from the event list has
   2528          		a higher priority than the calling task.  This allows
   2529          		the calling task to know if it should force a context
   2530          		switch now. */
   2531          		xReturn = pdTRUE;
   \   00000054   0x2001             MOVS     R0,#+1
   2532          
   2533          		/* Mark that a yield is pending in case the user is not using the
   2534          		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
   2535          		xYieldPending = pdTRUE;
   \   00000056   0x6760             STR      R0,[R4, #+116]
   \   00000058   0xE000             B        ??xTaskRemoveFromUnorderedEventList_6
   2536          	}
   2537          	else
   2538          	{
   2539          		xReturn = pdFALSE;
   \                     ??xTaskRemoveFromUnorderedEventList_5: (+1)
   \   0000005A   0x2000             MOVS     R0,#+0
   2540          	}
   2541          
   2542          	return xReturn;
   \                     ??xTaskRemoveFromUnorderedEventList_6: (+1)
   \   0000005C   0xB001             ADD      SP,SP,#+4
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return
   2543          }
   2544          /*-----------------------------------------------------------*/
   2545          

   \                                 In section .text, align 4, keep-with-next
   2546          void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
   2547          {
   2548          	configASSERT( pxTimeOut );
   \                     vTaskSetTimeOutState: (+1)
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD101             BNE      ??vTaskSetTimeOutState_0
   \   00000004   0xB672             cpsid i
   \                     ??vTaskSetTimeOutState_1: (+1)
   \   00000006   0xE7FE             B        ??vTaskSetTimeOutState_1
   2549          	pxTimeOut->xOverflowCount = xNumOfOverflows;
   \                     ??vTaskSetTimeOutState_0: (+1)
   \   00000008   0x....             LDR      R1,??DataTable35
   \   0000000A   0x6B8A             LDR      R2,[R1, #+56]
   \   0000000C   0x6002             STR      R2,[R0, #+0]
   2550          	pxTimeOut->xTimeOnEntering = xTickCount;
   \   0000000E   0x6AC9             LDR      R1,[R1, #+44]
   \   00000010   0x6041             STR      R1,[R0, #+4]
   2551          }
   \   00000012   0x4770             BX       LR               ;; return
   2552          /*-----------------------------------------------------------*/
   2553          

   \                                 In section .text, align 4, keep-with-next
   2554          BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
   2555          {
   \                     xTaskCheckForTimeOut: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000C             MOVS     R4,R1
   2556          BaseType_t xReturn;
   2557          
   2558          	configASSERT( pxTimeOut );
   \   00000006   0x2D00             CMP      R5,#+0
   \   00000008   0xD101             BNE      ??xTaskCheckForTimeOut_0
   \   0000000A   0xB672             cpsid i
   \                     ??xTaskCheckForTimeOut_1: (+1)
   \   0000000C   0xE7FE             B        ??xTaskCheckForTimeOut_1
   2559          	configASSERT( pxTicksToWait );
   \                     ??xTaskCheckForTimeOut_0: (+1)
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD101             BNE      ??xTaskCheckForTimeOut_2
   \   00000012   0xB672             cpsid i
   \                     ??xTaskCheckForTimeOut_3: (+1)
   \   00000014   0xE7FE             B        ??xTaskCheckForTimeOut_3
   2560          
   2561          	taskENTER_CRITICAL();
   \                     ??xTaskCheckForTimeOut_2: (+1)
   \   00000016   0x.... 0x....      BL       vPortEnterCritical
   2562          	{
   2563          		/* Minor optimisation.  The tick count cannot change in this block. */
   2564          		const TickType_t xConstTickCount = xTickCount;
   \   0000001A   0x....             LDR      R3,??DataTable36
   \   0000001C   0x6AD8             LDR      R0,[R3, #+44]
   2565          
   2566          		#if ( INCLUDE_vTaskSuspend == 1 )
   2567          			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
   2568          			the maximum block time then the task should block indefinitely, and
   2569          			therefore never time out. */
   2570          			if( *pxTicksToWait == portMAX_DELAY )
   \   0000001E   0x6821             LDR      R1,[R4, #+0]
   \   00000020   0x2200             MOVS     R2,#+0
   \   00000022   0x43D2             MVNS     R2,R2            ;; #-1
   \   00000024   0x4291             CMP      R1,R2
   \   00000026   0xD00F             BEQ      ??xTaskCheckForTimeOut_4
   2571          			{
   2572          				xReturn = pdFALSE;
   2573          			}
   2574          			else /* We are not blocking indefinitely, perform the checks below. */
   2575          		#endif
   2576          
   2577          		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   \   00000028   0x686A             LDR      R2,[R5, #+4]
   \   0000002A   0x6B9B             LDR      R3,[R3, #+56]
   \   0000002C   0x682E             LDR      R6,[R5, #+0]
   \   0000002E   0x42B3             CMP      R3,R6
   \   00000030   0xD001             BEQ      ??xTaskCheckForTimeOut_5
   \   00000032   0x4290             CMP      R0,R2
   \   00000034   0xD20A             BCS      ??xTaskCheckForTimeOut_6
   2578          		{
   2579          			/* The tick count is greater than the time at which vTaskSetTimeout()
   2580          			was called, but has also overflowed since vTaskSetTimeOut() was called.
   2581          			It must have wrapped all the way around and gone past us again. This
   2582          			passed since vTaskSetTimeout() was called. */
   2583          			xReturn = pdTRUE;
   2584          		}
   2585          		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
   \                     ??xTaskCheckForTimeOut_5: (+1)
   \   00000036   0x1A83             SUBS     R3,R0,R2
   \   00000038   0x428B             CMP      R3,R1
   \   0000003A   0xD207             BCS      ??xTaskCheckForTimeOut_6
   2586          		{
   2587          			/* Not a genuine timeout. Adjust parameters for time remaining. */
   2588          			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
   \   0000003C   0x1A08             SUBS     R0,R1,R0
   \   0000003E   0x1880             ADDS     R0,R0,R2
   \   00000040   0x6020             STR      R0,[R4, #+0]
   2589          			vTaskSetTimeOutState( pxTimeOut );
   \   00000042   0x0028             MOVS     R0,R5
   \   00000044   0x.... 0x....      BL       vTaskSetTimeOutState
   2590          			xReturn = pdFALSE;
   \                     ??xTaskCheckForTimeOut_4: (+1)
   \   00000048   0x2400             MOVS     R4,#+0
   \   0000004A   0xE000             B        ??xTaskCheckForTimeOut_7
   2591          		}
   2592          		else
   2593          		{
   2594          			xReturn = pdTRUE;
   \                     ??xTaskCheckForTimeOut_6: (+1)
   \   0000004C   0x2401             MOVS     R4,#+1
   2595          		}
   2596          	}
   2597          	taskEXIT_CRITICAL();
   \                     ??xTaskCheckForTimeOut_7: (+1)
   \   0000004E   0x.... 0x....      BL       vPortExitCritical
   2598          
   2599          	return xReturn;
   \   00000052   0x0020             MOVS     R0,R4
   \   00000054   0xBD70             POP      {R4-R6,PC}       ;; return
   2600          }
   2601          /*-----------------------------------------------------------*/
   2602          

   \                                 In section .text, align 2, keep-with-next
   2603          void vTaskMissedYield( void )
   2604          {
   2605          	xYieldPending = pdTRUE;
   \                     vTaskMissedYield: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x....             LDR      R1,??DataTable31
   \   00000004   0x6748             STR      R0,[R1, #+116]
   2606          }
   \   00000006   0x4770             BX       LR               ;; return
   2607          /*-----------------------------------------------------------*/
   2608          
   2609          #if ( configUSE_TRACE_FACILITY == 1 )
   2610          
   2611          	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
   2612          	{
   2613          	UBaseType_t uxReturn;
   2614          	TCB_t *pxTCB;
   2615          
   2616          		if( xTask != NULL )
   2617          		{
   2618          			pxTCB = ( TCB_t * ) xTask;
   2619          			uxReturn = pxTCB->uxTaskNumber;
   2620          		}
   2621          		else
   2622          		{
   2623          			uxReturn = 0U;
   2624          		}
   2625          
   2626          		return uxReturn;
   2627          	}
   2628          
   2629          #endif /* configUSE_TRACE_FACILITY */
   2630          /*-----------------------------------------------------------*/
   2631          
   2632          #if ( configUSE_TRACE_FACILITY == 1 )
   2633          
   2634          	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
   2635          	{
   2636          	TCB_t *pxTCB;
   2637          
   2638          		if( xTask != NULL )
   2639          		{
   2640          			pxTCB = ( TCB_t * ) xTask;
   2641          			pxTCB->uxTaskNumber = uxHandle;
   2642          		}
   2643          	}
   2644          
   2645          #endif /* configUSE_TRACE_FACILITY */
   2646          
   2647          /*
   2648           * -----------------------------------------------------------
   2649           * The Idle task.
   2650           * ----------------------------------------------------------
   2651           *
   2652           * The portTASK_FUNCTION() macro is used to allow port/compiler specific
   2653           * language extensions.  The equivalent prototype for this function is:
   2654           *
   2655           * void prvIdleTask( void *pvParameters );
   2656           *
   2657           */

   \                                 In section .text, align 2, keep-with-next
   2658          static portTASK_FUNCTION( prvIdleTask, pvParameters )
   2659          {
   \                     prvIdleTask: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   2660          	/* Stop warnings. */
   2661          	( void ) pvParameters;
   \   00000002   0x....             LDR      R4,??DataTable31
   2662          
   2663          	for( ;; )
   2664          	{
   2665          		/* See if any tasks have been deleted. */
   2666          		prvCheckTasksWaitingTermination();
   2667          
   2668          		#if ( configUSE_PREEMPTION == 0 )
   2669          		{
   2670          			/* If we are not using preemption we keep forcing a task switch to
   2671          			see if any other task has become available.  If we are using
   2672          			preemption we don't need to do this as any task becoming available
   2673          			will automatically get the processor anyway. */
   2674          			taskYIELD();
   2675          		}
   2676          		#endif /* configUSE_PREEMPTION */
   2677          
   2678          		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
   2679          		{
   2680          			/* When using preemption tasks of equal priority will be
   2681          			timesliced.  If a task that is sharing the idle priority is ready
   2682          			to run then the idle task should yield before the end of the
   2683          			timeslice.
   2684          
   2685          			A critical region is not required here as we are just reading from
   2686          			the list, and an occasional incorrect value will not matter.  If
   2687          			the ready list at the idle priority contains more than one task
   2688          			then a task other than the idle task is ready to execute. */
   2689          			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   \                     ??prvIdleTask_0: (+1)
   \   00000004   0x6860             LDR      R0,[R4, #+4]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD3FC             BCC      ??prvIdleTask_0
   2690          			{
   2691          				taskYIELD();
   \   0000000A   0x.... 0x....      BL       vPortYield
   \   0000000E   0xE7F9             B        ??prvIdleTask_0
   2692          			}
   2693          			else
   2694          			{
   2695          				mtCOVERAGE_TEST_MARKER();
   2696          			}
   2697          		}
   2698          		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
   2699          
   2700          		#if ( configUSE_IDLE_HOOK == 1 )
   2701          		{
   2702          			extern void vApplicationIdleHook( void );
   2703          
   2704          			/* Call the user defined function from within the idle task.  This
   2705          			allows the application designer to add background functionality
   2706          			without the overhead of a separate task.
   2707          			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
   2708          			CALL A FUNCTION THAT MIGHT BLOCK. */
   2709          			vApplicationIdleHook();
   2710          		}
   2711          		#endif /* configUSE_IDLE_HOOK */
   2712          
   2713          		/* This conditional compilation should use inequality to 0, not equality
   2714          		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
   2715          		user defined low power mode	implementations require
   2716          		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
   2717          		#if ( configUSE_TICKLESS_IDLE != 0 )
   2718          		{
   2719          		TickType_t xExpectedIdleTime;
   2720          
   2721          			/* It is not desirable to suspend then resume the scheduler on
   2722          			each iteration of the idle task.  Therefore, a preliminary
   2723          			test of the expected idle time is performed without the
   2724          			scheduler suspended.  The result here is not necessarily
   2725          			valid. */
   2726          			xExpectedIdleTime = prvGetExpectedIdleTime();
   2727          
   2728          			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2729          			{
   2730          				vTaskSuspendAll();
   2731          				{
   2732          					/* Now the scheduler is suspended, the expected idle
   2733          					time can be sampled again, and this time its value can
   2734          					be used. */
   2735          					configASSERT( xNextTaskUnblockTime >= xTickCount );
   2736          					xExpectedIdleTime = prvGetExpectedIdleTime();
   2737          
   2738          					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
   2739          					{
   2740          						traceLOW_POWER_IDLE_BEGIN();
   2741          						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
   2742          						traceLOW_POWER_IDLE_END();
   2743          					}
   2744          					else
   2745          					{
   2746          						mtCOVERAGE_TEST_MARKER();
   2747          					}
   2748          				}
   2749          				( void ) xTaskResumeAll();
   2750          			}
   2751          			else
   2752          			{
   2753          				mtCOVERAGE_TEST_MARKER();
   2754          			}
   2755          		}
   2756          		#endif /* configUSE_TICKLESS_IDLE */
   2757          	}
   2758          }
   2759          /*-----------------------------------------------------------*/
   2760          
   2761          #if configUSE_TICKLESS_IDLE != 0
   2762          
   2763          	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
   2764          	{
   2765          	eSleepModeStatus eReturn = eStandardSleep;
   2766          
   2767          		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
   2768          		{
   2769          			/* A task was made ready while the scheduler was suspended. */
   2770          			eReturn = eAbortSleep;
   2771          		}
   2772          		else if( xYieldPending != pdFALSE )
   2773          		{
   2774          			/* A yield was pended while the scheduler was suspended. */
   2775          			eReturn = eAbortSleep;
   2776          		}
   2777          		else
   2778          		{
   2779          			#if configUSE_TIMERS == 0
   2780          			{
   2781          				/* The idle task exists in addition to the application tasks. */
   2782          				const UBaseType_t uxNonApplicationTasks = 1;
   2783          
   2784          				/* If timers are not being used and all the tasks are in the
   2785          				suspended list (which might mean they have an infinite block
   2786          				time rather than actually being suspended) then it is safe to
   2787          				turn all clocks off and just wait for external interrupts. */
   2788          				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
   2789          				{
   2790          					eReturn = eNoTasksWaitingTimeout;
   2791          				}
   2792          				else
   2793          				{
   2794          					mtCOVERAGE_TEST_MARKER();
   2795          				}
   2796          			}
   2797          			#endif /* configUSE_TIMERS */
   2798          		}
   2799          
   2800          		return eReturn;
   2801          	}
   2802          #endif /* configUSE_TICKLESS_IDLE */
   2803          /*-----------------------------------------------------------*/
   2804          
   2805          static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
   2806          {
   2807          UBaseType_t x;
   2808          
   2809          	/* Store the task name in the TCB. */
   2810          	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   2811          	{
   2812          		pxTCB->pcTaskName[ x ] = pcName[ x ];
   2813          
   2814          		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
   2815          		configMAX_TASK_NAME_LEN characters just in case the memory after the
   2816          		string is not accessible (extremely unlikely). */
   2817          		if( pcName[ x ] == 0x00 )
   2818          		{
   2819          			break;
   2820          		}
   2821          		else
   2822          		{
   2823          			mtCOVERAGE_TEST_MARKER();
   2824          		}
   2825          	}
   2826          
   2827          	/* Ensure the name string is terminated in the case that the string length
   2828          	was greater or equal to configMAX_TASK_NAME_LEN. */
   2829          	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   2830          
   2831          	/* This is used as an array index so must ensure it's not too large.  First
   2832          	remove the privilege bit if one is present. */
   2833          	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   2834          	{
   2835          		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   2836          	}
   2837          	else
   2838          	{
   2839          		mtCOVERAGE_TEST_MARKER();
   2840          	}
   2841          
   2842          	pxTCB->uxPriority = uxPriority;
   2843          	#if ( configUSE_MUTEXES == 1 )
   2844          	{
   2845          		pxTCB->uxBasePriority = uxPriority;
   2846          		pxTCB->uxMutexesHeld = 0;
   2847          	}
   2848          	#endif /* configUSE_MUTEXES */
   2849          
   2850          	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   2851          	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   2852          
   2853          	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
   2854          	back to	the containing TCB from a generic item in a list. */
   2855          	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   2856          
   2857          	/* Event lists are always in priority order. */
   2858          	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   2859          	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   2860          
   2861          	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
   2862          	{
   2863          		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
   2864          	}
   2865          	#endif /* portCRITICAL_NESTING_IN_TCB */
   2866          
   2867          	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
   2868          	{
   2869          		pxTCB->pxTaskTag = NULL;
   2870          	}
   2871          	#endif /* configUSE_APPLICATION_TASK_TAG */
   2872          
   2873          	#if ( configGENERATE_RUN_TIME_STATS == 1 )
   2874          	{
   2875          		pxTCB->ulRunTimeCounter = 0UL;
   2876          	}
   2877          	#endif /* configGENERATE_RUN_TIME_STATS */
   2878          
   2879          	#if ( portUSING_MPU_WRAPPERS == 1 )
   2880          	{
   2881          		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
   2882          	}
   2883          	#else /* portUSING_MPU_WRAPPERS */
   2884          	{
   2885          		( void ) xRegions;
   2886          		( void ) usStackDepth;
   2887          	}
   2888          	#endif /* portUSING_MPU_WRAPPERS */
   2889          
   2890          	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   2891          	{
   2892          		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
   2893          		{
   2894          			pxTCB->pvThreadLocalStoragePointers[ x ] = NULL;
   2895          		}
   2896          	}
   2897          	#endif
   2898          
   2899          	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
   2900          	{
   2901          		pxTCB->ulNotifiedValue = 0;
   2902          		pxTCB->eNotifyState = eNotWaitingNotification;
   2903          	}
   2904          	#endif
   2905          
   2906          	#if ( configUSE_NEWLIB_REENTRANT == 1 )
   2907          	{
   2908          		/* Initialise this task's Newlib reent structure. */
   2909          		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
   2910          	}
   2911          	#endif /* configUSE_NEWLIB_REENTRANT */
   2912          }
   2913          /*-----------------------------------------------------------*/
   2914          
   2915          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   2916          

   \                                 In section .text, align 2, keep-with-next
   2917          	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
   2918          	{
   2919          	TCB_t *pxTCB;
   2920          
   2921          		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
   \                     vTaskSetThreadLocalStoragePointer: (+1)
   \   00000000   0x2905             CMP      R1,#+5
   \   00000002   0xDA06             BGE      ??vTaskSetThreadLocalStoragePointer_0
   2922          		{
   2923          			pxTCB = prvGetTCBFromHandle( xTaskToSet );
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD101             BNE      ??vTaskSetThreadLocalStoragePointer_1
   \   00000008   0x....             LDR      R0,??DataTable31
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   2924          			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
   \                     ??vTaskSetThreadLocalStoragePointer_1: (+1)
   \   0000000C   0x0089             LSLS     R1,R1,#+2
   \   0000000E   0x1840             ADDS     R0,R0,R1
   \   00000010   0x6442             STR      R2,[R0, #+68]
   2925          		}
   2926          	}
   \                     ??vTaskSetThreadLocalStoragePointer_0: (+1)
   \   00000012   0x4770             BX       LR               ;; return
   2927          
   2928          #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
   2929          /*-----------------------------------------------------------*/
   2930          
   2931          #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
   2932          

   \                                 In section .text, align 2, keep-with-next
   2933          	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
   2934          	{
   \                     pvTaskGetThreadLocalStoragePointer: (+1)
   \   00000000   0x0002             MOVS     R2,R0
   2935          	void *pvReturn = NULL;
   \   00000002   0x2000             MOVS     R0,#+0
   2936          	TCB_t *pxTCB;
   2937          
   2938          		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
   \   00000004   0x2905             CMP      R1,#+5
   \   00000006   0xDA06             BGE      ??pvTaskGetThreadLocalStoragePointer_0
   2939          		{
   2940          			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
   \   00000008   0x2A00             CMP      R2,#+0
   \   0000000A   0xD101             BNE      ??pvTaskGetThreadLocalStoragePointer_1
   \   0000000C   0x....             LDR      R0,??DataTable31
   \   0000000E   0x6802             LDR      R2,[R0, #+0]
   2941          			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
   \                     ??pvTaskGetThreadLocalStoragePointer_1: (+1)
   \   00000010   0x0088             LSLS     R0,R1,#+2
   \   00000012   0x1810             ADDS     R0,R2,R0
   \   00000014   0x6C40             LDR      R0,[R0, #+68]
   2942          		}
   2943          		else
   2944          		{
   2945          			pvReturn = NULL;
   2946          		}
   2947          
   2948          		return pvReturn;
   \                     ??pvTaskGetThreadLocalStoragePointer_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return
   2949          	}
   2950          
   2951          #endif /* configNUM_THREAD_LOCAL_STORAGE_POINTERS */
   2952          /*-----------------------------------------------------------*/
   2953          
   2954          #if ( portUSING_MPU_WRAPPERS == 1 )
   2955          
   2956          	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
   2957          	{
   2958          	TCB_t *pxTCB;
   2959          
   2960          		/* If null is passed in here then we are deleting ourselves. */
   2961          		pxTCB = prvGetTCBFromHandle( xTaskToModify );
   2962          
   2963                  vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
   2964          	}
   2965          
   2966          #endif /* portUSING_MPU_WRAPPERS */
   2967          /*-----------------------------------------------------------*/
   2968          
   2969          static void prvInitialiseTaskLists( void )
   2970          {
   2971          UBaseType_t uxPriority;
   2972          
   2973          	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   2974          	{
   2975          		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   2976          	}
   2977          
   2978          	vListInitialise( &xDelayedTaskList1 );
   2979          	vListInitialise( &xDelayedTaskList2 );
   2980          	vListInitialise( &xPendingReadyList );
   2981          
   2982          	#if ( INCLUDE_vTaskDelete == 1 )
   2983          	{
   2984          		vListInitialise( &xTasksWaitingTermination );
   2985          	}
   2986          	#endif /* INCLUDE_vTaskDelete */
   2987          
   2988          	#if ( INCLUDE_vTaskSuspend == 1 )
   2989          	{
   2990          		vListInitialise( &xSuspendedTaskList );
   2991          	}
   2992          	#endif /* INCLUDE_vTaskSuspend */
   2993          
   2994          	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
   2995          	using list2. */
   2996          	pxDelayedTaskList = &xDelayedTaskList1;
   2997          	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   2998          }
   2999          /*-----------------------------------------------------------*/
   3000          
   3001          static void prvCheckTasksWaitingTermination( void )
   3002          {
   3003          	#if ( INCLUDE_vTaskDelete == 1 )
   3004          	{
   3005          		BaseType_t xListIsEmpty;
   3006          
   3007          		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
   3008          		too often in the idle task. */
   3009          		while( uxTasksDeleted > ( UBaseType_t ) 0U )
   3010          		{
   3011          			vTaskSuspendAll();
   3012          			{
   3013          				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   3014          			}
   3015          			( void ) xTaskResumeAll();
   3016          
   3017          			if( xListIsEmpty == pdFALSE )
   3018          			{
   3019          				TCB_t *pxTCB;
   3020          
   3021          				taskENTER_CRITICAL();
   3022          				{
   3023          					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   3024          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   3025          					--uxCurrentNumberOfTasks;
   3026          					--uxTasksDeleted;
   3027          				}
   3028          				taskEXIT_CRITICAL();
   3029          
   3030          				prvDeleteTCB( pxTCB );
   3031          			}
   3032          			else
   3033          			{
   3034          				mtCOVERAGE_TEST_MARKER();
   3035          			}
   3036          		}
   3037          	}
   3038          	#endif /* vTaskDelete */
   3039          }
   3040          /*-----------------------------------------------------------*/
   3041          
   3042          static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
   3043          {
   3044          	/* The list item will be inserted in wake time order. */
   3045          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   3046          
   3047          	if( xTimeToWake < xTickCount )
   3048          	{
   3049          		/* Wake time has overflowed.  Place this item in the overflow list. */
   3050          		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   3051          	}
   3052          	else
   3053          	{
   3054          		/* The wake time has not overflowed, so the current block list is used. */
   3055          		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   3056          
   3057          		/* If the task entering the blocked state was placed at the head of the
   3058          		list of blocked tasks then xNextTaskUnblockTime needs to be updated
   3059          		too. */
   3060          		if( xTimeToWake < xNextTaskUnblockTime )
   3061          		{
   3062          			xNextTaskUnblockTime = xTimeToWake;
   3063          		}
   3064          		else
   3065          		{
   3066          			mtCOVERAGE_TEST_MARKER();
   3067          		}
   3068          	}
   3069          }
   3070          /*-----------------------------------------------------------*/
   3071          
   3072          static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
   3073          {
   3074          TCB_t *pxNewTCB;
   3075          
   3076          	/* If the stack grows down then allocate the stack then the TCB so the stack
   3077          	does not grow into the TCB.  Likewise if the stack grows up then allocate
   3078          	the TCB then the stack. */
   3079          	#if( portSTACK_GROWTH > 0 )
   3080          	{
   3081          		/* Allocate space for the TCB.  Where the memory comes from depends on
   3082          		the implementation of the port malloc function. */
   3083          		pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
   3084          
   3085          		if( pxNewTCB != NULL )
   3086          		{
   3087          			/* Allocate space for the stack used by the task being created.
   3088          			The base of the stack memory stored in the TCB so the task can
   3089          			be deleted later if required. */
   3090          			pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3091          
   3092          			if( pxNewTCB->pxStack == NULL )
   3093          			{
   3094          				/* Could not allocate the stack.  Delete the allocated TCB. */
   3095          				vPortFree( pxNewTCB );
   3096          				pxNewTCB = NULL;
   3097          			}
   3098          		}
   3099          	}
   3100          	#else /* portSTACK_GROWTH */
   3101          	{
   3102          	StackType_t *pxStack;
   3103          
   3104          		/* Allocate space for the stack used by the task being created. */
   3105          		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3106          
   3107          		if( pxStack != NULL )
   3108          		{
   3109          			/* Allocate space for the TCB.  Where the memory comes from depends
   3110          			on the implementation of the port malloc function. */
   3111          			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
   3112          
   3113          			if( pxNewTCB != NULL )
   3114          			{
   3115          				/* Store the stack location in the TCB. */
   3116          				pxNewTCB->pxStack = pxStack;
   3117          			}
   3118          			else
   3119          			{
   3120          				/* The stack cannot be used as the TCB was not created.  Free it
   3121          				again. */
   3122          				vPortFree( pxStack );
   3123          			}
   3124          		}
   3125          		else
   3126          		{
   3127          			pxNewTCB = NULL;
   3128          		}
   3129          	}
   3130          	#endif /* portSTACK_GROWTH */
   3131          
   3132          	if( pxNewTCB != NULL )
   3133          	{
   3134          		/* Avoid dependency on memset() if it is not required. */
   3135          		#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   3136          		{
   3137          			/* Just to help debugging. */
   3138          			( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
   3139          		}
   3140          		#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
   3141          	}
   3142          
   3143          	return pxNewTCB;
   3144          }
   3145          /*-----------------------------------------------------------*/
   3146          
   3147          #if ( configUSE_TRACE_FACILITY == 1 )
   3148          
   3149          	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
   3150          	{
   3151          	volatile TCB_t *pxNextTCB, *pxFirstTCB;
   3152          	UBaseType_t uxTask = 0;
   3153          
   3154          		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
   3155          		{
   3156          			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
   3157          
   3158          			/* Populate an TaskStatus_t structure within the
   3159          			pxTaskStatusArray array for each task that is referenced from
   3160          			pxList.  See the definition of TaskStatus_t in task.h for the
   3161          			meaning of each TaskStatus_t structure member. */
   3162          			do
   3163          			{
   3164          				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
   3165          
   3166          				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
   3167          				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
   3168          				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
   3169          				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
   3170          				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
   3171          
   3172          				#if ( INCLUDE_vTaskSuspend == 1 )
   3173          				{
   3174          					/* If the task is in the suspended list then there is a chance
   3175          					it is actually just blocked indefinitely - so really it should
   3176          					be reported as being in the Blocked state. */
   3177          					if( eState == eSuspended )
   3178          					{
   3179          						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
   3180          						{
   3181          							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
   3182          						}
   3183          					}
   3184          				}
   3185          				#endif /* INCLUDE_vTaskSuspend */
   3186          
   3187          				#if ( configUSE_MUTEXES == 1 )
   3188          				{
   3189          					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
   3190          				}
   3191          				#else
   3192          				{
   3193          					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
   3194          				}
   3195          				#endif
   3196          
   3197          				#if ( configGENERATE_RUN_TIME_STATS == 1 )
   3198          				{
   3199          					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
   3200          				}
   3201          				#else
   3202          				{
   3203          					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
   3204          				}
   3205          				#endif
   3206          
   3207          				#if ( portSTACK_GROWTH > 0 )
   3208          				{
   3209          					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
   3210          				}
   3211          				#else
   3212          				{
   3213          					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
   3214          				}
   3215          				#endif
   3216          
   3217          				uxTask++;
   3218          
   3219          			} while( pxNextTCB != pxFirstTCB );
   3220          		}
   3221          		else
   3222          		{
   3223          			mtCOVERAGE_TEST_MARKER();
   3224          		}
   3225          
   3226          		return uxTask;
   3227          	}
   3228          
   3229          #endif /* configUSE_TRACE_FACILITY */
   3230          /*-----------------------------------------------------------*/
   3231          
   3232          #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
   3233          
   3234          	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
   3235          	{
   3236          	uint32_t ulCount = 0U;
   3237          
   3238          		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
   3239          		{
   3240          			pucStackByte -= portSTACK_GROWTH;
   3241          			ulCount++;
   3242          		}
   3243          
   3244          		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
   3245          
   3246          		return ( uint16_t ) ulCount;
   3247          	}
   3248          
   3249          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
   3250          /*-----------------------------------------------------------*/
   3251          
   3252          #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
   3253          
   3254          	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
   3255          	{
   3256          	TCB_t *pxTCB;
   3257          	uint8_t *pucEndOfStack;
   3258          	UBaseType_t uxReturn;
   3259          
   3260          		pxTCB = prvGetTCBFromHandle( xTask );
   3261          
   3262          		#if portSTACK_GROWTH < 0
   3263          		{
   3264          			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
   3265          		}
   3266          		#else
   3267          		{
   3268          			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
   3269          		}
   3270          		#endif
   3271          
   3272          		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
   3273          
   3274          		return uxReturn;
   3275          	}
   3276          
   3277          #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
   3278          /*-----------------------------------------------------------*/
   3279          
   3280          #if ( INCLUDE_vTaskDelete == 1 )
   3281          
   3282          	static void prvDeleteTCB( TCB_t *pxTCB )
   3283          	{
   3284          		/* This call is required specifically for the TriCore port.  It must be
   3285          		above the vPortFree() calls.  The call is also used by ports/demos that
   3286          		want to allocate and clean RAM statically. */
   3287          		portCLEAN_UP_TCB( pxTCB );
   3288          
   3289          		/* Free up the memory allocated by the scheduler for the task.  It is up
   3290          		to the task to free any memory allocated at the application level. */
   3291          		#if ( configUSE_NEWLIB_REENTRANT == 1 )
   3292          		{
   3293          			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
   3294          		}
   3295          		#endif /* configUSE_NEWLIB_REENTRANT */
   3296          
   3297          		#if( portUSING_MPU_WRAPPERS == 1 )
   3298          		{
   3299          			/* Only free the stack if it was allocated dynamically in the first
   3300          			place. */
   3301          			if( pxTCB->xUsingStaticallyAllocatedStack == pdFALSE )
   3302          			{
   3303          				vPortFreeAligned( pxTCB->pxStack );
   3304          			}
   3305          		}
   3306          		#else
   3307          		{
   3308          			vPortFreeAligned( pxTCB->pxStack );
   3309          		}
   3310          		#endif
   3311          
   3312          		vPortFree( pxTCB );
   3313          	}
   3314          
   3315          #endif /* INCLUDE_vTaskDelete */
   3316          /*-----------------------------------------------------------*/
   3317          
   3318          static void prvResetNextTaskUnblockTime( void )
   3319          {
   3320          TCB_t *pxTCB;
   3321          
   3322          	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   3323          	{
   3324          		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
   3325          		the maximum possible value so it is	extremely unlikely that the
   3326          		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
   3327          		there is an item in the delayed list. */
   3328          		xNextTaskUnblockTime = portMAX_DELAY;
   3329          	}
   3330          	else
   3331          	{
   3332          		/* The new current delayed list is not empty, get the value of
   3333          		the item at the head of the delayed list.  This is the time at
   3334          		which the task at the head of the delayed list should be removed
   3335          		from the Blocked state. */
   3336          		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   3337          		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
   3338          	}
   3339          }
   3340          /*-----------------------------------------------------------*/
   3341          
   3342          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
   3343          

   \                                 In section .text, align 2, keep-with-next
   3344          	TaskHandle_t xTaskGetCurrentTaskHandle( void )
   3345          	{
   3346          	TaskHandle_t xReturn;
   3347          
   3348          		/* A critical section is not required as this is not called from
   3349          		an interrupt and the current TCB will always be the same for any
   3350          		individual execution thread. */
   3351          		xReturn = pxCurrentTCB;
   3352          
   3353          		return xReturn;
   \                     xTaskGetCurrentTaskHandle: (+1)
   \   00000000   0x....             LDR      R0,??DataTable31
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   3354          	}
   3355          
   3356          #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
   3357          /*-----------------------------------------------------------*/
   3358          
   3359          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
   3360          

   \                                 In section .text, align 2, keep-with-next
   3361          	BaseType_t xTaskGetSchedulerState( void )
   3362          	{
   3363          	BaseType_t xReturn;
   3364          
   3365          		if( xSchedulerRunning == pdFALSE )
   \                     xTaskGetSchedulerState: (+1)
   \   00000000   0x....             LDR      R0,??DataTable35
   \   00000002   0x6B00             LDR      R0,[R0, #+48]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD101             BNE      ??xTaskGetSchedulerState_0
   3366          		{
   3367          			xReturn = taskSCHEDULER_NOT_STARTED;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   3368          		}
   3369          		else
   3370          		{
   3371          			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \                     ??xTaskGetSchedulerState_0: (+1)
   \   0000000C   0x....             LDR      R0,??DataTable37
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD101             BNE      ??xTaskGetSchedulerState_1
   3372          			{
   3373          				xReturn = taskSCHEDULER_RUNNING;
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0x4770             BX       LR
   3374          			}
   3375          			else
   3376          			{
   3377          				xReturn = taskSCHEDULER_SUSPENDED;
   \                     ??xTaskGetSchedulerState_1: (+1)
   \   00000018   0x2000             MOVS     R0,#+0
   3378          			}
   3379          		}
   3380          
   3381          		return xReturn;
   \   0000001A   0x4770             BX       LR               ;; return
   3382          	}
   3383          
   3384          #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
   3385          /*-----------------------------------------------------------*/
   3386          
   3387          #if ( configUSE_MUTEXES == 1 )
   3388          
   3389          	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
   3390          	{
   3391          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3392          
   3393          		/* If the mutex was given back by an interrupt while the queue was
   3394          		locked then the mutex holder might now be NULL. */
   3395          		if( pxMutexHolder != NULL )
   3396          		{
   3397          			/* If the holder of the mutex has a priority below the priority of
   3398          			the task attempting to obtain the mutex then it will temporarily
   3399          			inherit the priority of the task attempting to obtain the mutex. */
   3400          			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   3401          			{
   3402          				/* Adjust the mutex holder state to account for its new
   3403          				priority.  Only reset the event list item value if the value is
   3404          				not	being used for anything else. */
   3405          				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   3406          				{
   3407          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3408          				}
   3409          				else
   3410          				{
   3411          					mtCOVERAGE_TEST_MARKER();
   3412          				}
   3413          
   3414          				/* If the task being modified is in the ready state it will need
   3415          				to be moved into a new list. */
   3416          				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   3417          				{
   3418          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3419          					{
   3420          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   3421          					}
   3422          					else
   3423          					{
   3424          						mtCOVERAGE_TEST_MARKER();
   3425          					}
   3426          
   3427          					/* Inherit the priority before being moved into the new list. */
   3428          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   3429          					prvAddTaskToReadyList( pxTCB );
   3430          				}
   3431          				else
   3432          				{
   3433          					/* Just inherit the priority. */
   3434          					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   3435          				}
   3436          
   3437          				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
   3438          			}
   3439          			else
   3440          			{
   3441          				mtCOVERAGE_TEST_MARKER();
   3442          			}
   3443          		}
   3444          		else
   3445          		{
   3446          			mtCOVERAGE_TEST_MARKER();
   3447          		}
   3448          	}
   3449          
   3450          #endif /* configUSE_MUTEXES */
   3451          /*-----------------------------------------------------------*/
   3452          
   3453          #if ( configUSE_MUTEXES == 1 )
   3454          
   3455          	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
   3456          	{
   3457          	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   3458          	BaseType_t xReturn = pdFALSE;
   3459          
   3460          		if( pxMutexHolder != NULL )
   3461          		{
   3462          			/* A task can only have an inherited priority if it holds the mutex.
   3463          			If the mutex is held by a task then it cannot be given from an
   3464          			interrupt, and if a mutex is given by the holding task then it must
   3465          			be the running state task. */
   3466          			configASSERT( pxTCB == pxCurrentTCB );
   3467          
   3468          			configASSERT( pxTCB->uxMutexesHeld );
   3469          			( pxTCB->uxMutexesHeld )--;
   3470          
   3471          			/* Has the holder of the mutex inherited the priority of another
   3472          			task? */
   3473          			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   3474          			{
   3475          				/* Only disinherit if no other mutexes are held. */
   3476          				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   3477          				{
   3478          					/* A task can only have an inherited priority if it holds
   3479          					the mutex.  If the mutex is held by a task then it cannot be
   3480          					given from an interrupt, and if a mutex is given by the
   3481          					holding	task then it must be the running state task.  Remove
   3482          					the	holding task from the ready	list. */
   3483          					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   3484          					{
   3485          						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   3486          					}
   3487          					else
   3488          					{
   3489          						mtCOVERAGE_TEST_MARKER();
   3490          					}
   3491          
   3492          					/* Disinherit the priority before adding the task into the
   3493          					new	ready list. */
   3494          					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
   3495          					pxTCB->uxPriority = pxTCB->uxBasePriority;
   3496          
   3497          					/* Reset the event list item value.  It cannot be in use for
   3498          					any other purpose if this task is running, and it must be
   3499          					running to give back the mutex. */
   3500          					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   3501          					prvAddTaskToReadyList( pxTCB );
   3502          
   3503          					/* Return true to indicate that a context switch is required.
   3504          					This is only actually required in the corner case whereby
   3505          					multiple mutexes were held and the mutexes were given back
   3506          					in an order different to that in which they were taken.
   3507          					If a context switch did not occur when the first mutex was
   3508          					returned, even if a task was waiting on it, then a context
   3509          					switch should occur when the last mutex is returned whether
   3510          					a task is waiting on it or not. */
   3511          					xReturn = pdTRUE;
   3512          				}
   3513          				else
   3514          				{
   3515          					mtCOVERAGE_TEST_MARKER();
   3516          				}
   3517          			}
   3518          			else
   3519          			{
   3520          				mtCOVERAGE_TEST_MARKER();
   3521          			}
   3522          		}
   3523          		else
   3524          		{
   3525          			mtCOVERAGE_TEST_MARKER();
   3526          		}
   3527          
   3528          		return xReturn;
   3529          	}
   3530          
   3531          #endif /* configUSE_MUTEXES */
   3532          /*-----------------------------------------------------------*/
   3533          
   3534          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   3535          
   3536          	void vTaskEnterCritical( void )
   3537          	{
   3538          		portDISABLE_INTERRUPTS();
   3539          
   3540          		if( xSchedulerRunning != pdFALSE )
   3541          		{
   3542          			( pxCurrentTCB->uxCriticalNesting )++;
   3543          
   3544          			/* This is not the interrupt safe version of the enter critical
   3545          			function so	assert() if it is being called from an interrupt
   3546          			context.  Only API functions that end in "FromISR" can be used in an
   3547          			interrupt.  Only assert if the critical nesting count is 1 to
   3548          			protect against recursive calls if the assert function also uses a
   3549          			critical section. */
   3550          			if( pxCurrentTCB->uxCriticalNesting == 1 )
   3551          			{
   3552          				portASSERT_IF_IN_ISR();
   3553          			}
   3554          
   3555          		}
   3556          		else
   3557          		{
   3558          			mtCOVERAGE_TEST_MARKER();
   3559          		}
   3560          	}
   3561          
   3562          #endif /* portCRITICAL_NESTING_IN_TCB */
   3563          /*-----------------------------------------------------------*/
   3564          
   3565          #if ( portCRITICAL_NESTING_IN_TCB == 1 )
   3566          
   3567          	void vTaskExitCritical( void )
   3568          	{
   3569          		if( xSchedulerRunning != pdFALSE )
   3570          		{
   3571          			if( pxCurrentTCB->uxCriticalNesting > 0U )
   3572          			{
   3573          				( pxCurrentTCB->uxCriticalNesting )--;
   3574          
   3575          				if( pxCurrentTCB->uxCriticalNesting == 0U )
   3576          				{
   3577          					portENABLE_INTERRUPTS();
   3578          				}
   3579          				else
   3580          				{
   3581          					mtCOVERAGE_TEST_MARKER();
   3582          				}
   3583          			}
   3584          			else
   3585          			{
   3586          				mtCOVERAGE_TEST_MARKER();
   3587          			}
   3588          		}
   3589          		else
   3590          		{
   3591          			mtCOVERAGE_TEST_MARKER();
   3592          		}
   3593          	}
   3594          
   3595          #endif /* portCRITICAL_NESTING_IN_TCB */
   3596          /*-----------------------------------------------------------*/
   3597          
   3598          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3599          
   3600          	static char *prvWriteNameToBuffer( char *pcBuffer, const char *pcTaskName )
   3601          	{
   3602          	BaseType_t x;
   3603          
   3604          		/* Start by copying the entire string. */
   3605          		strcpy( pcBuffer, pcTaskName );
   3606          
   3607          		/* Pad the end of the string with spaces to ensure columns line up when
   3608          		printed out. */
   3609          		for( x = strlen( pcBuffer ); x < ( configMAX_TASK_NAME_LEN - 1 ); x++ )
   3610          		{
   3611          			pcBuffer[ x ] = ' ';
   3612          		}
   3613          
   3614          		/* Terminate. */
   3615          		pcBuffer[ x ] = 0x00;
   3616          
   3617          		/* Return the new end of string. */
   3618          		return &( pcBuffer[ x ] );
   3619          	}
   3620          
   3621          #endif /* ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) */
   3622          /*-----------------------------------------------------------*/
   3623          
   3624          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3625          
   3626          	void vTaskList( char * pcWriteBuffer )
   3627          	{
   3628          	TaskStatus_t *pxTaskStatusArray;
   3629          	volatile UBaseType_t uxArraySize, x;
   3630          	char cStatus;
   3631          
   3632          		/*
   3633          		 * PLEASE NOTE:
   3634          		 *
   3635          		 * This function is provided for convenience only, and is used by many
   3636          		 * of the demo applications.  Do not consider it to be part of the
   3637          		 * scheduler.
   3638          		 *
   3639          		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
   3640          		 * uxTaskGetSystemState() output into a human readable table that
   3641          		 * displays task names, states and stack usage.
   3642          		 *
   3643          		 * vTaskList() has a dependency on the sprintf() C library function that
   3644          		 * might bloat the code size, use a lot of stack, and provide different
   3645          		 * results on different platforms.  An alternative, tiny, third party,
   3646          		 * and limited functionality implementation of sprintf() is provided in
   3647          		 * many of the FreeRTOS/Demo sub-directories in a file called
   3648          		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
   3649          		 * snprintf() implementation!).
   3650          		 *
   3651          		 * It is recommended that production systems call uxTaskGetSystemState()
   3652          		 * directly to get access to raw stats data, rather than indirectly
   3653          		 * through a call to vTaskList().
   3654          		 */
   3655          
   3656          
   3657          		/* Make sure the write buffer does not contain a string. */
   3658          		*pcWriteBuffer = 0x00;
   3659          
   3660          		/* Take a snapshot of the number of tasks in case it changes while this
   3661          		function is executing. */
   3662          		uxArraySize = uxCurrentNumberOfTasks;
   3663          
   3664          		/* Allocate an array index for each task. */
   3665          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   3666          
   3667          		if( pxTaskStatusArray != NULL )
   3668          		{
   3669          			/* Generate the (binary) data. */
   3670          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
   3671          
   3672          			/* Create a human readable table from the binary data. */
   3673          			for( x = 0; x < uxArraySize; x++ )
   3674          			{
   3675          				switch( pxTaskStatusArray[ x ].eCurrentState )
   3676          				{
   3677          					case eReady:		cStatus = tskREADY_CHAR;
   3678          										break;
   3679          
   3680          					case eBlocked:		cStatus = tskBLOCKED_CHAR;
   3681          										break;
   3682          
   3683          					case eSuspended:	cStatus = tskSUSPENDED_CHAR;
   3684          										break;
   3685          
   3686          					case eDeleted:		cStatus = tskDELETED_CHAR;
   3687          										break;
   3688          
   3689          					default:			/* Should not get here, but it is included
   3690          										to prevent static checking errors. */
   3691          										cStatus = 0x00;
   3692          										break;
   3693          				}
   3694          
   3695          				/* Write the task name to the string, padding with spaces so it
   3696          				can be printed in tabular form more easily. */
   3697          				pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   3698          
   3699          				/* Write the rest of the string. */
   3700          				sprintf( pcWriteBuffer, "\t%c\t%u\t%u\t%u\r\n", cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
   3701          				pcWriteBuffer += strlen( pcWriteBuffer );
   3702          			}
   3703          
   3704          			/* Free the array again. */
   3705          			vPortFree( pxTaskStatusArray );
   3706          		}
   3707          		else
   3708          		{
   3709          			mtCOVERAGE_TEST_MARKER();
   3710          		}
   3711          	}
   3712          
   3713          #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
   3714          /*----------------------------------------------------------*/
   3715          
   3716          #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) )
   3717          
   3718          	void vTaskGetRunTimeStats( char *pcWriteBuffer )
   3719          	{
   3720          	TaskStatus_t *pxTaskStatusArray;
   3721          	volatile UBaseType_t uxArraySize, x;
   3722          	uint32_t ulTotalTime, ulStatsAsPercentage;
   3723          
   3724          		#if( configUSE_TRACE_FACILITY != 1 )
   3725          		{
   3726          			#error configUSE_TRACE_FACILITY must also be set to 1 in freertos_cfg.h to use vTaskGetRunTimeStats().
   3727          		}
   3728          		#endif
   3729          
   3730          		/*
   3731          		 * PLEASE NOTE:
   3732          		 *
   3733          		 * This function is provided for convenience only, and is used by many
   3734          		 * of the demo applications.  Do not consider it to be part of the
   3735          		 * scheduler.
   3736          		 *
   3737          		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
   3738          		 * of the uxTaskGetSystemState() output into a human readable table that
   3739          		 * displays the amount of time each task has spent in the Running state
   3740          		 * in both absolute and percentage terms.
   3741          		 *
   3742          		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
   3743          		 * function that might bloat the code size, use a lot of stack, and
   3744          		 * provide different results on different platforms.  An alternative,
   3745          		 * tiny, third party, and limited functionality implementation of
   3746          		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
   3747          		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
   3748          		 * a full snprintf() implementation!).
   3749          		 *
   3750          		 * It is recommended that production systems call uxTaskGetSystemState()
   3751          		 * directly to get access to raw stats data, rather than indirectly
   3752          		 * through a call to vTaskGetRunTimeStats().
   3753          		 */
   3754          
   3755          		/* Make sure the write buffer does not contain a string. */
   3756          		*pcWriteBuffer = 0x00;
   3757          
   3758          		/* Take a snapshot of the number of tasks in case it changes while this
   3759          		function is executing. */
   3760          		uxArraySize = uxCurrentNumberOfTasks;
   3761          
   3762          		/* Allocate an array index for each task. */
   3763          		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
   3764          
   3765          		if( pxTaskStatusArray != NULL )
   3766          		{
   3767          			/* Generate the (binary) data. */
   3768          			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
   3769          
   3770          			/* For percentage calculations. */
   3771          			ulTotalTime /= 100UL;
   3772          
   3773          			/* Avoid divide by zero errors. */
   3774          			if( ulTotalTime > 0 )
   3775          			{
   3776          				/* Create a human readable table from the binary data. */
   3777          				for( x = 0; x < uxArraySize; x++ )
   3778          				{
   3779          					/* What percentage of the total run time has the task used?
   3780          					This will always be rounded down to the nearest integer.
   3781          					ulTotalRunTimeDiv100 has already been divided by 100. */
   3782          					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
   3783          
   3784          					/* Write the task name to the string, padding with
   3785          					spaces so it can be printed in tabular form more
   3786          					easily. */
   3787          					pcWriteBuffer = prvWriteNameToBuffer( pcWriteBuffer, pxTaskStatusArray[ x ].pcTaskName );
   3788          
   3789          					if( ulStatsAsPercentage > 0UL )
   3790          					{
   3791          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   3792          						{
   3793          							sprintf( pcWriteBuffer, "\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
   3794          						}
   3795          						#else
   3796          						{
   3797          							/* sizeof( int ) == sizeof( long ) so a smaller
   3798          							printf() library can be used. */
   3799          							sprintf( pcWriteBuffer, "\t%u\t\t%u%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
   3800          						}
   3801          						#endif
   3802          					}
   3803          					else
   3804          					{
   3805          						/* If the percentage is zero here then the task has
   3806          						consumed less than 1% of the total run time. */
   3807          						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
   3808          						{
   3809          							sprintf( pcWriteBuffer, "\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].ulRunTimeCounter );
   3810          						}
   3811          						#else
   3812          						{
   3813          							/* sizeof( int ) == sizeof( long ) so a smaller
   3814          							printf() library can be used. */
   3815          							sprintf( pcWriteBuffer, "\t%u\t\t<1%%\r\n", ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
   3816          						}
   3817          						#endif
   3818          					}
   3819          
   3820          					pcWriteBuffer += strlen( pcWriteBuffer );
   3821          				}
   3822          			}
   3823          			else
   3824          			{
   3825          				mtCOVERAGE_TEST_MARKER();
   3826          			}
   3827          
   3828          			/* Free the array again. */
   3829          			vPortFree( pxTaskStatusArray );
   3830          		}
   3831          		else
   3832          		{
   3833          			mtCOVERAGE_TEST_MARKER();
   3834          		}
   3835          	}
   3836          
   3837          #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
   3838          /*-----------------------------------------------------------*/
   3839          

   \                                 In section .text, align 2, keep-with-next
   3840          TickType_t uxTaskResetEventItemValue( void )
   3841          {
   3842          TickType_t uxReturn;
   3843          
   3844          	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
   \                     uxTaskResetEventItemValue: (+1)
   \   00000000   0x....             LDR      R1,??DataTable37_1
   \   00000002   0x6808             LDR      R0,[R1, #+0]
   \   00000004   0x6980             LDR      R0,[R0, #+24]
   3845          
   3846          	/* Reset the event list item to its normal value - so it can be used with
   3847          	queues and semaphores. */
   3848          	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0x2305             MOVS     R3,#+5
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x6AC9             LDR      R1,[R1, #+44]
   \   0000000E   0x1A59             SUBS     R1,R3,R1
   \   00000010   0x6191             STR      R1,[R2, #+24]
   3849          
   3850          	return uxReturn;
   \   00000012   0x4770             BX       LR               ;; return
   3851          }
   3852          /*-----------------------------------------------------------*/
   3853          
   3854          #if ( configUSE_MUTEXES == 1 )
   3855          
   3856          	void *pvTaskIncrementMutexHeldCount( void )
   3857          	{
   3858          		/* If xSemaphoreCreateMutex() is called before any tasks have been created
   3859          		then pxCurrentTCB will be NULL. */
   3860          		if( pxCurrentTCB != NULL )
   3861          		{
   3862          			( pxCurrentTCB->uxMutexesHeld )++;
   3863          		}
   3864          
   3865          		return pxCurrentTCB;
   3866          	}
   3867          
   3868          #endif /* configUSE_MUTEXES */
   3869          /*-----------------------------------------------------------*/
   3870          
   3871          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   3872          

   \                                 In section .text, align 2, keep-with-next
   3873          	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
   3874          	{
   \                     ulTaskNotifyTake: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000E             MOVS     R6,R1
   3875          	TickType_t xTimeToWake;
   3876          	uint32_t ulReturn;
   3877          
   3878          		taskENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       vPortEnterCritical
   3879          		{
   3880          			/* Only block if the notification count is not already non-zero. */
   3881          			if( pxCurrentTCB->ulNotifiedValue == 0UL )
   \   0000000A   0x....             LDR      R5,??DataTable37_1
   \   0000000C   0x6828             LDR      R0,[R5, #+0]
   \   0000000E   0x6D80             LDR      R0,[R0, #+88]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD12B             BNE      ??ulTaskNotifyTake_0
   3882          			{
   3883          				/* Mark this task as waiting for a notification. */
   3884          				pxCurrentTCB->eNotifyState = eWaitingNotification;
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x6829             LDR      R1,[R5, #+0]
   \   00000018   0x315C             ADDS     R1,R1,#+92
   \   0000001A   0x7008             STRB     R0,[R1, #+0]
   3885          
   3886          				if( xTicksToWait > ( TickType_t ) 0 )
   \   0000001C   0x2E00             CMP      R6,#+0
   \   0000001E   0xD025             BEQ      ??ulTaskNotifyTake_0
   3887          				{
   3888          					/* The task is going to block.  First it must be removed
   3889          					from the ready list. */
   3890          					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   \   00000020   0x6828             LDR      R0,[R5, #+0]
   \   00000022   0x1D00             ADDS     R0,R0,#+4
   \   00000024   0x.... 0x....      BL       uxListRemove
   3891          					{
   3892          						/* The current task must be in a ready list, so there is
   3893          						no need to check, and the port reset macro can be called
   3894          						directly. */
   3895          						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   3896          					}
   3897          					else
   3898          					{
   3899          						mtCOVERAGE_TEST_MARKER();
   3900          					}
   3901          
   3902          					#if ( INCLUDE_vTaskSuspend == 1 )
   3903          					{
   3904          						if( xTicksToWait == portMAX_DELAY )
   \   00000028   0x....             LDR      R0,??DataTable36
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000002E   0x428E             CMP      R6,R1
   \   00000030   0xD105             BNE      ??ulTaskNotifyTake_1
   3905          						{
   3906          							/* Add the task to the suspended task list instead
   3907          							of a delayed task list to ensure the task is not
   3908          							woken by a timing event.  It will block
   3909          							indefinitely. */
   3910          							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   \   00000032   0x6829             LDR      R1,[R5, #+0]
   \   00000034   0x1D09             ADDS     R1,R1,#+4
   \   00000036   0x3014             ADDS     R0,R0,#+20
   \   00000038   0x.... 0x....      BL       vListInsertEnd
   \   0000003C   0xE014             B        ??ulTaskNotifyTake_2
   3911          						}
   3912          						else
   3913          						{
   3914          							/* Calculate the time at which the task should be
   3915          							woken if no notification events occur.  This may
   3916          							overflow but this doesn't matter, the scheduler will
   3917          							handle it. */
   3918          							xTimeToWake = xTickCount + xTicksToWait;
   3919          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   \                     ??ulTaskNotifyTake_1: (+1)
   \   0000003E   0x6AC1             LDR      R1,[R0, #+44]
   \   00000040   0x198E             ADDS     R6,R1,R6
   \   00000042   0x6829             LDR      R1,[R5, #+0]
   \   00000044   0x604E             STR      R6,[R1, #+4]
   \   00000046   0x6AC0             LDR      R0,[R0, #+44]
   \   00000048   0x4286             CMP      R6,R0
   \   0000004A   0x6829             LDR      R1,[R5, #+0]
   \   0000004C   0xD204             BCS      ??ulTaskNotifyTake_3
   \   0000004E   0x1D09             ADDS     R1,R1,#+4
   \   00000050   0x6EE8             LDR      R0,[R5, #+108]
   \   00000052   0x.... 0x....      BL       vListInsert
   \   00000056   0xE007             B        ??ulTaskNotifyTake_2
   \                     ??ulTaskNotifyTake_3: (+1)
   \   00000058   0x1D09             ADDS     R1,R1,#+4
   \   0000005A   0x6EA8             LDR      R0,[R5, #+104]
   \   0000005C   0x.... 0x....      BL       vListInsert
   \   00000060   0x6FE8             LDR      R0,[R5, #+124]
   \   00000062   0x4286             CMP      R6,R0
   \   00000064   0xD200             BCS      ??ulTaskNotifyTake_2
   \   00000066   0x67EE             STR      R6,[R5, #+124]
   3920          						}
   3921          					}
   3922          					#else /* INCLUDE_vTaskSuspend */
   3923          					{
   3924          							/* Calculate the time at which the task should be
   3925          							woken if the event does not occur.  This may
   3926          							overflow but this doesn't matter, the scheduler will
   3927          							handle it. */
   3928          							xTimeToWake = xTickCount + xTicksToWait;
   3929          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   3930          					}
   3931          					#endif /* INCLUDE_vTaskSuspend */
   3932          
   3933          					/* All ports are written to allow a yield in a critical
   3934          					section (some will yield immediately, others wait until the
   3935          					critical section exits) - but it is not something that
   3936          					application code should ever do. */
   3937          					portYIELD_WITHIN_API();
   \                     ??ulTaskNotifyTake_2: (+1)
   \   00000068   0x.... 0x....      BL       vPortYield
   3938          				}
   3939          				else
   3940          				{
   3941          					mtCOVERAGE_TEST_MARKER();
   3942          				}
   3943          			}
   3944          			else
   3945          			{
   3946          				mtCOVERAGE_TEST_MARKER();
   3947          			}
   3948          		}
   3949          		taskEXIT_CRITICAL();
   \                     ??ulTaskNotifyTake_0: (+1)
   \   0000006C   0x.... 0x....      BL       vPortExitCritical
   3950          
   3951          		taskENTER_CRITICAL();
   \   00000070   0x.... 0x....      BL       vPortEnterCritical
   3952          		{
   3953          			ulReturn = pxCurrentTCB->ulNotifiedValue;
   \   00000074   0x6828             LDR      R0,[R5, #+0]
   \   00000076   0x6D86             LDR      R6,[R0, #+88]
   3954          
   3955          			if( ulReturn != 0UL )
   \   00000078   0x2E00             CMP      R6,#+0
   \   0000007A   0xD009             BEQ      ??ulTaskNotifyTake_4
   3956          			{
   3957          				if( xClearCountOnExit != pdFALSE )
   \   0000007C   0x2C00             CMP      R4,#+0
   \   0000007E   0xD003             BEQ      ??ulTaskNotifyTake_5
   3958          				{
   3959          					pxCurrentTCB->ulNotifiedValue = 0UL;
   \   00000080   0x2000             MOVS     R0,#+0
   \   00000082   0x6829             LDR      R1,[R5, #+0]
   \   00000084   0x6588             STR      R0,[R1, #+88]
   \   00000086   0xE003             B        ??ulTaskNotifyTake_4
   3960          				}
   3961          				else
   3962          				{
   3963          					( pxCurrentTCB->ulNotifiedValue )--;
   \                     ??ulTaskNotifyTake_5: (+1)
   \   00000088   0x6828             LDR      R0,[R5, #+0]
   \   0000008A   0x6D81             LDR      R1,[R0, #+88]
   \   0000008C   0x1E49             SUBS     R1,R1,#+1
   \   0000008E   0x6581             STR      R1,[R0, #+88]
   3964          				}
   3965          			}
   3966          			else
   3967          			{
   3968          				mtCOVERAGE_TEST_MARKER();
   3969          			}
   3970          
   3971          			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
   \                     ??ulTaskNotifyTake_4: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x6829             LDR      R1,[R5, #+0]
   \   00000094   0x315C             ADDS     R1,R1,#+92
   \   00000096   0x7008             STRB     R0,[R1, #+0]
   3972          		}
   3973          		taskEXIT_CRITICAL();
   \   00000098   0x.... 0x....      BL       vPortExitCritical
   3974          
   3975          		return ulReturn;
   \   0000009C   0x0030             MOVS     R0,R6
   \   0000009E   0xBD70             POP      {R4-R6,PC}       ;; return
   3976          	}
   3977          
   3978          #endif /* configUSE_TASK_NOTIFICATIONS */
   3979          /*-----------------------------------------------------------*/
   3980          
   3981          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   3982          

   \                                 In section .text, align 2, keep-with-next
   3983          	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
   3984          	{
   \                     xTaskNotifyWait: (+1)
   \   00000000   0xB5F4             PUSH     {R2,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000F             MOVS     R7,R1
   \   00000006   0x001E             MOVS     R6,R3
   3985          	TickType_t xTimeToWake;
   3986          	BaseType_t xReturn;
   3987          
   3988          		taskENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       vPortEnterCritical
   3989          		{
   3990          			/* Only block if a notification is not already pending. */
   3991          			if( pxCurrentTCB->eNotifyState != eNotified )
   \   0000000C   0x....             LDR      R5,??DataTable37_1
   \   0000000E   0x6828             LDR      R0,[R5, #+0]
   \   00000010   0x305C             ADDS     R0,R0,#+92
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD02F             BEQ      ??xTaskNotifyWait_0
   3992          			{
   3993          				/* Clear bits in the task's notification value as bits may get
   3994          				set	by the notifying task or interrupt.  This can be used to
   3995          				clear the value to zero. */
   3996          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
   \   00000018   0x6828             LDR      R0,[R5, #+0]
   \   0000001A   0x6D81             LDR      R1,[R0, #+88]
   \   0000001C   0x43A1             BICS     R1,R1,R4
   \   0000001E   0x6581             STR      R1,[R0, #+88]
   3997          
   3998          				/* Mark this task as waiting for a notification. */
   3999          				pxCurrentTCB->eNotifyState = eWaitingNotification;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x6829             LDR      R1,[R5, #+0]
   \   00000024   0x315C             ADDS     R1,R1,#+92
   \   00000026   0x7008             STRB     R0,[R1, #+0]
   4000          
   4001          				if( xTicksToWait > ( TickType_t ) 0 )
   \   00000028   0x2E00             CMP      R6,#+0
   \   0000002A   0xD025             BEQ      ??xTaskNotifyWait_0
   4002          				{
   4003          					/* The task is going to block.  First it must be removed
   4004          					from the	ready list. */
   4005          					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   \   0000002C   0x6828             LDR      R0,[R5, #+0]
   \   0000002E   0x1D00             ADDS     R0,R0,#+4
   \   00000030   0x.... 0x....      BL       uxListRemove
   4006          					{
   4007          						/* The current task must be in a ready list, so there is
   4008          						no need to check, and the port reset macro can be called
   4009          						directly. */
   4010          						portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   4011          					}
   4012          					else
   4013          					{
   4014          						mtCOVERAGE_TEST_MARKER();
   4015          					}
   4016          
   4017          					#if ( INCLUDE_vTaskSuspend == 1 )
   4018          					{
   4019          						if( xTicksToWait == portMAX_DELAY )
   \   00000034   0x....             LDR      R0,??DataTable36
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x43C9             MVNS     R1,R1            ;; #-1
   \   0000003A   0x428E             CMP      R6,R1
   \   0000003C   0xD105             BNE      ??xTaskNotifyWait_1
   4020          						{
   4021          							/* Add the task to the suspended task list instead
   4022          							of a delayed task list to ensure the task is not
   4023          							woken by a timing event.  It will block
   4024          							indefinitely. */
   4025          							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   \   0000003E   0x6829             LDR      R1,[R5, #+0]
   \   00000040   0x1D09             ADDS     R1,R1,#+4
   \   00000042   0x3014             ADDS     R0,R0,#+20
   \   00000044   0x.... 0x....      BL       vListInsertEnd
   \   00000048   0xE014             B        ??xTaskNotifyWait_2
   4026          						}
   4027          						else
   4028          						{
   4029          							/* Calculate the time at which the task should be
   4030          							woken if no notification events occur.  This may
   4031          							overflow but this doesn't matter, the scheduler will
   4032          							handle it. */
   4033          							xTimeToWake = xTickCount + xTicksToWait;
   4034          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   \                     ??xTaskNotifyWait_1: (+1)
   \   0000004A   0x6AC1             LDR      R1,[R0, #+44]
   \   0000004C   0x198C             ADDS     R4,R1,R6
   \   0000004E   0x6829             LDR      R1,[R5, #+0]
   \   00000050   0x604C             STR      R4,[R1, #+4]
   \   00000052   0x6AC0             LDR      R0,[R0, #+44]
   \   00000054   0x4284             CMP      R4,R0
   \   00000056   0x6829             LDR      R1,[R5, #+0]
   \   00000058   0xD204             BCS      ??xTaskNotifyWait_3
   \   0000005A   0x1D09             ADDS     R1,R1,#+4
   \   0000005C   0x6EE8             LDR      R0,[R5, #+108]
   \   0000005E   0x.... 0x....      BL       vListInsert
   \   00000062   0xE007             B        ??xTaskNotifyWait_2
   \                     ??xTaskNotifyWait_3: (+1)
   \   00000064   0x1D09             ADDS     R1,R1,#+4
   \   00000066   0x6EA8             LDR      R0,[R5, #+104]
   \   00000068   0x.... 0x....      BL       vListInsert
   \   0000006C   0x6FE8             LDR      R0,[R5, #+124]
   \   0000006E   0x4284             CMP      R4,R0
   \   00000070   0xD200             BCS      ??xTaskNotifyWait_2
   \   00000072   0x67EC             STR      R4,[R5, #+124]
   4035          						}
   4036          					}
   4037          					#else /* INCLUDE_vTaskSuspend */
   4038          					{
   4039          							/* Calculate the time at which the task should be
   4040          							woken if the event does not occur.  This may
   4041          							overflow but this doesn't matter, the scheduler will
   4042          							handle it. */
   4043          							xTimeToWake = xTickCount + xTicksToWait;
   4044          							prvAddCurrentTaskToDelayedList( xTimeToWake );
   4045          					}
   4046          					#endif /* INCLUDE_vTaskSuspend */
   4047          
   4048          					/* All ports are written to allow a yield in a critical
   4049          					section (some will yield immediately, others wait until the
   4050          					critical section exits) - but it is not something that
   4051          					application code should ever do. */
   4052          					portYIELD_WITHIN_API();
   \                     ??xTaskNotifyWait_2: (+1)
   \   00000074   0x.... 0x....      BL       vPortYield
   4053          				}
   4054          				else
   4055          				{
   4056          					mtCOVERAGE_TEST_MARKER();
   4057          				}
   4058          			}
   4059          			else
   4060          			{
   4061          				mtCOVERAGE_TEST_MARKER();
   4062          			}
   4063          		}
   4064          		taskEXIT_CRITICAL();
   \                     ??xTaskNotifyWait_0: (+1)
   \   00000078   0x.... 0x....      BL       vPortExitCritical
   4065          
   4066          		taskENTER_CRITICAL();
   \   0000007C   0x.... 0x....      BL       vPortEnterCritical
   4067          		{
   4068          			if( pulNotificationValue != NULL )
   \   00000080   0x9800             LDR      R0,[SP, #+0]
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD003             BEQ      ??xTaskNotifyWait_4
   4069          			{
   4070          				/* Output the current notification value, which may or may not
   4071          				have changed. */
   4072          				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
   \   00000086   0x6828             LDR      R0,[R5, #+0]
   \   00000088   0x6D80             LDR      R0,[R0, #+88]
   \   0000008A   0x9900             LDR      R1,[SP, #+0]
   \   0000008C   0x6008             STR      R0,[R1, #+0]
   4073          			}
   4074          
   4075          			/* If eNotifyValue is set then either the task never entered the
   4076          			blocked state (because a notification was already pending) or the
   4077          			task unblocked because of a notification.  Otherwise the task
   4078          			unblocked because of a timeout. */
   4079          			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
   \                     ??xTaskNotifyWait_4: (+1)
   \   0000008E   0x6829             LDR      R1,[R5, #+0]
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x315C             ADDS     R1,R1,#+92
   \   00000094   0x7809             LDRB     R1,[R1, #+0]
   \   00000096   0x2901             CMP      R1,#+1
   \   00000098   0xD101             BNE      ??xTaskNotifyWait_5
   4080          			{
   4081          				/* A notification was not received. */
   4082          				xReturn = pdFALSE;
   \   0000009A   0x2400             MOVS     R4,#+0
   \   0000009C   0xE004             B        ??xTaskNotifyWait_6
   4083          			}
   4084          			else
   4085          			{
   4086          				/* A notification was already pending or a notification was
   4087          				received while the task was waiting. */
   4088          				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
   \                     ??xTaskNotifyWait_5: (+1)
   \   0000009E   0x6829             LDR      R1,[R5, #+0]
   \   000000A0   0x6D8A             LDR      R2,[R1, #+88]
   \   000000A2   0x43BA             BICS     R2,R2,R7
   \   000000A4   0x658A             STR      R2,[R1, #+88]
   4089          				xReturn = pdTRUE;
   \   000000A6   0x2401             MOVS     R4,#+1
   4090          			}
   4091          
   4092          			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
   \                     ??xTaskNotifyWait_6: (+1)
   \   000000A8   0x6829             LDR      R1,[R5, #+0]
   \   000000AA   0x315C             ADDS     R1,R1,#+92
   \   000000AC   0x7008             STRB     R0,[R1, #+0]
   4093          		}
   4094          		taskEXIT_CRITICAL();
   \   000000AE   0x.... 0x....      BL       vPortExitCritical
   4095          
   4096          		return xReturn;
   \   000000B2   0x0020             MOVS     R0,R4
   \   000000B4   0xB001             ADD      SP,SP,#+4
   \   000000B6   0xBDF0             POP      {R4-R7,PC}       ;; return
   4097          	}
   4098          
   4099          #endif /* configUSE_TASK_NOTIFICATIONS */
   4100          /*-----------------------------------------------------------*/
   4101          
   4102          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4103          

   \                                 In section .text, align 4, keep-with-next
   4104          	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
   4105          	{
   \                     xTaskGenericNotify: (+1)
   \   00000000   0xB5FC             PUSH     {R2-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   4106          	TCB_t * pxTCB;
   4107          	eNotifyValue eOriginalNotifyState;
   4108          	BaseType_t xReturn = pdPASS;
   \   00000008   0x2701             MOVS     R7,#+1
   4109          
   4110          		configASSERT( xTaskToNotify );
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE      ??xTaskGenericNotify_0
   \   0000000E   0xB672             cpsid i
   \                     ??xTaskGenericNotify_1: (+1)
   \   00000010   0xE7FE             B        ??xTaskGenericNotify_1
   4111          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4112          
   4113          		taskENTER_CRITICAL();
   \                     ??xTaskGenericNotify_0: (+1)
   \   00000012   0x.... 0x....      BL       vPortEnterCritical
   4114          		{
   4115          			if( pulPreviousNotificationValue != NULL )
   \   00000016   0x0025             MOVS     R5,R4
   \   00000018   0x3528             ADDS     R5,R5,#+40
   \   0000001A   0x9802             LDR      R0,[SP, #+8]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD002             BEQ      ??xTaskGenericNotify_2
   4116          			{
   4117          				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
   \   00000020   0x6B28             LDR      R0,[R5, #+48]
   \   00000022   0x9902             LDR      R1,[SP, #+8]
   \   00000024   0x6008             STR      R0,[R1, #+0]
   4118          			}
   4119          
   4120          			eOriginalNotifyState = pxTCB->eNotifyState;
   \                     ??xTaskGenericNotify_2: (+1)
   \   00000026   0x205C             MOVS     R0,#+92
   \   00000028   0x5C20             LDRB     R0,[R4, R0]
   4121          
   4122          			pxTCB->eNotifyState = eNotified;
   \   0000002A   0x2102             MOVS     R1,#+2
   \   0000002C   0x225C             MOVS     R2,#+92
   \   0000002E   0x54A1             STRB     R1,[R4, R2]
   4123          
   4124          			switch( eAction )
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x7909             LDRB     R1,[R1, #+4]
   \   00000034   0x2901             CMP      R1,#+1
   \   00000036   0xD006             BEQ      ??xTaskGenericNotify_3
   \   00000038   0xD311             BCC      ??xTaskGenericNotify_4
   \   0000003A   0x2903             CMP      R1,#+3
   \   0000003C   0xD00E             BEQ      ??xTaskGenericNotify_5
   \   0000003E   0xD305             BCC      ??xTaskGenericNotify_6
   \   00000040   0x2904             CMP      R1,#+4
   \   00000042   0xD007             BEQ      ??xTaskGenericNotify_7
   \   00000044   0xE00B             B        ??xTaskGenericNotify_4
   4125          			{
   4126          				case eSetBits	:
   4127          					pxTCB->ulNotifiedValue |= ulValue;
   \                     ??xTaskGenericNotify_3: (+1)
   \   00000046   0x6B29             LDR      R1,[R5, #+48]
   \   00000048   0x430E             ORRS     R6,R6,R1
   \   0000004A   0xE007             B        ??xTaskGenericNotify_5
   4128          					break;
   4129          
   4130          				case eIncrement	:
   4131          					( pxTCB->ulNotifiedValue )++;
   \                     ??xTaskGenericNotify_6: (+1)
   \   0000004C   0x6B29             LDR      R1,[R5, #+48]
   \   0000004E   0x1C49             ADDS     R1,R1,#+1
   \   00000050   0x6329             STR      R1,[R5, #+48]
   4132          					break;
   \   00000052   0xE004             B        ??xTaskGenericNotify_4
   4133          
   4134          				case eSetValueWithOverwrite	:
   4135          					pxTCB->ulNotifiedValue = ulValue;
   4136          					break;
   4137          
   4138          				case eSetValueWithoutOverwrite :
   4139          					if( eOriginalNotifyState != eNotified )
   \                     ??xTaskGenericNotify_7: (+1)
   \   00000054   0x2802             CMP      R0,#+2
   \   00000056   0xD101             BNE      ??xTaskGenericNotify_5
   \   00000058   0x2700             MOVS     R7,#+0
   \   0000005A   0xE01F             B        ??xTaskGenericNotify_8
   4140          					{
   4141          						pxTCB->ulNotifiedValue = ulValue;
   \                     ??xTaskGenericNotify_5: (+1)
   \   0000005C   0x632E             STR      R6,[R5, #+48]
   4142          					}
   4143          					else
   4144          					{
   4145          						/* The value could not be written to the task. */
   4146          						xReturn = pdFAIL;
   4147          					}
   4148          					break;
   4149          
   4150          				case eNoAction:
   4151          					/* The task is being notified without its notify value being
   4152          					updated. */
   4153          					break;
   4154          			}
   4155          
   4156          
   4157          			/* If the task is in the blocked state specifically to wait for a
   4158          			notification then unblock it now. */
   4159          			if( eOriginalNotifyState == eWaitingNotification )
   \                     ??xTaskGenericNotify_4: (+1)
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD11C             BNE      ??xTaskGenericNotify_8
   4160          			{
   4161          				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   \   00000062   0x1D20             ADDS     R0,R4,#+4
   \   00000064   0x.... 0x....      BL       uxListRemove
   4162          				prvAddTaskToReadyList( pxTCB );
   \   00000068   0x6868             LDR      R0,[R5, #+4]
   \   0000006A   0x....             LDR      R6,??DataTable38
   \   0000006C   0x6F31             LDR      R1,[R6, #+112]
   \   0000006E   0x4281             CMP      R1,R0
   \   00000070   0xD200             BCS      ??xTaskGenericNotify_9
   \   00000072   0x6730             STR      R0,[R6, #+112]
   \                     ??xTaskGenericNotify_9: (+1)
   \   00000074   0x1D21             ADDS     R1,R4,#+4
   \   00000076   0x0082             LSLS     R2,R0,#+2
   \   00000078   0x1810             ADDS     R0,R2,R0
   \   0000007A   0x0080             LSLS     R0,R0,#+2
   \   0000007C   0x1830             ADDS     R0,R6,R0
   \   0000007E   0x1D00             ADDS     R0,R0,#+4
   \   00000080   0x.... 0x....      BL       vListInsertEnd
   4163          
   4164          				/* The task should not have been on an event list. */
   4165          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   \   00000084   0x6828             LDR      R0,[R5, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD001             BEQ      ??xTaskGenericNotify_10
   \   0000008A   0xB672             cpsid i
   \                     ??xTaskGenericNotify_11: (+1)
   \   0000008C   0xE7FE             B        ??xTaskGenericNotify_11
   4166          
   4167          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   \                     ??xTaskGenericNotify_10: (+1)
   \   0000008E   0x6830             LDR      R0,[R6, #+0]
   \   00000090   0x6AC0             LDR      R0,[R0, #+44]
   \   00000092   0x6869             LDR      R1,[R5, #+4]
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xD201             BCS      ??xTaskGenericNotify_8
   4168          				{
   4169          					/* The notified task has a priority above the currently
   4170          					executing task so a yield is required. */
   4171          					taskYIELD_IF_USING_PREEMPTION();
   \   00000098   0x.... 0x....      BL       vPortYield
   4172          				}
   4173          				else
   4174          				{
   4175          					mtCOVERAGE_TEST_MARKER();
   4176          				}
   4177          			}
   4178          			else
   4179          			{
   4180          				mtCOVERAGE_TEST_MARKER();
   4181          			}
   4182          		}
   4183          		taskEXIT_CRITICAL();
   \                     ??xTaskGenericNotify_8: (+1)
   \   0000009C   0x.... 0x....      BL       vPortExitCritical
   4184          
   4185          		return xReturn;
   \   000000A0   0x0038             MOVS     R0,R7
   \   000000A2   0xB003             ADD      SP,SP,#+12
   \   000000A4   0xBDF0             POP      {R4-R7,PC}       ;; return
   4186          	}
   4187          
   4188          #endif /* configUSE_TASK_NOTIFICATIONS */
   4189          /*-----------------------------------------------------------*/
   4190          
   4191          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4192          

   \                                 In section .text, align 4, keep-with-next
   4193          	BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken )
   4194          	{
   \                     xTaskNotifyFromISR: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000E             MOVS     R6,R1
   \   00000008   0x0015             MOVS     R5,R2
   4195          	TCB_t * pxTCB;
   4196          	eNotifyValue eOriginalNotifyState;
   4197          	BaseType_t xReturn = pdPASS;
   \   0000000A   0x2701             MOVS     R7,#+1
   \   0000000C   0x9700             STR      R7,[SP, #+0]
   4198          	UBaseType_t uxSavedInterruptStatus;
   4199          
   4200          		configASSERT( xTaskToNotify );
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD101             BNE      ??xTaskNotifyFromISR_0
   \   00000012   0xB672             cpsid i
   \                     ??xTaskNotifyFromISR_1: (+1)
   \   00000014   0xE7FE             B        ??xTaskNotifyFromISR_1
   4201          
   4202          		/* RTOS ports that support interrupt nesting have the concept of a
   4203          		maximum	system call (or maximum API call) interrupt priority.
   4204          		Interrupts that are	above the maximum system call priority are keep
   4205          		permanently enabled, even when the RTOS kernel is in a critical section,
   4206          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4207          		is defined in freertos_cfg.h then
   4208          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4209          		failure if a FreeRTOS API function is called from an interrupt that has
   4210          		been assigned a priority above the configured maximum system call
   4211          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4212          		from interrupts	that have been assigned a priority at or (logically)
   4213          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4214          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4215          		simple as possible.  More information (albeit Cortex-M specific) is
   4216          		provided on the following link:
   4217          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4218          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   4219          
   4220          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4221          
   4222          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??xTaskNotifyFromISR_0: (+1)
   \   00000016   0x.... 0x....      BL       ulSetInterruptMaskFromISR
   \   0000001A   0x9001             STR      R0,[SP, #+4]
   4223          		{
   4224          			eOriginalNotifyState = pxTCB->eNotifyState;
   \   0000001C   0x205C             MOVS     R0,#+92
   \   0000001E   0x5C20             LDRB     R0,[R4, R0]
   4225          
   4226          			pxTCB->eNotifyState = eNotified;
   \   00000020   0x2102             MOVS     R1,#+2
   \   00000022   0x225C             MOVS     R2,#+92
   \   00000024   0x54A1             STRB     R1,[R4, R2]
   4227          
   4228          			switch( eAction )
   \   00000026   0x2D01             CMP      R5,#+1
   \   00000028   0xD006             BEQ      ??xTaskNotifyFromISR_2
   \   0000002A   0xD319             BCC      ??xTaskNotifyFromISR_3
   \   0000002C   0x2D03             CMP      R5,#+3
   \   0000002E   0xD014             BEQ      ??xTaskNotifyFromISR_4
   \   00000030   0xD308             BCC      ??xTaskNotifyFromISR_5
   \   00000032   0x2D04             CMP      R5,#+4
   \   00000034   0xD00C             BEQ      ??xTaskNotifyFromISR_6
   \   00000036   0xE013             B        ??xTaskNotifyFromISR_3
   4229          			{
   4230          				case eSetBits	:
   4231          					pxTCB->ulNotifiedValue |= ulValue;
   \                     ??xTaskNotifyFromISR_2: (+1)
   \   00000038   0x0025             MOVS     R5,R4
   \   0000003A   0x3528             ADDS     R5,R5,#+40
   \   0000003C   0x6B29             LDR      R1,[R5, #+48]
   \   0000003E   0x430E             ORRS     R6,R6,R1
   \   00000040   0x632E             STR      R6,[R5, #+48]
   4232          					break;
   \   00000042   0xE00D             B        ??xTaskNotifyFromISR_3
   4233          
   4234          				case eIncrement	:
   4235          					( pxTCB->ulNotifiedValue )++;
   \                     ??xTaskNotifyFromISR_5: (+1)
   \   00000044   0x0025             MOVS     R5,R4
   \   00000046   0x3528             ADDS     R5,R5,#+40
   \   00000048   0x6B29             LDR      R1,[R5, #+48]
   \   0000004A   0x1C49             ADDS     R1,R1,#+1
   \   0000004C   0x6329             STR      R1,[R5, #+48]
   4236          					break;
   \   0000004E   0xE007             B        ??xTaskNotifyFromISR_3
   4237          
   4238          				case eSetValueWithOverwrite	:
   4239          					pxTCB->ulNotifiedValue = ulValue;
   4240          					break;
   4241          
   4242          				case eSetValueWithoutOverwrite :
   4243          					if( eOriginalNotifyState != eNotified )
   \                     ??xTaskNotifyFromISR_6: (+1)
   \   00000050   0x2802             CMP      R0,#+2
   \   00000052   0xD102             BNE      ??xTaskNotifyFromISR_4
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x9000             STR      R0,[SP, #+0]
   \   00000058   0xE02D             B        ??xTaskNotifyFromISR_7
   4244          					{
   4245          						pxTCB->ulNotifiedValue = ulValue;
   \                     ??xTaskNotifyFromISR_4: (+1)
   \   0000005A   0x0021             MOVS     R1,R4
   \   0000005C   0x3128             ADDS     R1,R1,#+40
   \   0000005E   0x630E             STR      R6,[R1, #+48]
   4246          					}
   4247          					else
   4248          					{
   4249          						/* The value could not be written to the task. */
   4250          						xReturn = pdFAIL;
   4251          					}
   4252          					break;
   4253          
   4254          				case eNoAction :
   4255          					/* The task is being notified without its notify value being
   4256          					updated. */
   4257          					break;
   4258          			}
   4259          
   4260          
   4261          			/* If the task is in the blocked state specifically to wait for a
   4262          			notification then unblock it now. */
   4263          			if( eOriginalNotifyState == eWaitingNotification )
   \                     ??xTaskNotifyFromISR_3: (+1)
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD128             BNE      ??xTaskNotifyFromISR_7
   4264          			{
   4265          				/* The task should not have been on an event list. */
   4266          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   \   00000064   0x0025             MOVS     R5,R4
   \   00000066   0x3528             ADDS     R5,R5,#+40
   \   00000068   0x6828             LDR      R0,[R5, #+0]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD001             BEQ      ??xTaskNotifyFromISR_8
   \   0000006E   0xB672             cpsid i
   \                     ??xTaskNotifyFromISR_9: (+1)
   \   00000070   0xE7FE             B        ??xTaskNotifyFromISR_9
   4267          
   4268          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \                     ??xTaskNotifyFromISR_8: (+1)
   \   00000072   0x....             LDR      R6,??DataTable37_1
   \   00000074   0x2080             MOVS     R0,#+128
   \   00000076   0x5830             LDR      R0,[R6, R0]
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD10E             BNE      ??xTaskNotifyFromISR_10
   4269          				{
   4270          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   \   0000007C   0x1D20             ADDS     R0,R4,#+4
   \   0000007E   0x.... 0x....      BL       uxListRemove
   4271          					prvAddTaskToReadyList( pxTCB );
   \   00000082   0x6868             LDR      R0,[R5, #+4]
   \   00000084   0x6F31             LDR      R1,[R6, #+112]
   \   00000086   0x4281             CMP      R1,R0
   \   00000088   0xD200             BCS      ??xTaskNotifyFromISR_11
   \   0000008A   0x6730             STR      R0,[R6, #+112]
   \                     ??xTaskNotifyFromISR_11: (+1)
   \   0000008C   0x1D21             ADDS     R1,R4,#+4
   \   0000008E   0x0082             LSLS     R2,R0,#+2
   \   00000090   0x1810             ADDS     R0,R2,R0
   \   00000092   0x0080             LSLS     R0,R0,#+2
   \   00000094   0x1830             ADDS     R0,R6,R0
   \   00000096   0x1D00             ADDS     R0,R0,#+4
   \   00000098   0xE002             B        ??xTaskNotifyFromISR_12
   4272          				}
   4273          				else
   4274          				{
   4275          					/* The delayed and ready lists cannot be accessed, so hold
   4276          					this task pending until the scheduler is resumed. */
   4277          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   \                     ??xTaskNotifyFromISR_10: (+1)
   \   0000009A   0x3418             ADDS     R4,R4,#+24
   \   0000009C   0x0021             MOVS     R1,R4
   \   0000009E   0x....             LDR      R0,??DataTable38_1
   \                     ??xTaskNotifyFromISR_12: (+1)
   \   000000A0   0x.... 0x....      BL       vListInsertEnd
   4278          				}
   4279          
   4280          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   \   000000A4   0x6830             LDR      R0,[R6, #+0]
   \   000000A6   0x6AC0             LDR      R0,[R0, #+44]
   \   000000A8   0x6869             LDR      R1,[R5, #+4]
   \   000000AA   0x4288             CMP      R0,R1
   \   000000AC   0xD203             BCS      ??xTaskNotifyFromISR_7
   4281          				{
   4282          					/* The notified task has a priority above the currently
   4283          					executing task so a yield is required. */
   4284          					if( pxHigherPriorityTaskWoken != NULL )
   \   000000AE   0x9802             LDR      R0,[SP, #+8]
   \   000000B0   0x2800             CMP      R0,#+0
   \   000000B2   0xD000             BEQ      ??xTaskNotifyFromISR_7
   4285          					{
   4286          						*pxHigherPriorityTaskWoken = pdTRUE;
   \   000000B4   0x6007             STR      R7,[R0, #+0]
   4287          					}
   4288          				}
   4289          				else
   4290          				{
   4291          					mtCOVERAGE_TEST_MARKER();
   4292          				}
   4293          			}
   4294          		}
   4295          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??xTaskNotifyFromISR_7: (+1)
   \   000000B6   0x9801             LDR      R0,[SP, #+4]
   \   000000B8   0x.... 0x....      BL       vClearInterruptMaskFromISR
   4296          
   4297          		return xReturn;
   \   000000BC   0x9800             LDR      R0,[SP, #+0]
   \   000000BE   0xB003             ADD      SP,SP,#+12
   \   000000C0   0xBDF0             POP      {R4-R7,PC}       ;; return
   4298          	}
   4299          
   4300          #endif /* configUSE_TASK_NOTIFICATIONS */
   4301          /*-----------------------------------------------------------*/
   4302          
   4303          #if( configUSE_TASK_NOTIFICATIONS == 1 )
   4304          

   \                                 In section .text, align 4, keep-with-next
   4305          	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
   4306          	{
   \                     vTaskNotifyGiveFromISR: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000F             MOVS     R7,R1
   4307          	TCB_t * pxTCB;
   4308          	eNotifyValue eOriginalNotifyState;
   4309          	UBaseType_t uxSavedInterruptStatus;
   4310          
   4311          		configASSERT( xTaskToNotify );
   \   00000008   0x2C00             CMP      R4,#+0
   \   0000000A   0xD101             BNE      ??vTaskNotifyGiveFromISR_0
   \   0000000C   0xB672             cpsid i
   \                     ??vTaskNotifyGiveFromISR_1: (+1)
   \   0000000E   0xE7FE             B        ??vTaskNotifyGiveFromISR_1
   4312          
   4313          		/* RTOS ports that support interrupt nesting have the concept of a
   4314          		maximum	system call (or maximum API call) interrupt priority.
   4315          		Interrupts that are	above the maximum system call priority are keep
   4316          		permanently enabled, even when the RTOS kernel is in a critical section,
   4317          		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
   4318          		is defined in freertos_cfg.h then
   4319          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
   4320          		failure if a FreeRTOS API function is called from an interrupt that has
   4321          		been assigned a priority above the configured maximum system call
   4322          		priority.  Only FreeRTOS functions that end in FromISR can be called
   4323          		from interrupts	that have been assigned a priority at or (logically)
   4324          		below the maximum system call interrupt priority.  FreeRTOS maintains a
   4325          		separate interrupt safe API to ensure interrupt entry is as fast and as
   4326          		simple as possible.  More information (albeit Cortex-M specific) is
   4327          		provided on the following link:
   4328          		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
   4329          		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   4330          
   4331          		pxTCB = ( TCB_t * ) xTaskToNotify;
   4332          
   4333          		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   \                     ??vTaskNotifyGiveFromISR_0: (+1)
   \   00000010   0x.... 0x....      BL       ulSetInterruptMaskFromISR
   \   00000014   0x9000             STR      R0,[SP, #+0]
   4334          		{
   4335          			eOriginalNotifyState = pxTCB->eNotifyState;
   \   00000016   0x205C             MOVS     R0,#+92
   \   00000018   0x5C20             LDRB     R0,[R4, R0]
   4336          			pxTCB->eNotifyState = eNotified;
   \   0000001A   0x2102             MOVS     R1,#+2
   \   0000001C   0x225C             MOVS     R2,#+92
   \   0000001E   0x54A1             STRB     R1,[R4, R2]
   4337          
   4338          			/* 'Giving' is equivalent to incrementing a count in a counting
   4339          			semaphore. */
   4340          			( pxTCB->ulNotifiedValue )++;
   \   00000020   0x0026             MOVS     R6,R4
   \   00000022   0x3628             ADDS     R6,R6,#+40
   \   00000024   0x6B31             LDR      R1,[R6, #+48]
   \   00000026   0x1C49             ADDS     R1,R1,#+1
   \   00000028   0x6331             STR      R1,[R6, #+48]
   4341          
   4342          			/* If the task is in the blocked state specifically to wait for a
   4343          			notification then unblock it now. */
   4344          			if( eOriginalNotifyState == eWaitingNotification )
   \   0000002A   0x2801             CMP      R0,#+1
   \   0000002C   0xD126             BNE      ??vTaskNotifyGiveFromISR_2
   4345          			{
   4346          				/* The task should not have been on an event list. */
   4347          				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
   \   0000002E   0x6830             LDR      R0,[R6, #+0]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD001             BEQ      ??vTaskNotifyGiveFromISR_3
   \   00000034   0xB672             cpsid i
   \                     ??vTaskNotifyGiveFromISR_4: (+1)
   \   00000036   0xE7FE             B        ??vTaskNotifyGiveFromISR_4
   4348          
   4349          				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   \                     ??vTaskNotifyGiveFromISR_3: (+1)
   \   00000038   0x....             LDR      R5,??DataTable38
   \   0000003A   0x2080             MOVS     R0,#+128
   \   0000003C   0x5828             LDR      R0,[R5, R0]
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD10E             BNE      ??vTaskNotifyGiveFromISR_5
   4350          				{
   4351          					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   \   00000042   0x1D20             ADDS     R0,R4,#+4
   \   00000044   0x.... 0x....      BL       uxListRemove
   4352          					prvAddTaskToReadyList( pxTCB );
   \   00000048   0x6870             LDR      R0,[R6, #+4]
   \   0000004A   0x6F29             LDR      R1,[R5, #+112]
   \   0000004C   0x4281             CMP      R1,R0
   \   0000004E   0xD200             BCS      ??vTaskNotifyGiveFromISR_6
   \   00000050   0x6728             STR      R0,[R5, #+112]
   \                     ??vTaskNotifyGiveFromISR_6: (+1)
   \   00000052   0x1D21             ADDS     R1,R4,#+4
   \   00000054   0x0082             LSLS     R2,R0,#+2
   \   00000056   0x1810             ADDS     R0,R2,R0
   \   00000058   0x0080             LSLS     R0,R0,#+2
   \   0000005A   0x1828             ADDS     R0,R5,R0
   \   0000005C   0x1D00             ADDS     R0,R0,#+4
   \   0000005E   0xE002             B        ??vTaskNotifyGiveFromISR_7
   4353          				}
   4354          				else
   4355          				{
   4356          					/* The delayed and ready lists cannot be accessed, so hold
   4357          					this task pending until the scheduler is resumed. */
   4358          					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
   \                     ??vTaskNotifyGiveFromISR_5: (+1)
   \   00000060   0x3418             ADDS     R4,R4,#+24
   \   00000062   0x0021             MOVS     R1,R4
   \   00000064   0x....             LDR      R0,??DataTable38_1
   \                     ??vTaskNotifyGiveFromISR_7: (+1)
   \   00000066   0x.... 0x....      BL       vListInsertEnd
   4359          				}
   4360          
   4361          				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
   \   0000006A   0x6828             LDR      R0,[R5, #+0]
   \   0000006C   0x6AC0             LDR      R0,[R0, #+44]
   \   0000006E   0x6871             LDR      R1,[R6, #+4]
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xD203             BCS      ??vTaskNotifyGiveFromISR_2
   4362          				{
   4363          					/* The notified task has a priority above the currently
   4364          					executing task so a yield is required. */
   4365          					if( pxHigherPriorityTaskWoken != NULL )
   \   00000074   0x2F00             CMP      R7,#+0
   \   00000076   0xD001             BEQ      ??vTaskNotifyGiveFromISR_2
   4366          					{
   4367          						*pxHigherPriorityTaskWoken = pdTRUE;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x6038             STR      R0,[R7, #+0]
   4368          					}
   4369          				}
   4370          				else
   4371          				{
   4372          					mtCOVERAGE_TEST_MARKER();
   4373          				}
   4374          			}
   4375          		}
   4376          		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   \                     ??vTaskNotifyGiveFromISR_2: (+1)
   \   0000007C   0x9800             LDR      R0,[SP, #+0]
   \   0000007E   0x.... 0x....      BL       vClearInterruptMaskFromISR
   4377          	}
   \   00000082   0xB001             ADD      SP,SP,#+4
   \   00000084   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     pxCurrentTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     xPendingReadyList+0x14

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x49 0x44          DC8 "IDLE"
   \              0x4C 0x45    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     pxCurrentTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     prvIdleTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     pxCurrentTCB+0x80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   0x........         DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable23_1:
   \   00000000   0x........         DC32     pxCurrentTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   0x........         DC32     pxCurrentTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x........         DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable36:
   \   00000000   0x........         DC32     xPendingReadyList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   0x........         DC32     pxCurrentTCB+0x80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37_1:
   \   00000000   0x........         DC32     pxCurrentTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   0x........         DC32     pxCurrentTCB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \   00000000   0x........         DC32     xPendingReadyList
   4378          
   4379          #endif /* configUSE_TASK_NOTIFICATIONS */
   4380          
   4381          /*-----------------------------------------------------------*/
   4382          
   4383          
   4384          #ifdef FREERTOS_MODULE_TEST
   4385          	#include "tasks_test_access_functions.h"
   4386          #endif
   4387          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   prvIdleTask
         8   -> vPortYield
       4   prvTaskIsTaskSuspended
       0   pvTaskGetThreadLocalStoragePointer
      16   ulTaskNotifyTake
        16   -> uxListRemove
        16   -> vListInsert
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYield
       0   uxTaskGetNumberOfTasks
       8   uxTaskPriorityGet
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
       8   uxTaskPriorityGetFromISR
         8   -> ulSetInterruptMaskFromISR
         8   -> vClearInterruptMaskFromISR
       0   uxTaskResetEventItemValue
      24   vTaskDelay
        24   -> uxListRemove
        24   -> vListInsert
        24   -> vPortYield
        24   -> xTaskResumeAll
      16   vTaskDelayUntil
        16   -> uxListRemove
        16   -> vListInsert
        16   -> vPortYield
        16   -> xTaskResumeAll
       8   vTaskEndScheduler
         8   -> vPortEndScheduler
       0   vTaskMissedYield
      24   vTaskNotifyGiveFromISR
        24   -> ulSetInterruptMaskFromISR
        24   -> uxListRemove
        24   -> vClearInterruptMaskFromISR
        24   -> vListInsertEnd
      16   vTaskPlaceOnEventList
        16   -> uxListRemove
        16   -> vListInsert
        16   -> vListInsertEnd
      16   vTaskPlaceOnEventListRestricted
        16   -> uxListRemove
        16   -> vListInsert
        16   -> vListInsertEnd
      16   vTaskPlaceOnUnorderedEventList
        16   -> uxListRemove
        16   -> vListInsert
        16   -> vListInsertEnd
      24   vTaskPrioritySet
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vPortYield
      16   vTaskResume
        16   -> prvTaskIsTaskSuspended
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYield
       0   vTaskSetThreadLocalStoragePointer
       0   vTaskSetTimeOutState
      24   vTaskStartScheduler
        24   -> xPortStartScheduler
        24   -> xTaskGenericCreate
        24   -> xTimerCreateTimerTask
      16   vTaskSuspend
        16   -> uxListRemove
        16   -> vListInsertEnd
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vPortYield
        16   -> vTaskSwitchContext
       0   vTaskSuspendAll
       0   vTaskSwitchContext
      16   xTaskCheckForTimeOut
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
        16   -> vTaskSetTimeOutState
      32   xTaskGenericCreate
        32   -> pvPortMalloc
        32   -> pxPortInitialiseStack
        32   -> vListInitialise
        32   -> vListInitialiseItem
        32   -> vListInsertEnd
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortFree
        32   -> vPortYield
      32   xTaskGenericNotify
        32   -> uxListRemove
        32   -> vListInsertEnd
        32   -> vPortEnterCritical
        32   -> vPortExitCritical
        32   -> vPortYield
       0   xTaskGetCurrentTaskHandle
       0   xTaskGetSchedulerState
       0   xTaskGetTickCount
       0   xTaskGetTickCountFromISR
      24   xTaskIncrementTick
        24   -> uxListRemove
        24   -> vListInsertEnd
      32   xTaskNotifyFromISR
        32   -> ulSetInterruptMaskFromISR
        32   -> uxListRemove
        32   -> vClearInterruptMaskFromISR
        32   -> vListInsertEnd
      24   xTaskNotifyWait
        24   -> uxListRemove
        24   -> vListInsert
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vPortYield
      16   xTaskRemoveFromEventList
        16   -> uxListRemove
        16   -> vListInsertEnd
      16   xTaskRemoveFromUnorderedEventList
        16   -> uxListRemove
        16   -> vListInsertEnd
      24   xTaskResumeAll
        24   -> uxListRemove
        24   -> vListInsertEnd
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
        24   -> vPortYield
        24   -> xTaskIncrementTick
      24   xTaskResumeFromISR
        24   -> prvTaskIsTaskSuspended
        24   -> ulSetInterruptMaskFromISR
        24   -> uxListRemove
        24   -> vClearInterruptMaskFromISR
        24   -> vListInsertEnd


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable23
       4  ??DataTable23_1
       4  ??DataTable31
       4  ??DataTable35
       4  ??DataTable36
       4  ??DataTable37
       4  ??DataTable37_1
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable7
       8  ?_0
      16  prvIdleTask
      44  prvTaskIsTaskSuspended
      24  pvTaskGetThreadLocalStoragePointer
     172  pxCurrentTCB
          pxReadyTasksLists
          pxDelayedTaskList
          pxOverflowDelayedTaskList
          uxTopReadyPriority
          xYieldPending
          uxTaskNumber
          xNextTaskUnblockTime
          uxSchedulerSuspended
          xDelayedTaskList1
          xDelayedTaskList2
     160  ulTaskNotifyTake
       6  uxTaskGetNumberOfTasks
      26  uxTaskPriorityGet
      26  uxTaskPriorityGetFromISR
      20  uxTaskResetEventItemValue
      98  vTaskDelay
     130  vTaskDelayUntil
      20  vTaskEndScheduler
       8  vTaskMissedYield
     134  vTaskNotifyGiveFromISR
     100  vTaskPlaceOnEventList
      80  vTaskPlaceOnEventListRestricted
     122  vTaskPlaceOnUnorderedEventList
     140  vTaskPrioritySet
      90  vTaskResume
      20  vTaskSetThreadLocalStoragePointer
      20  vTaskSetTimeOutState
      68  vTaskStartScheduler
     140  vTaskSuspend
      10  vTaskSuspendAll
      88  vTaskSwitchContext
      60  xPendingReadyList
          xSuspendedTaskList
          uxCurrentNumberOfTasks
          xTickCount
          xSchedulerRunning
          uxPendedTicks
          xNumOfOverflows
      86  xTaskCheckForTimeOut
     356  xTaskGenericCreate
     166  xTaskGenericNotify
       6  xTaskGetCurrentTaskHandle
      28  xTaskGetSchedulerState
       6  xTaskGetTickCount
       6  xTaskGetTickCountFromISR
     198  xTaskIncrementTick
     194  xTaskNotifyFromISR
     184  xTaskNotifyWait
      98  xTaskRemoveFromEventList
      96  xTaskRemoveFromUnorderedEventList
     168  xTaskResumeAll
     106  xTaskResumeFromISR

 
    60 bytes in section .bss
   172 bytes in section .data
 3 360 bytes in section .text
 
 3 360 bytes of CODE memory
   232 bytes of DATA memory

Errors: none
Warnings: none
