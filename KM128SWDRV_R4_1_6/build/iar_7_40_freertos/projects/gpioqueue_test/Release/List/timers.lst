###############################################################################
#
# IAR ANSI C/C++ Compiler V7.40.3.8902/W32 for ARM        07/Feb/2017  17:55:58
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Freescale\KM128SWDRV_R4_1_6\src\freertos\timers.c
#    Command line =  
#        C:\Freescale\KM128SWDRV_R4_1_6\src\freertos\timers.c
#        --no_size_constraints -D NDEBUG -lCN
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\List\
#        -o
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\Obj\
#        --no_unroll --debug --endian=little --cpu=Cortex-M0+ --no_mem_idioms
#        -e --fpu=None --dlib_config
#        D:\IAR7.4anzhuang\arm\INC\c\DLib_Config_Normal.h -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\common\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\drivers\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\freemaster\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\freertos\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\freertos\iar\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\projects\gpioqueue_test\
#        -I
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\..\..\..\..\src\toolchain\iar\
#        -Ohs --require_prototypes
#    List file    =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\List\timers.lst
#    Object file  =  
#        C:\Freescale\KM128SWDRV_R4_1_6\build\iar_7_40_freertos\projects\gpioqueue_test\Release\Obj\timers.o
#
###############################################################################

C:\Freescale\KM128SWDRV_R4_1_6\src\freertos\timers.c
      1          /*
      2              FreeRTOS V8.2.1 - Copyright (C) 2015 Real Time Engineers Ltd.
      3              All rights reserved
      4          
      5              VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
      6          
      7              This file is part of the FreeRTOS distribution.
      8          
      9              FreeRTOS is free software; you can redistribute it and/or modify it under
     10              the terms of the GNU General Public License (version 2) as published by the
     11              Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
     12          
     13              ***************************************************************************
     14              >>!   NOTE: The modification to the GPL is included to allow you to     !<<
     15              >>!   distribute a combined work that includes FreeRTOS without being   !<<
     16              >>!   obliged to provide the source code for proprietary components     !<<
     17              >>!   outside of the FreeRTOS kernel.                                   !<<
     18              ***************************************************************************
     19          
     20              FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
     21              WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     22              FOR A PARTICULAR PURPOSE.  Full license text is available on the following
     23              link: http://www.freertos.org/a00114.html
     24          
     25              ***************************************************************************
     26               *                                                                       *
     27               *    FreeRTOS provides completely free yet professionally developed,    *
     28               *    robust, strictly quality controlled, supported, and cross          *
     29               *    platform software that is more than just the market leader, it     *
     30               *    is the industry's de facto standard.                               *
     31               *                                                                       *
     32               *    Help yourself get started quickly while simultaneously helping     *
     33               *    to support the FreeRTOS project by purchasing a FreeRTOS           *
     34               *    tutorial book, reference manual, or both:                          *
     35               *    http://www.FreeRTOS.org/Documentation                              *
     36               *                                                                       *
     37              ***************************************************************************
     38          
     39              http://www.FreeRTOS.org/FAQHelp.html - Having a problem?  Start by reading
     40              the FAQ page "My application does not run, what could be wrong?".  Have you
     41              defined configASSERT()?
     42          
     43              http://www.FreeRTOS.org/support - In return for receiving this top quality
     44              embedded software for free we request you assist our global community by
     45              participating in the support forum.
     46          
     47              http://www.FreeRTOS.org/training - Investing in training allows your team to
     48              be as productive as possible as early as possible.  Now you can receive
     49              FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers
     50              Ltd, and the world's leading authority on the world's leading RTOS.
     51          
     52              http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
     53              including FreeRTOS+Trace - an indispensable productivity tool, a DOS
     54              compatible FAT file system, and our tiny thread aware UDP/IP stack.
     55          
     56              http://www.FreeRTOS.org/labs - Where new FreeRTOS products go to incubate.
     57              Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS.
     58          
     59              http://www.OpenRTOS.com - Real Time Engineers ltd. license FreeRTOS to High
     60              Integrity Systems ltd. to sell under the OpenRTOS brand.  Low cost OpenRTOS
     61              licenses offer ticketed support, indemnification and commercial middleware.
     62          
     63              http://www.SafeRTOS.com - High Integrity Systems also provide a safety
     64              engineered and independently SIL3 certified version for use in safety and
     65              mission critical applications that require provable dependability.
     66          
     67              1 tab == 4 spaces!
     68          */
     69          
     70          /* Standard includes. */
     71          #include <stdlib.h>
     72          
     73          /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
     74          all the API functions to use the MPU wrappers.  That should only be done when
     75          task.h is included from an application file. */
     76          #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
     77          
     78          #include "freertos.h"
     79          #include "task.h"
     80          #include "queue.h"
     81          #include "timers.h"
     82          
     83          #if ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )
     84          	#error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function available.
     85          #endif
     86          
     87          /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
     88          MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
     89          header files above, but not in this file, in order to generate the correct
     90          privileged Vs unprivileged linkage and placement. */
     91          #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
     92          
     93          
     94          /* This entire source file will be skipped if the application is not configured
     95          to include software timer functionality.  This #if is closed at the very bottom
     96          of this file.  If you want to include software timer functionality then ensure
     97          configUSE_TIMERS is set to 1 in freertos_cfg.h. */
     98          #if ( configUSE_TIMERS == 1 )
     99          
    100          /* Misc definitions. */
    101          #define tmrNO_DELAY		( TickType_t ) 0U
    102          
    103          /* The definition of the timers themselves. */
    104          typedef struct tmrTimerControl
    105          {
    106          	const char				*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    107          	ListItem_t				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for event management. */
    108          	TickType_t				xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
    109          	UBaseType_t				uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one-shot timer. */
    110          	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
    111          	TimerCallbackFunction_t	pxCallbackFunction;	/*<< The function that will be called when the timer expires. */
    112          	#if( configUSE_TRACE_FACILITY == 1 )
    113          		UBaseType_t			uxTimerNumber;		/*<< An ID assigned by trace tools such as FreeRTOS+Trace */
    114          	#endif
    115          } xTIMER;
    116          
    117          /* The old xTIMER name is maintained above then typedefed to the new Timer_t
    118          name below to enable the use of older kernel aware debuggers. */
    119          typedef xTIMER Timer_t;
    120          
    121          /* The definition of messages that can be sent and received on the timer queue.
    122          Two types of message can be queued - messages that manipulate a software timer,
    123          and messages that request the execution of a non-timer related callback.  The
    124          two message types are defined in two separate structures, xTimerParametersType
    125          and xCallbackParametersType respectively. */
    126          typedef struct tmrTimerParameters
    127          {
    128          	TickType_t			xMessageValue;		/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
    129          	Timer_t *			pxTimer;			/*<< The timer to which the command will be applied. */
    130          } TimerParameter_t;
    131          
    132          
    133          typedef struct tmrCallbackParameters
    134          {
    135          	PendedFunction_t	pxCallbackFunction;	/* << The callback function to execute. */
    136          	void *pvParameter1;						/* << The value that will be used as the callback functions first parameter. */
    137          	uint32_t ulParameter2;					/* << The value that will be used as the callback functions second parameter. */
    138          } CallbackParameters_t;
    139          
    140          /* The structure that contains the two message types, along with an identifier
    141          that is used to determine which message type is valid. */
    142          typedef struct tmrTimerQueueMessage
    143          {
    144          	BaseType_t			xMessageID;			/*<< The command being sent to the timer service task. */
    145          	union
    146          	{
    147          		TimerParameter_t xTimerParameters;
    148          
    149          		/* Don't include xCallbackParameters if it is not going to be used as
    150          		it makes the structure (and therefore the timer queue) larger. */
    151          		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
    152          			CallbackParameters_t xCallbackParameters;
    153          		#endif /* INCLUDE_xTimerPendFunctionCall */
    154          	} u;
    155          } DaemonTaskMessage_t;
    156          
    157          /*lint -e956 A manual analysis and inspection has been used to determine which
    158          static variables must be declared volatile. */
    159          
    160          /* The list in which active timers are stored.  Timers are referenced in expire
    161          time order, with the nearest expiry time at the front of the list.  Only the
    162          timer service task is allowed to access these lists. */
    163          PRIVILEGED_DATA static List_t xActiveTimerList1;
    164          PRIVILEGED_DATA static List_t xActiveTimerList2;
    165          PRIVILEGED_DATA static List_t *pxCurrentTimerList;
    166          PRIVILEGED_DATA static List_t *pxOverflowTimerList;
    167          
    168          /* A queue that is used to send commands to the timer service task. */
    169          PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
    170          
    171          #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
    172          
    173          	PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
    174          
    175          #endif
    176          
    177          /*lint +e956 */
    178          
    179          /*-----------------------------------------------------------*/
    180          
    181          /*
    182           * Initialise the infrastructure used by the timer service task if it has not
    183           * been initialised already.
    184           */
    185          static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
    186          
    187          /*
    188           * The timer service task (daemon).  Timer functionality is controlled by this
    189           * task.  Other tasks communicate with the timer service task using the
    190           * xTimerQueue queue.
    191           */
    192          static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
    193          
    194          /*
    195           * Called by the timer service task to interpret and process a command it
    196           * received on the timer queue.
    197           */
    198          static void	prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
    199          
    200          /*
    201           * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
    202           * depending on if the expire time causes a timer counter overflow.
    203           */
    204          static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime ) PRIVILEGED_FUNCTION;
    205          
    206          /*
    207           * An active timer has reached its expire time.  Reload the timer if it is an
    208           * auto reload timer, then call its callback.
    209           */
    210          static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
    211          
    212          /*
    213           * The tick count has overflowed.  Switch the timer lists after ensuring the
    214           * current timer list does not still reference some timers.
    215           */
    216          static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
    217          
    218          /*
    219           * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
    220           * if a tick count overflow occurred since prvSampleTimeNow() was last called.
    221           */
    222          static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
    223          
    224          /*
    225           * If the timer list contains any active timers then return the expire time of
    226           * the timer that will expire first and set *pxListWasEmpty to false.  If the
    227           * timer list does not contain any timers then return 0 and set *pxListWasEmpty
    228           * to pdTRUE.
    229           */
    230          static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION;
    231          
    232          /*
    233           * If a timer has expired, process it.  Otherwise, block the timer service task
    234           * until either a timer does expire or a command is received.
    235           */
    236          static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
    237          
    238          /*-----------------------------------------------------------*/
    239          

   \                                 In section .text, align 4, keep-with-next
    240          BaseType_t xTimerCreateTimerTask( void )
    241          {
   \                     xTimerCreateTimerTask: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    242          BaseType_t xReturn = pdFAIL;
    243          
    244          	/* This function is called when the scheduler is started if
    245          	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
    246          	timer service task has been created/initialised.  If timers have already
    247          	been created then the initialisation will already have been performed. */
    248          	prvCheckForValidListAndQueue();
   \   00000004   0x.... 0x....      BL       prvCheckForValidListAndQueue
    249          
    250          	if( xTimerQueue != NULL )
   \   00000008   0x....             LDR      R0,??DataTable6
   \   0000000A   0x6880             LDR      R0,[R0, #+8]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00D             BEQ      ??xTimerCreateTimerTask_0
    251          	{
    252          		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
    253          		{
    254          			/* Create the timer task, storing its handle in xTimerTaskHandle so
    255          			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
    256          			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
    257          		}
    258          		#else
    259          		{
    260          			/* Create the timer task without storing its handle. */
    261          			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x9003             STR      R0,[SP, #+12]
   \   00000014   0x9002             STR      R0,[SP, #+8]
   \   00000016   0x9001             STR      R0,[SP, #+4]
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x2280             MOVS     R2,#+128
   \   00000020   0x....             ADR.N    R1,?_0
   \   00000022   0x....             LDR      R0,??DataTable7
   \   00000024   0x.... 0x....      BL       xTaskGenericCreate
    262          		}
    263          		#endif
    264          	}
    265          	else
    266          	{
    267          		mtCOVERAGE_TEST_MARKER();
    268          	}
    269          
    270          	configASSERT( xReturn );
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD101             BNE      ??xTimerCreateTimerTask_1
   \                     ??xTimerCreateTimerTask_0: (+1)
   \   0000002C   0xB672             cpsid i
   \                     ??xTimerCreateTimerTask_2: (+1)
   \   0000002E   0xE7FE             B        ??xTimerCreateTimerTask_2
    271          	return xReturn;
   \                     ??xTimerCreateTimerTask_1: (+1)
   \   00000030   0xB005             ADD      SP,SP,#+20
   \   00000032   0xBD00             POP      {PC}             ;; return
    272          }
    273          /*-----------------------------------------------------------*/
    274          

   \                                 In section .text, align 4, keep-with-next
    275          TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    276          {
   \                     xTimerCreate: (+1)
   \   00000000   0xB5F2             PUSH     {R1,R4-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x0017             MOVS     R7,R2
   \   00000006   0x001D             MOVS     R5,R3
    277          Timer_t *pxNewTimer;
    278          
    279          	/* Allocate the timer structure. */
    280          	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD101             BNE      ??xTimerCreate_0
    281          	{
    282          		pxNewTimer = NULL;
    283          	}
    284          	else
    285          	{
    286          		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    287          		if( pxNewTimer != NULL )
    288          		{
    289          			/* Ensure the infrastructure used by the timer service task has been
    290          			created/initialised. */
    291          			prvCheckForValidListAndQueue();
    292          
    293          			/* Initialise the timer structure members using the function parameters. */
    294          			pxNewTimer->pcTimerName = pcTimerName;
    295          			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    296          			pxNewTimer->uxAutoReload = uxAutoReload;
    297          			pxNewTimer->pvTimerID = pvTimerID;
    298          			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    299          			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    300          
    301          			traceTIMER_CREATE( pxNewTimer );
    302          		}
    303          		else
    304          		{
    305          			traceTIMER_CREATE_FAILED();
    306          		}
    307          	}
    308          
    309          	/* 0 is not a valid value for xTimerPeriodInTicks. */
    310          	configASSERT( ( xTimerPeriodInTicks > 0 ) );
   \   0000000C   0xB672             cpsid i
   \                     ??xTimerCreate_1: (+1)
   \   0000000E   0xE7FE             B        ??xTimerCreate_1
   \                     ??xTimerCreate_0: (+1)
   \   00000010   0x2028             MOVS     R0,#+40
   \   00000012   0x.... 0x....      BL       pvPortMalloc
   \   00000016   0x0006             MOVS     R6,R0
   \   00000018   0xD00B             BEQ      ??xTimerCreate_2
   \   0000001A   0x.... 0x....      BL       prvCheckForValidListAndQueue
   \   0000001E   0x6034             STR      R4,[R6, #+0]
   \   00000020   0x9800             LDR      R0,[SP, #+0]
   \   00000022   0x61B0             STR      R0,[R6, #+24]
   \   00000024   0x61F7             STR      R7,[R6, #+28]
   \   00000026   0x6235             STR      R5,[R6, #+32]
   \   00000028   0x9806             LDR      R0,[SP, #+24]
   \   0000002A   0x6270             STR      R0,[R6, #+36]
   \   0000002C   0x1D30             ADDS     R0,R6,#+4
   \   0000002E   0x.... 0x....      BL       vListInitialiseItem
    311          
    312          	return ( TimerHandle_t ) pxNewTimer;
   \                     ??xTimerCreate_2: (+1)
   \   00000032   0x0030             MOVS     R0,R6
   \   00000034   0xB001             ADD      SP,SP,#+4
   \   00000036   0xBDF0             POP      {R4-R7,PC}       ;; return
    313          }
    314          /*-----------------------------------------------------------*/
    315          

   \                                 In section .text, align 2, keep-with-next
    316          BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
    317          {
   \                     xTimerGenericCommand: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x001F             MOVS     R7,R3
    318          BaseType_t xReturn = pdFAIL;
   \   00000008   0x2000             MOVS     R0,#+0
    319          DaemonTaskMessage_t xMessage;
    320          
    321          	/* Send a message to the timer service task to perform a particular action
    322          	on a particular timer definition. */
    323          	if( xTimerQueue != NULL )
   \   0000000A   0x....             LDR      R4,??DataTable6
   \   0000000C   0x68A6             LDR      R6,[R4, #+8]
   \   0000000E   0x2E00             CMP      R6,#+0
   \   00000010   0xD018             BEQ      ??xTimerGenericCommand_0
    324          	{
    325          		/* Send a command to the timer service task to start the xTimer timer. */
    326          		xMessage.xMessageID = xCommandID;
   \   00000012   0x9100             STR      R1,[SP, #+0]
    327          		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
   \   00000014   0x9201             STR      R2,[SP, #+4]
    328          		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
   \   00000016   0x9502             STR      R5,[SP, #+8]
    329          
    330          		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
   \   00000018   0x2906             CMP      R1,#+6
   \   0000001A   0xDA0D             BGE      ??xTimerGenericCommand_1
    331          		{
    332          			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   \   0000001C   0x.... 0x....      BL       xTaskGetSchedulerState
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xD102             BNE      ??xTimerGenericCommand_2
    333          			{
    334          				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x9A0A             LDR      R2,[SP, #+40]
   \   00000028   0xE001             B.N      ??xTimerGenericCommand_3
    335          			}
    336          			else
    337          			{
    338          				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   \                     ??xTimerGenericCommand_2: (+1)
   \   0000002A   0x2300             MOVS     R3,#+0
   \   0000002C   0x2200             MOVS     R2,#+0
   \                     ??xTimerGenericCommand_3: (+1)
   \   0000002E   0x4669             MOV      R1,SP
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0x.... 0x....      BL       xQueueGenericSend
   \   00000036   0xE005             B        ??xTimerGenericCommand_0
    339          			}
    340          		}
    341          		else
    342          		{
    343          			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   \                     ??xTimerGenericCommand_1: (+1)
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x003A             MOVS     R2,R7
   \   0000003C   0x4669             MOV      R1,SP
   \   0000003E   0x0030             MOVS     R0,R6
   \   00000040   0x.... 0x....      BL       xQueueGenericSendFromISR
    344          		}
    345          
    346          		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
    347          	}
    348          	else
    349          	{
    350          		mtCOVERAGE_TEST_MARKER();
    351          	}
    352          
    353          	return xReturn;
   \                     ??xTimerGenericCommand_0: (+1)
   \   00000044   0xB005             ADD      SP,SP,#+20
   \   00000046   0xBDF0             POP      {R4-R7,PC}       ;; return
    354          }
    355          /*-----------------------------------------------------------*/
    356          
    357          #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
    358          
    359          	TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
    360          	{
    361          		/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
    362          		started, then xTimerTaskHandle will be NULL. */
    363          		configASSERT( ( xTimerTaskHandle != NULL ) );
    364          		return xTimerTaskHandle;
    365          	}
    366          
    367          #endif
    368          /*-----------------------------------------------------------*/
    369          

   \                                 In section .text, align 2, keep-with-next
    370          const char * pcTimerGetTimerName( TimerHandle_t xTimer )
    371          {
    372          Timer_t *pxTimer = ( Timer_t * ) xTimer;
    373          
    374          	return pxTimer->pcTimerName;
   \                     pcTimerGetTimerName: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x4770             BX       LR               ;; return
    375          }
    376          /*-----------------------------------------------------------*/
    377          

   \                                 In section .text, align 4, keep-with-next
    378          static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
    379          {
   \                     prvProcessExpiredTimer: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000E             MOVS     R6,R1
    380          BaseType_t xResult;
    381          Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   \   00000008   0x....             LDR      R4,??DataTable6
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x68C0             LDR      R0,[R0, #+12]
   \   0000000E   0x68C7             LDR      R7,[R0, #+12]
    382          
    383          	/* Remove the timer from the list of active timers.  A check has already
    384          	been performed to ensure the list is not empty. */
    385          	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   \   00000010   0x1D38             ADDS     R0,R7,#+4
   \   00000012   0x.... 0x....      BL       uxListRemove
    386          	traceTIMER_EXPIRED( pxTimer );
    387          
    388          	/* If the timer is an auto reload timer then calculate the next
    389          	expiry time and re-insert the timer in the list of active timers. */
    390          	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   \   00000016   0x69F8             LDR      R0,[R7, #+28]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD10D             BNE      ??prvProcessExpiredTimer_0
    391          	{
    392          		/* The timer is inserted into a list using a time relative to anything
    393          		other than the current time.  It will therefore be inserted into the
    394          		correct list relative to the time this task thinks it is now. */
    395          		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
   \   0000001C   0x69B8             LDR      R0,[R7, #+24]
   \   0000001E   0x1828             ADDS     R0,R5,R0
   \   00000020   0x6078             STR      R0,[R7, #+4]
   \   00000022   0x613F             STR      R7,[R7, #+16]
   \   00000024   0x4286             CMP      R6,R0
   \   00000026   0xD30C             BCC      ??prvProcessExpiredTimer_1
   \   00000028   0x1B70             SUBS     R0,R6,R5
   \   0000002A   0x69B9             LDR      R1,[R7, #+24]
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD20C             BCS      ??prvProcessExpiredTimer_2
   \   00000030   0x1D39             ADDS     R1,R7,#+4
   \   00000032   0x6860             LDR      R0,[R4, #+4]
   \                     ??prvProcessExpiredTimer_3: (+1)
   \   00000034   0x.... 0x....      BL       vListInsert
    396          		{
    397          			/* The timer expired before it was added to the active timer
    398          			list.  Reload it now.  */
    399          			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    400          			configASSERT( xResult );
    401          			( void ) xResult;
    402          		}
    403          		else
    404          		{
    405          			mtCOVERAGE_TEST_MARKER();
    406          		}
    407          	}
    408          	else
    409          	{
    410          		mtCOVERAGE_TEST_MARKER();
    411          	}
    412          
    413          	/* Call the timer callback. */
    414          	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   \                     ??prvProcessExpiredTimer_0: (+1)
   \   00000038   0x0038             MOVS     R0,R7
   \   0000003A   0x6A79             LDR      R1,[R7, #+36]
   \   0000003C   0x4788             BLX      R1
    415          }
   \   0000003E   0xB005             ADD      SP,SP,#+20
   \   00000040   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??prvProcessExpiredTimer_1: (+1)
   \   00000042   0x42AE             CMP      R6,R5
   \   00000044   0xD214             BCS      ??prvProcessExpiredTimer_4
   \   00000046   0x42A8             CMP      R0,R5
   \   00000048   0xD312             BCC      ??prvProcessExpiredTimer_4
   \                     ??prvProcessExpiredTimer_2: (+1)
   \   0000004A   0x68A0             LDR      R0,[R4, #+8]
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD00D             BEQ      ??prvProcessExpiredTimer_5
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x9000             STR      R0,[SP, #+0]
   \   00000054   0x9501             STR      R5,[SP, #+4]
   \   00000056   0x9702             STR      R7,[SP, #+8]
   \   00000058   0x.... 0x....      BL       xTaskGetSchedulerState
   \   0000005C   0x2300             MOVS     R3,#+0
   \   0000005E   0x2200             MOVS     R2,#+0
   \   00000060   0x4669             MOV      R1,SP
   \   00000062   0x68A0             LDR      R0,[R4, #+8]
   \   00000064   0x.... 0x....      BL       xQueueGenericSend
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD1E5             BNE      ??prvProcessExpiredTimer_0
   \                     ??prvProcessExpiredTimer_5: (+1)
   \   0000006C   0xB672             cpsid i
   \                     ??prvProcessExpiredTimer_6: (+1)
   \   0000006E   0xE7FE             B        ??prvProcessExpiredTimer_6
   \                     ??prvProcessExpiredTimer_4: (+1)
   \   00000070   0x1D39             ADDS     R1,R7,#+4
   \   00000072   0x6820             LDR      R0,[R4, #+0]
   \   00000074   0xE7DE             B        ??prvProcessExpiredTimer_3
    416          /*-----------------------------------------------------------*/
    417          

   \                                 In section .text, align 2, keep-with-next
    418          static void prvTimerTask( void *pvParameters )
    419          {
   \                     prvTimerTask: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x....             LDR      R7,??DataTable6
   \   00000006   0xE00B             B        ??prvTimerTask_0
    420          TickType_t xNextExpireTime;
    421          BaseType_t xListWasEmpty;
    422          
    423          	/* Just to avoid compiler warnings. */
    424          	( void ) pvParameters;
    425          
    426          	for( ;; )
    427          	{
   \                     ??prvTimerTask_1: (+1)
   \   00000008   0x1B29             SUBS     R1,R5,R4
   \   0000000A   0x68B8             LDR      R0,[R7, #+8]
   \   0000000C   0x.... 0x....      BL       vQueueWaitForMessageRestricted
   \   00000010   0x.... 0x....      BL       xTaskResumeAll
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD101             BNE      ??prvTimerTask_2
   \   00000018   0x.... 0x....      BL       vPortYield
    428          		/* Query the timers list to see if it contains any timers, and if so,
    429          		obtain the time at which the next timer will expire. */
    430          		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    431          
    432          		/* If a timer has expired, process it.  Otherwise, block this task
    433          		until either a timer does expire, or a command is received. */
    434          		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    435          
    436          		/* Empty the command queue. */
    437          		prvProcessReceivedCommands();
   \                     ??prvTimerTask_2: (+1)
   \   0000001C   0x.... 0x....      BL       prvProcessReceivedCommands
   \                     ??prvTimerTask_0: (+1)
   \   00000020   0x6838             LDR      R0,[R7, #+0]
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x2900             CMP      R1,#+0
   \   00000026   0xD102             BNE      ??prvTimerTask_3
   \   00000028   0x2601             MOVS     R6,#+1
   \   0000002A   0x2500             MOVS     R5,#+0
   \   0000002C   0xE002             B        ??prvTimerTask_4
   \                     ??prvTimerTask_3: (+1)
   \   0000002E   0x2600             MOVS     R6,#+0
   \   00000030   0x68C0             LDR      R0,[R0, #+12]
   \   00000032   0x6805             LDR      R5,[R0, #+0]
   \                     ??prvTimerTask_4: (+1)
   \   00000034   0x.... 0x....      BL       vTaskSuspendAll
   \   00000038   0x.... 0x....      BL       xTaskGetTickCount
   \   0000003C   0x0004             MOVS     R4,R0
   \   0000003E   0x68F8             LDR      R0,[R7, #+12]
   \   00000040   0x4284             CMP      R4,R0
   \   00000042   0xD205             BCS      ??prvTimerTask_5
   \   00000044   0x.... 0x....      BL       prvSwitchTimerLists
   \   00000048   0x60FC             STR      R4,[R7, #+12]
   \   0000004A   0x.... 0x....      BL       xTaskResumeAll
   \   0000004E   0xE7E5             B        ??prvTimerTask_2
   \                     ??prvTimerTask_5: (+1)
   \   00000050   0x60FC             STR      R4,[R7, #+12]
   \   00000052   0x2E00             CMP      R6,#+0
   \   00000054   0xD1D8             BNE      ??prvTimerTask_1
   \   00000056   0x42AC             CMP      R4,R5
   \   00000058   0xD3D6             BCC      ??prvTimerTask_1
   \   0000005A   0x.... 0x....      BL       xTaskResumeAll
   \   0000005E   0x0021             MOVS     R1,R4
   \   00000060   0x0028             MOVS     R0,R5
   \   00000062   0x.... 0x....      BL       prvProcessExpiredTimer
   \   00000066   0xE7D9             B        ??prvTimerTask_2
    438          	}
    439          }

   \                                 In section .bss, align 4
   \                     pxCurrentTimerList:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
   \   0000000C                      DS8 4
   \   00000010                      DS8 20
   \   00000024                      DS8 20
    440          /*-----------------------------------------------------------*/
    441          
    442          static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
    443          {
    444          TickType_t xTimeNow;
    445          BaseType_t xTimerListsWereSwitched;
    446          
    447          	vTaskSuspendAll();
    448          	{
    449          		/* Obtain the time now to make an assessment as to whether the timer
    450          		has expired or not.  If obtaining the time causes the lists to switch
    451          		then don't process this timer as any timers that remained in the list
    452          		when the lists were switched will have been processed within the
    453          		prvSampleTimeNow() function. */
    454          		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    455          		if( xTimerListsWereSwitched == pdFALSE )
    456          		{
    457          			/* The tick count has not overflowed, has the timer expired? */
    458          			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    459          			{
    460          				( void ) xTaskResumeAll();
    461          				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    462          			}
    463          			else
    464          			{
    465          				/* The tick count has not overflowed, and the next expire
    466          				time has not been reached yet.  This task should therefore
    467          				block to wait for the next expire time or a command to be
    468          				received - whichever comes first.  The following line cannot
    469          				be reached unless xNextExpireTime > xTimeNow, except in the
    470          				case when the current timer list is empty. */
    471          				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    472          
    473          				if( xTaskResumeAll() == pdFALSE )
    474          				{
    475          					/* Yield to wait for either a command to arrive, or the
    476          					block time to expire.  If a command arrived between the
    477          					critical section being exited and this yield then the yield
    478          					will not cause the task to block. */
    479          					portYIELD_WITHIN_API();
    480          				}
    481          				else
    482          				{
    483          					mtCOVERAGE_TEST_MARKER();
    484          				}
    485          			}
    486          		}
    487          		else
    488          		{
    489          			( void ) xTaskResumeAll();
    490          		}
    491          	}
    492          }
    493          /*-----------------------------------------------------------*/
    494          
    495          static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
    496          {
    497          TickType_t xNextExpireTime;
    498          
    499          	/* Timers are listed in expiry time order, with the head of the list
    500          	referencing the task that will expire first.  Obtain the time at which
    501          	the timer with the nearest expiry time will expire.  If there are no
    502          	active timers then just set the next expire time to 0.  That will cause
    503          	this task to unblock when the tick count overflows, at which point the
    504          	timer lists will be switched and the next expiry time can be
    505          	re-assessed.  */
    506          	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    507          	if( *pxListWasEmpty == pdFALSE )
    508          	{
    509          		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    510          	}
    511          	else
    512          	{
    513          		/* Ensure the task unblocks when the tick count rolls over. */
    514          		xNextExpireTime = ( TickType_t ) 0U;
    515          	}
    516          
    517          	return xNextExpireTime;
    518          }
    519          /*-----------------------------------------------------------*/
    520          
    521          static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
    522          {
    523          TickType_t xTimeNow;
    524          PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
    525          
    526          	xTimeNow = xTaskGetTickCount();
    527          
    528          	if( xTimeNow < xLastTime )
    529          	{
    530          		prvSwitchTimerLists();
    531          		*pxTimerListsWereSwitched = pdTRUE;
    532          	}
    533          	else
    534          	{
    535          		*pxTimerListsWereSwitched = pdFALSE;
    536          	}
    537          
    538          	xLastTime = xTimeNow;
    539          
    540          	return xTimeNow;
    541          }
    542          /*-----------------------------------------------------------*/
    543          
    544          static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
    545          {
    546          BaseType_t xProcessTimerNow = pdFALSE;
    547          
    548          	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    549          	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    550          
    551          	if( xNextExpiryTime <= xTimeNow )
    552          	{
    553          		/* Has the expiry time elapsed between the command to start/reset a
    554          		timer was issued, and the time the command was processed? */
    555          		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    556          		{
    557          			/* The time between a command being issued and the command being
    558          			processed actually exceeds the timers period.  */
    559          			xProcessTimerNow = pdTRUE;
    560          		}
    561          		else
    562          		{
    563          			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    564          		}
    565          	}
    566          	else
    567          	{
    568          		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    569          		{
    570          			/* If, since the command was issued, the tick count has overflowed
    571          			but the expiry time has not, then the timer must have already passed
    572          			its expiry time and should be processed immediately. */
    573          			xProcessTimerNow = pdTRUE;
    574          		}
    575          		else
    576          		{
    577          			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    578          		}
    579          	}
    580          
    581          	return xProcessTimerNow;
    582          }
    583          /*-----------------------------------------------------------*/
    584          

   \                                 In section .text, align 4, keep-with-next
    585          static void	prvProcessReceivedCommands( void )
    586          {
   \                     prvProcessReceivedCommands: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x....             LDR      R4,??DataTable6
   \   00000006   0xE002             B        ??prvProcessReceivedCommands_1
    587          DaemonTaskMessage_t xMessage;
    588          Timer_t *pxTimer;
    589          BaseType_t xTimerListsWereSwitched, xResult;
    590          TickType_t xTimeNow;
    591          
    592          	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    593          	{
    594          		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
    595          		{
    596          			/* Negative commands are pended function calls rather than timer
    597          			commands. */
    598          			if( xMessage.xMessageID < ( BaseType_t ) 0 )
    599          			{
    600          				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
    601          
    602          				/* The timer uses the xCallbackParameters member to request a
    603          				callback be executed.  Check the callback is not NULL. */
    604          				configASSERT( pxCallback );
    605          
    606          				/* Call the function. */
    607          				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
    608          			}
    609          			else
    610          			{
    611          				mtCOVERAGE_TEST_MARKER();
    612          			}
    613          		}
    614          		#endif /* INCLUDE_xTimerPendFunctionCall */
    615          
    616          		/* Commands that are positive are timer commands rather than pended
    617          		function calls. */
    618          		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    619          		{
    620          			/* The messages uses the xTimerParameters member to work on a
    621          			software timer. */
    622          			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    623          
    624          			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    625          			{
    626          				/* The timer is in a list, remove it. */
    627          				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    628          			}
    629          			else
    630          			{
    631          				mtCOVERAGE_TEST_MARKER();
    632          			}
    633          
    634          			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
    635          
    636          			/* In this case the xTimerListsWereSwitched parameter is not used, but
    637          			it must be present in the function call.  prvSampleTimeNow() must be
    638          			called after the message is received from xTimerQueue so there is no
    639          			possibility of a higher priority task adding a message to the message
    640          			queue with a time that is ahead of the timer daemon task (because it
    641          			pre-empted the timer daemon task after the xTimeNow value was set). */
    642          			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    643          
    644          			switch( xMessage.xMessageID )
    645          			{
    646          				case tmrCOMMAND_START :
    647          			    case tmrCOMMAND_START_FROM_ISR :
    648          			    case tmrCOMMAND_RESET :
    649          			    case tmrCOMMAND_RESET_FROM_ISR :
    650          				case tmrCOMMAND_START_DONT_TRACE :
    651          					/* Start or restart a timer. */
    652          					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    653          					{
    654          						/* The timer expired before it was added to the active
    655          						timer list.  Process it now. */
    656          						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    657          						traceTIMER_EXPIRED( pxTimer );
    658          
    659          						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    660          						{
    661          							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    662          							configASSERT( xResult );
    663          							( void ) xResult;
    664          						}
    665          						else
    666          						{
    667          							mtCOVERAGE_TEST_MARKER();
    668          						}
    669          					}
    670          					else
    671          					{
    672          						mtCOVERAGE_TEST_MARKER();
    673          					}
    674          					break;
    675          
    676          				case tmrCOMMAND_STOP :
    677          				case tmrCOMMAND_STOP_FROM_ISR :
    678          					/* The timer has already been removed from the active list.
    679          					There is nothing to do here. */
    680          					break;
    681          
    682          				case tmrCOMMAND_CHANGE_PERIOD :
    683          				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
    684          					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    685          					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
    686          
    687          					/* The new period does not really have a reference, and can be
    688          					longer or shorter than the old one.  The command time is
    689          					therefore set to the current time, and as the period cannot be
    690          					zero the next expiry time can only be in the future, meaning
    691          					(unlike for the xTimerStart() case above) there is no fail case
    692          					that needs to be handled here. */
    693          					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    694          					break;
    695          
    696          				case tmrCOMMAND_DELETE :
    697          					/* The timer has already been removed from the active list,
    698          					just free up the memory. */
    699          					vPortFree( pxTimer );
   \                     ??prvProcessReceivedCommands_2: (+1)
   \   00000008   0x0028             MOVS     R0,R5
   \   0000000A   0x.... 0x....      BL       vPortFree
    700          					break;
   \                     ??prvProcessReceivedCommands_1: (+1)
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x4669             MOV      R1,SP
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0x.... 0x....      BL       xQueueGenericReceive
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD062             BEQ      ??prvProcessReceivedCommands_3
   \   0000001E   0x9800             LDR      R0,[SP, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD503             BPL      ??prvProcessReceivedCommands_4
   \   00000024   0x9903             LDR      R1,[SP, #+12]
   \   00000026   0x9802             LDR      R0,[SP, #+8]
   \   00000028   0x9A01             LDR      R2,[SP, #+4]
   \   0000002A   0x4790             BLX      R2
   \                     ??prvProcessReceivedCommands_4: (+1)
   \   0000002C   0x9800             LDR      R0,[SP, #+0]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD4ED             BMI      ??prvProcessReceivedCommands_1
   \   00000032   0x9D02             LDR      R5,[SP, #+8]
   \   00000034   0x6968             LDR      R0,[R5, #+20]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD002             BEQ      ??prvProcessReceivedCommands_5
   \   0000003A   0x1D28             ADDS     R0,R5,#+4
   \   0000003C   0x.... 0x....      BL       uxListRemove
   \                     ??prvProcessReceivedCommands_5: (+1)
   \   00000040   0x.... 0x....      BL       xTaskGetTickCount
   \   00000044   0x0006             MOVS     R6,R0
   \   00000046   0x68E0             LDR      R0,[R4, #+12]
   \   00000048   0x4286             CMP      R6,R0
   \   0000004A   0xD201             BCS      ??prvProcessReceivedCommands_6
   \   0000004C   0x.... 0x....      BL       prvSwitchTimerLists
   \                     ??prvProcessReceivedCommands_6: (+1)
   \   00000050   0x60E6             STR      R6,[R4, #+12]
   \   00000052   0x9800             LDR      R0,[SP, #+0]
   \   00000054   0x2809             CMP      R0,#+9
   \   00000056   0xD8DA             BHI      ??prvProcessReceivedCommands_1
   \   00000058   0xA101             ADR      R1,??prvProcessReceivedCommands_0
   \   0000005A   0x5609             LDRSB    R1,[R1, R0]
   \   0000005C   0x448F             ADD      PC,PC,R1
   \   0000005E   0xBF00             Nop      
   \                     ??prvProcessReceivedCommands_0:
   \   00000060   0x0A 0x0A          DC8      0xA,0xA,0xA,0xAE
   \              0x0A 0xAE    
   \   00000064   0x68 0xA8          DC8      0x68,0xA8,0xA,0xA
   \              0x0A 0x0A    
   \   00000068   0xAE 0x68          DC8      0xAE,0x68
   \                     ??prvProcessReceivedCommands_7: (+1)
   \   0000006A   0x9801             LDR      R0,[SP, #+4]
   \   0000006C   0x69A9             LDR      R1,[R5, #+24]
   \   0000006E   0x1842             ADDS     R2,R0,R1
   \   00000070   0x606A             STR      R2,[R5, #+4]
   \   00000072   0x612D             STR      R5,[R5, #+16]
   \   00000074   0x4296             CMP      R6,R2
   \   00000076   0xD307             BCC      ??prvProcessReceivedCommands_8
   \   00000078   0x1A30             SUBS     R0,R6,R0
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD208             BCS      ??prvProcessReceivedCommands_9
   \                     ??prvProcessReceivedCommands_10: (+1)
   \   0000007E   0x1D29             ADDS     R1,R5,#+4
   \   00000080   0x6860             LDR      R0,[R4, #+4]
   \                     ??prvProcessReceivedCommands_11: (+1)
   \   00000082   0x.... 0x....      BL       vListInsert
   \   00000086   0xE7C2             B        ??prvProcessReceivedCommands_1
   \                     ??prvProcessReceivedCommands_8: (+1)
   \   00000088   0x4286             CMP      R6,R0
   \   0000008A   0xD228             BCS      ??prvProcessReceivedCommands_12
   \   0000008C   0x4282             CMP      R2,R0
   \   0000008E   0xD326             BCC      ??prvProcessReceivedCommands_12
   \                     ??prvProcessReceivedCommands_9: (+1)
   \   00000090   0x0028             MOVS     R0,R5
   \   00000092   0x6A69             LDR      R1,[R5, #+36]
   \   00000094   0x4788             BLX      R1
   \   00000096   0x69E8             LDR      R0,[R5, #+28]
   \   00000098   0x2801             CMP      R0,#+1
   \   0000009A   0xD1B8             BNE      ??prvProcessReceivedCommands_1
   \   0000009C   0x9801             LDR      R0,[SP, #+4]
   \   0000009E   0x69A9             LDR      R1,[R5, #+24]
   \   000000A0   0x1840             ADDS     R0,R0,R1
   \   000000A2   0x68A1             LDR      R1,[R4, #+8]
   \   000000A4   0x2900             CMP      R1,#+0
   \   000000A6   0xD00D             BEQ      ??prvProcessReceivedCommands_13
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0x9104             STR      R1,[SP, #+16]
   \   000000AC   0x9005             STR      R0,[SP, #+20]
   \   000000AE   0x9506             STR      R5,[SP, #+24]
   \   000000B0   0x.... 0x....      BL       xTaskGetSchedulerState
   \   000000B4   0x2300             MOVS     R3,#+0
   \   000000B6   0x2200             MOVS     R2,#+0
   \   000000B8   0xA904             ADD      R1,SP,#+16
   \   000000BA   0x68A0             LDR      R0,[R4, #+8]
   \   000000BC   0x.... 0x....      BL       xQueueGenericSend
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD1A4             BNE      ??prvProcessReceivedCommands_1
   \                     ??prvProcessReceivedCommands_13: (+1)
   \   000000C4   0xB672             cpsid i
   \                     ??prvProcessReceivedCommands_14: (+1)
   \   000000C6   0xE7FE             B        ??prvProcessReceivedCommands_14
   \                     ??prvProcessReceivedCommands_15: (+1)
   \   000000C8   0x9801             LDR      R0,[SP, #+4]
   \   000000CA   0x61A8             STR      R0,[R5, #+24]
   \   000000CC   0x2800             CMP      R0,#+0
   \   000000CE   0xD101             BNE      ??prvProcessReceivedCommands_16
   \   000000D0   0xB672             cpsid i
   \                     ??prvProcessReceivedCommands_17: (+1)
   \   000000D2   0xE7FE             B        ??prvProcessReceivedCommands_17
   \                     ??prvProcessReceivedCommands_16: (+1)
   \   000000D4   0x1830             ADDS     R0,R6,R0
   \   000000D6   0x6068             STR      R0,[R5, #+4]
   \   000000D8   0x612D             STR      R5,[R5, #+16]
   \   000000DA   0x4286             CMP      R6,R0
   \   000000DC   0xD2CF             BCS      ??prvProcessReceivedCommands_10
   \                     ??prvProcessReceivedCommands_12: (+1)
   \   000000DE   0x1D29             ADDS     R1,R5,#+4
   \   000000E0   0x6820             LDR      R0,[R4, #+0]
   \   000000E2   0xE7CE             B.N      ??prvProcessReceivedCommands_11
    701          
    702          				default	:
    703          					/* Don't expect to get here. */
    704          					break;
    705          			}
    706          		}
    707          	}
    708          }
   \                     ??prvProcessReceivedCommands_3: (+1)
   \   000000E4   0xB008             ADD      SP,SP,#+32
   \   000000E6   0xBD70             POP      {R4-R6,PC}       ;; return
    709          /*-----------------------------------------------------------*/
    710          

   \                                 In section .text, align 4, keep-with-next
    711          static void prvSwitchTimerLists( void )
    712          {
   \                     prvSwitchTimerLists: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x2700             MOVS     R7,#+0
   \   00000006   0x....             LDR      R4,??DataTable10
   \   00000008   0xE005             B        ??prvSwitchTimerLists_0
    713          TickType_t xNextExpireTime, xReloadTime;
    714          List_t *pxTemp;
    715          Timer_t *pxTimer;
    716          BaseType_t xResult;
    717          
    718          	/* The tick count has overflowed.  The timer lists must be switched.
    719          	If there are any timers still referenced from the current timer list
    720          	then they must have expired and should be processed before the lists
    721          	are switched. */
    722          	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    723          	{
    724          		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    725          
    726          		/* Remove the timer from the list. */
    727          		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    728          		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    729          		traceTIMER_EXPIRED( pxTimer );
    730          
    731          		/* Execute its callback, then send a command to restart the timer if
    732          		it is an auto-reload timer.  It cannot be restarted here as the lists
    733          		have not yet been switched. */
    734          		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    735          
    736          		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    737          		{
    738          			/* Calculate the reload value, and if the reload value results in
    739          			the timer going into the same timer list then it has already expired
    740          			and the timer should be re-inserted into the current list so it is
    741          			processed again within this loop.  Otherwise a command should be sent
    742          			to restart the timer to ensure it is only inserted into a list after
    743          			the lists have been swapped. */
    744          			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    745          			if( xReloadTime > xNextExpireTime )
    746          			{
    747          				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   \                     ??prvSwitchTimerLists_1: (+1)
   \   0000000A   0x6068             STR      R0,[R5, #+4]
    748          				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   \   0000000C   0x612D             STR      R5,[R5, #+16]
    749          				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   \   0000000E   0x1D29             ADDS     R1,R5,#+4
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x.... 0x....      BL       vListInsert
    750          			}
   \                     ??prvSwitchTimerLists_0: (+1)
   \   00000016   0x6820             LDR      R0,[R4, #+0]
   \   00000018   0x6801             LDR      R1,[R0, #+0]
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xD021             BEQ      ??prvSwitchTimerLists_2
   \   0000001E   0x68C0             LDR      R0,[R0, #+12]
   \   00000020   0x6806             LDR      R6,[R0, #+0]
   \   00000022   0x68C5             LDR      R5,[R0, #+12]
   \   00000024   0x1D28             ADDS     R0,R5,#+4
   \   00000026   0x.... 0x....      BL       uxListRemove
   \   0000002A   0x0028             MOVS     R0,R5
   \   0000002C   0x6A69             LDR      R1,[R5, #+36]
   \   0000002E   0x4788             BLX      R1
   \   00000030   0x69E8             LDR      R0,[R5, #+28]
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD1EF             BNE      ??prvSwitchTimerLists_0
   \   00000036   0x69A8             LDR      R0,[R5, #+24]
   \   00000038   0x1830             ADDS     R0,R6,R0
   \   0000003A   0x4286             CMP      R6,R0
   \   0000003C   0xD3E5             BCC      ??prvSwitchTimerLists_1
    751          			else
    752          			{
    753          				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    754          				configASSERT( xResult );
   \   0000003E   0x68A0             LDR      R0,[R4, #+8]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD00C             BEQ      ??prvSwitchTimerLists_3
   \   00000044   0x9700             STR      R7,[SP, #+0]
   \   00000046   0x9601             STR      R6,[SP, #+4]
   \   00000048   0x9502             STR      R5,[SP, #+8]
   \   0000004A   0x.... 0x....      BL       xTaskGetSchedulerState
   \   0000004E   0x2300             MOVS     R3,#+0
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x4669             MOV      R1,SP
   \   00000054   0x68A0             LDR      R0,[R4, #+8]
   \   00000056   0x.... 0x....      BL       xQueueGenericSend
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD1DB             BNE      ??prvSwitchTimerLists_0
   \                     ??prvSwitchTimerLists_3: (+1)
   \   0000005E   0xB672             cpsid i
   \                     ??prvSwitchTimerLists_4: (+1)
   \   00000060   0xE7FE             B        ??prvSwitchTimerLists_4
    755          				( void ) xResult;
    756          			}
    757          		}
    758          		else
    759          		{
    760          			mtCOVERAGE_TEST_MARKER();
    761          		}
    762          	}
    763          
    764          	pxTemp = pxCurrentTimerList;
    765          	pxCurrentTimerList = pxOverflowTimerList;
   \                     ??prvSwitchTimerLists_2: (+1)
   \   00000062   0x6861             LDR      R1,[R4, #+4]
   \   00000064   0x6021             STR      R1,[R4, #+0]
    766          	pxOverflowTimerList = pxTemp;
   \   00000066   0x6060             STR      R0,[R4, #+4]
    767          }
   \   00000068   0xB005             ADD      SP,SP,#+20
   \   0000006A   0xBDF0             POP      {R4-R7,PC}       ;; return
    768          /*-----------------------------------------------------------*/
    769          

   \                                 In section .text, align 4, keep-with-next
    770          static void prvCheckForValidListAndQueue( void )
    771          {
   \                     prvCheckForValidListAndQueue: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    772          	/* Check that the list from which active timers are referenced, and the
    773          	queue used to communicate with the timer service, have been
    774          	initialised. */
    775          	taskENTER_CRITICAL();
   \   00000002   0x.... 0x....      BL       vPortEnterCritical
    776          	{
    777          		if( xTimerQueue == NULL )
   \   00000006   0x....             LDR      R4,??DataTable10
   \   00000008   0x68A0             LDR      R0,[R4, #+8]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD11B             BNE      ??prvCheckForValidListAndQueue_0
    778          		{
    779          			vListInitialise( &xActiveTimerList1 );
   \   0000000E   0x0020             MOVS     R0,R4
   \   00000010   0x3010             ADDS     R0,R0,#+16
   \   00000012   0x.... 0x....      BL       vListInitialise
    780          			vListInitialise( &xActiveTimerList2 );
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0x3024             ADDS     R0,R0,#+36
   \   0000001A   0x.... 0x....      BL       vListInitialise
    781          			pxCurrentTimerList = &xActiveTimerList1;
   \   0000001E   0x0020             MOVS     R0,R4
   \   00000020   0x3010             ADDS     R0,R0,#+16
   \   00000022   0x6020             STR      R0,[R4, #+0]
    782          			pxOverflowTimerList = &xActiveTimerList2;
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x3024             ADDS     R0,R0,#+36
   \   00000028   0x6060             STR      R0,[R4, #+4]
    783          			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2110             MOVS     R1,#+16
   \   0000002E   0x200A             MOVS     R0,#+10
   \   00000030   0x.... 0x....      BL       xQueueGenericCreate
   \   00000034   0x60A0             STR      R0,[R4, #+8]
    784          			configASSERT( xTimerQueue );
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD101             BNE      ??prvCheckForValidListAndQueue_1
   \   0000003A   0xB672             cpsid i
   \                     ??prvCheckForValidListAndQueue_2: (+1)
   \   0000003C   0xE7FE             B        ??prvCheckForValidListAndQueue_2
    785          
    786          			#if ( configQUEUE_REGISTRY_SIZE > 0 )
    787          			{
    788          				if( xTimerQueue != NULL )
    789          				{
    790          					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
   \                     ??prvCheckForValidListAndQueue_1: (+1)
   \   0000003E   0xBF00             Nop      
   \   00000040   0x....             ADR.N    R1,?_1
   \   00000042   0x.... 0x....      BL       vQueueAddToRegistry
    791          				}
    792          				else
    793          				{
    794          					mtCOVERAGE_TEST_MARKER();
    795          				}
    796          			}
    797          			#endif /* configQUEUE_REGISTRY_SIZE */
    798          		}
    799          		else
    800          		{
    801          			mtCOVERAGE_TEST_MARKER();
    802          		}
    803          	}
    804          	taskEXIT_CRITICAL();
   \                     ??prvCheckForValidListAndQueue_0: (+1)
   \   00000046   0x.... 0x....      BL       vPortExitCritical
    805          }
   \   0000004A   0xBD10             POP      {R4,PC}          ;; return
    806          /*-----------------------------------------------------------*/
    807          

   \                                 In section .text, align 2, keep-with-next
    808          BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
    809          {
   \                     xTimerIsTimerActive: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    810          BaseType_t xTimerIsInActiveList;
    811          Timer_t *pxTimer = ( Timer_t * ) xTimer;
    812          
    813          	/* Is the timer in the list of active timers? */
    814          	taskENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       vPortEnterCritical
    815          	{
    816          		/* Checking to see if it is in the NULL list in effect checks to see if
    817          		it is referenced from either the current or the overflow timer lists in
    818          		one go, but the logic has to be reversed, hence the '!'. */
    819          		xTimerIsInActiveList = ( BaseType_t ) !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
   \   00000008   0x6960             LDR      R0,[R4, #+20]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD001             BEQ      ??xTimerIsTimerActive_0
   \   0000000E   0x2401             MOVS     R4,#+1
   \   00000010   0xE000             B        ??xTimerIsTimerActive_1
   \                     ??xTimerIsTimerActive_0: (+1)
   \   00000012   0x2400             MOVS     R4,#+0
    820          	}
    821          	taskEXIT_CRITICAL();
   \                     ??xTimerIsTimerActive_1: (+1)
   \   00000014   0x.... 0x....      BL       vPortExitCritical
    822          
    823          	return xTimerIsInActiveList;
   \   00000018   0x0020             MOVS     R0,R4
   \   0000001A   0xBD10             POP      {R4,PC}          ;; return
    824          } /*lint !e818 Can't be pointer to const due to the typedef. */
    825          /*-----------------------------------------------------------*/
    826          

   \                                 In section .text, align 4, keep-with-next
    827          void *pvTimerGetTimerID( const TimerHandle_t xTimer )
    828          {
   \                     pvTimerGetTimerID: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    829          Timer_t * const pxTimer = ( Timer_t * ) xTimer;
    830          void *pvReturn;
    831          
    832          	configASSERT( xTimer );
   \   00000004   0x2C00             CMP      R4,#+0
   \   00000006   0xD101             BNE      ??pvTimerGetTimerID_0
   \   00000008   0xB672             cpsid i
   \                     ??pvTimerGetTimerID_1: (+1)
   \   0000000A   0xE7FE             B        ??pvTimerGetTimerID_1
    833          
    834          	taskENTER_CRITICAL();
   \                     ??pvTimerGetTimerID_0: (+1)
   \   0000000C   0x.... 0x....      BL       vPortEnterCritical
    835          	{
    836          		pvReturn = pxTimer->pvTimerID;
   \   00000010   0x6A24             LDR      R4,[R4, #+32]
    837          	}
    838          	taskEXIT_CRITICAL();
   \   00000012   0x.... 0x....      BL       vPortExitCritical
    839          
    840          	return pvReturn;
   \   00000016   0x0020             MOVS     R0,R4
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
    841          }
    842          /*-----------------------------------------------------------*/
    843          

   \                                 In section .text, align 4, keep-with-next
    844          void vTimerSetTimerID( const TimerHandle_t xTimer, void *pvNewID )
    845          {
   \                     vTimerSetTimerID: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x0005             MOVS     R5,R0
   \   00000006   0x000C             MOVS     R4,R1
    846          Timer_t * const pxTimer = ( Timer_t * ) xTimer;
    847          
    848          	configASSERT( xTimer );
   \   00000008   0x2D00             CMP      R5,#+0
   \   0000000A   0xD101             BNE      ??vTimerSetTimerID_0
   \   0000000C   0xB672             cpsid i
   \                     ??vTimerSetTimerID_1: (+1)
   \   0000000E   0xE7FE             B        ??vTimerSetTimerID_1
    849          
    850          	taskENTER_CRITICAL();
   \                     ??vTimerSetTimerID_0: (+1)
   \   00000010   0x.... 0x....      BL       vPortEnterCritical
    851          	{
    852          		pxTimer->pvTimerID = pvNewID;
   \   00000014   0x622C             STR      R4,[R5, #+32]
    853          	}
    854          	taskEXIT_CRITICAL();
   \   00000016   0x.... 0x....      BL       vPortExitCritical
    855          }
   \   0000001A   0xB001             ADD      SP,SP,#+4
   \   0000001C   0xBD30             POP      {R4,R5,PC}       ;; return
    856          /*-----------------------------------------------------------*/
    857          
    858          #if( INCLUDE_xTimerPendFunctionCall == 1 )
    859          

   \                                 In section .text, align 2, keep-with-next
    860          	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
    861          	{
   \                     xTimerPendFunctionCallFromISR: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x001C             MOVS     R4,R3
    862          	DaemonTaskMessage_t xMessage;
    863          	BaseType_t xReturn;
    864          
    865          		/* Complete the message with the function parameters and post it to the
    866          		daemon task. */
    867          		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
   \   00000006   0x2301             MOVS     R3,#+1
   \   00000008   0x43DB             MVNS     R3,R3            ;; #-2
   \   0000000A   0x9300             STR      R3,[SP, #+0]
    868          		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
   \   0000000C   0x9001             STR      R0,[SP, #+4]
    869          		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
   \   0000000E   0x9102             STR      R1,[SP, #+8]
    870          		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
   \   00000010   0x9203             STR      R2,[SP, #+12]
    871          
    872          		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    873          
    874          		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
    875          
    876          		return xReturn;
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x0022             MOVS     R2,R4
   \   00000016   0x4669             MOV      R1,SP
   \   00000018   0x....             LDR      R0,??DataTable10
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x.... 0x....      BL       xQueueGenericSendFromISR
   \   00000020   0xB004             ADD      SP,SP,#+16
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
    877          	}
    878          
    879          #endif /* INCLUDE_xTimerPendFunctionCall */
    880          /*-----------------------------------------------------------*/
    881          
    882          #if( INCLUDE_xTimerPendFunctionCall == 1 )
    883          

   \                                 In section .text, align 4, keep-with-next
    884          	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
    885          	{
   \                     xTimerPendFunctionCall: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x001D             MOVS     R5,R3
   \   00000006   0x....             LDR      R3,??DataTable10
   \   00000008   0x689C             LDR      R4,[R3, #+8]
   \   0000000A   0x2C00             CMP      R4,#+0
   \   0000000C   0xD101             BNE      ??xTimerPendFunctionCall_0
    886          	DaemonTaskMessage_t xMessage;
    887          	BaseType_t xReturn;
    888          
    889          		/* This function can only be called after a timer has been created or
    890          		after the scheduler has been started because, until then, the timer
    891          		queue does not exist. */
    892          		configASSERT( xTimerQueue );
   \   0000000E   0xB672             cpsid i
   \                     ??xTimerPendFunctionCall_1: (+1)
   \   00000010   0xE7FE             B        ??xTimerPendFunctionCall_1
    893          
    894          		/* Complete the message with the function parameters and post it to the
    895          		daemon task. */
    896          		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
   \                     ??xTimerPendFunctionCall_0: (+1)
   \   00000012   0x2300             MOVS     R3,#+0
   \   00000014   0x43DB             MVNS     R3,R3            ;; #-1
   \   00000016   0x9300             STR      R3,[SP, #+0]
    897          		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
   \   00000018   0x9001             STR      R0,[SP, #+4]
    898          		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
   \   0000001A   0x9102             STR      R1,[SP, #+8]
    899          		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
   \   0000001C   0x9203             STR      R2,[SP, #+12]
    900          
    901          		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    902          
    903          		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
    904          
    905          		return xReturn;
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x002A             MOVS     R2,R5
   \   00000022   0x4669             MOV      R1,SP
   \   00000024   0x0020             MOVS     R0,R4
   \   00000026   0x.... 0x....      BL       xQueueGenericSend
   \   0000002A   0xB005             ADD      SP,SP,#+20
   \   0000002C   0xBD30             POP      {R4,R5,PC}       ;; return
    906          	}

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \   00000000   0x54 0x6D          DC8 "Tmr Svc"
   \              0x72 0x20    
   \              0x53 0x76    
   \              0x63 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     pxCurrentTimerList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x........         DC32     prvTimerTask

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     pxCurrentTimerList

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \   00000000   0x54 0x6D          DC8 "TmrQ"
   \              0x72 0x51    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    907          
    908          #endif /* INCLUDE_xTimerPendFunctionCall */
    909          /*-----------------------------------------------------------*/
    910          
    911          /* This entire source file will be skipped if the application is not configured
    912          to include software timer functionality.  If you want to include software timer
    913          functionality then ensure configUSE_TIMERS is set to 1 in freertos_cfg.h. */
    914          #endif /* configUSE_TIMERS == 1 */
    915          
    916          
    917          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   pcTimerGetTimerName
       8   prvCheckForValidListAndQueue
         8   -> vListInitialise
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
         8   -> vQueueAddToRegistry
         8   -> xQueueGenericCreate
      40   prvProcessExpiredTimer
        40   -- Indirect call
        40   -> uxListRemove
        40   -> vListInsert
        40   -> xQueueGenericSend
        40   -> xTaskGetSchedulerState
      48   prvProcessReceivedCommands
        48   -- Indirect call
        48   -> prvSwitchTimerLists
        48   -> uxListRemove
        48   -> vListInsert
        48   -> vPortFree
        48   -> xQueueGenericReceive
        48   -> xQueueGenericSend
        48   -> xTaskGetSchedulerState
        48   -> xTaskGetTickCount
      40   prvSwitchTimerLists
        40   -- Indirect call
        40   -> uxListRemove
        40   -> vListInsert
        40   -> xQueueGenericSend
        40   -> xTaskGetSchedulerState
      24   prvTimerTask
        24   -> prvProcessExpiredTimer
        24   -> prvProcessReceivedCommands
        24   -> prvSwitchTimerLists
        24   -> vPortYield
        24   -> vQueueWaitForMessageRestricted
        24   -> vTaskSuspendAll
        24   -> xTaskGetTickCount
        24   -> xTaskResumeAll
       8   pvTimerGetTimerID
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      16   vTimerSetTimerID
        16   -> vPortEnterCritical
        16   -> vPortExitCritical
      24   xTimerCreate
        24   -> prvCheckForValidListAndQueue
        24   -> pvPortMalloc
        24   -> vListInitialiseItem
      24   xTimerCreateTimerTask
        24   -> prvCheckForValidListAndQueue
        24   -> xTaskGenericCreate
      40   xTimerGenericCommand
        40   -> xQueueGenericSend
        40   -> xQueueGenericSendFromISR
        40   -> xTaskGetSchedulerState
       8   xTimerIsTimerActive
         8   -> vPortEnterCritical
         8   -> vPortExitCritical
      32   xTimerPendFunctionCall
        32   -> xQueueGenericSend
      24   xTimerPendFunctionCallFromISR
        24   -> xQueueGenericSendFromISR


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable6
       4  ??DataTable7
       8  ?_0
       8  ?_1
       4  pcTimerGetTimerName
      76  prvCheckForValidListAndQueue
     118  prvProcessExpiredTimer
     232  prvProcessReceivedCommands
     108  prvSwitchTimerLists
     104  prvTimerTask
      26  pvTimerGetTimerID
      56  pxCurrentTimerList
          pxOverflowTimerList
          xTimerQueue
          xLastTime
          xActiveTimerList1
          xActiveTimerList2
      30  vTimerSetTimerID
      56  xTimerCreate
      52  xTimerCreateTimerTask
      72  xTimerGenericCommand
      28  xTimerIsTimerActive
      46  xTimerPendFunctionCall
      36  xTimerPendFunctionCallFromISR

 
    56 bytes in section .bss
 1 016 bytes in section .text
 
 1 016 bytes of CODE memory
    56 bytes of DATA memory

Errors: none
Warnings: none
